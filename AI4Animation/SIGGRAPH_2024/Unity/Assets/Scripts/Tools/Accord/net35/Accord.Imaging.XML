<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Accord.Imaging</name>
    </assembly>
    <members>
        <member name="T:Accord.DataSets.TestImages">
            <summary>
              Public-Domain test images for image processing applications.
            </summary>
            
            <remarks>
            <para>
              This dataset contains famous images used in the image processing literature, such as 
              <a href="https://en.wikipedia.org/wiki/Lenna">Lena SÃ¶derberg</a> picture.</para>
              
            <para>Using this class, you can retrieve any of the following famous test images:</para>
            
            <list type="bullet">
             <list><description>airplane.png  </description></list>
             <list><description>arctichare.png</description></list>
             <list><description>baboon.png    </description></list>
             <list><description>barbara.bmp   </description></list>
             <list><description>barbara.png   </description></list>
             <list><description>boat.png      </description></list>
             <list><description>boy.bmp       </description></list>
             <list><description>boy.ppm       </description></list>
             <list><description>cameraman.tif </description></list>
             <list><description>cat.png       </description></list>
             <list><description>fprint3.pgm   </description></list>
             <list><description>fruits.png    </description></list>
             <list><description>frymire.png   </description></list>
             <list><description>girl.png      </description></list>
             <list><description>goldhill.bmp  </description></list>
             <list><description>goldhill.png  </description></list>
             <list><description>lena.bmp      </description></list>
             <list><description>lenacolor.png </description></list>
             <list><description>lena.ppm      </description></list>
             <list><description>Lenaclor.ppm  </description></list>
             <list><description>monarch.png   </description></list>
             <list><description>mountain.png  </description></list>
             <list><description>mountain.bmp  </description></list>
             <list><description>p64int.txt    </description></list>
             <list><description>peppers.png   </description></list>
             <list><description>pool.png      </description></list>
             <list><description>sails.bmp     </description></list>
             <list><description>sails.png     </description></list>
             <list><description>serrano.png   </description></list>
             <list><description>tulips.png    </description></list>
             <list><description>us021.pgm     </description></list>
             <list><description>us092.pgm     </description></list>
             <list><description>watch.png     </description></list>
             <list><description>zelda.png     </description></list>
            </list>
              
            <para>
              References:
              <list type="bullet">
                <item><description><a href="https://homepages.cae.wisc.edu/~ece533/images/">
                  ECE533 Digital Image Processing. "Public-Domain Test Images for Homeworks and Projects.",
                  University of Wisconsin-Madison, Fall 2012.</a>
                  </description></item>
               </list></para>
            </remarks>
            
            <example>
            <code source="Unit Tests\Accord.Tests.Imaging\HistogramsOfOrientedGradientsTest.cs" region="doc_apply" />
            </example>
            
        </member>
        <member name="P:Accord.DataSets.TestImages.ImageNames">
            <summary>
              Gets all the image names that can be passed to
              the <see cref="M:Accord.DataSets.TestImages.GetImage(System.String)"/> method.
            </summary>
            
            <value>The image names in this dataset.</value>
            
        </member>
        <member name="P:Accord.DataSets.TestImages.CorrectIndexedPalettes">
            <summary>
              Gets or sets whether images with non-standard color palettes (i.e. 8-bpp images where
              values do not represent intensity values but rather indices in a color palette) should
              be converted to true 8-bpp grayscale. Default is true.
            </summary>
            
            <seealso cref="M:Accord.Imaging.Image.ConvertColor8bppToGrayscale8bpp(System.Drawing.Bitmap)"/>
            
        </member>
        <member name="M:Accord.DataSets.TestImages.#ctor(System.String)">
            <summary>
              Downloads and prepares the test images dataset.
            </summary>
            
            <param name="path">The path where datasets will be stored. If null or empty, the dataset
            will be saved on a subfolder called "data" in the current working directory.</param>
            
        </member>
        <member name="P:Accord.DataSets.TestImages.Item(System.String)">
            <summary>
              Gets the example <see cref="T:System.Drawing.Bitmap"/> with the specified name.
            </summary>
            
            <param name="name">The standard image name. For a list of all possible names, see <see cref="P:Accord.DataSets.TestImages.ImageNames"/>.</param>
            
        </member>
        <member name="M:Accord.DataSets.TestImages.GetImage(System.String)">
            <summary>
              Gets the example image.
            </summary>
            
            <param name="name">The standard image name. For a list of all possible names, see <see cref="P:Accord.DataSets.TestImages.ImageNames"/>.</param>
            
        </member>
        <member name="T:Accord.Imaging.BaseCornersDetector">
            <summary>
              Base class for corner detectors implementing the <see cref="T:Accord.Imaging.ICornersDetector"/> interface.
              Corner detectors can be seen as the simplest sparse feature extractors, where the extracted
              features are the (x,y) positions themselves.
            </summary>
            
            <seealso cref="T:Accord.Imaging.BaseSparseFeatureExtractor`1" />
            <seealso cref="T:Accord.Imaging.ICornersDetector" />
            
        </member>
        <member name="M:Accord.Imaging.BaseCornersDetector.ProcessImage(System.Drawing.Bitmap)">
            <summary>
            Process image looking for corners.
            </summary>
            
            <param name="image">Source image to process.</param>
            
            <returns>Returns list of found corners (X-Y coordinates).</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BaseCornersDetector.InnerProcess(Accord.Imaging.UnmanagedImage)">
            <summary>
              This method should be implemented by inheriting classes to implement the
              actual corners detection, transforming the input image into a list of points.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.BaseCornersDetector.InnerTransform(Accord.Imaging.UnmanagedImage)">
            <summary>
              This method should be implemented by inheriting classes to implement the
              actual feature extraction, transforming the input image into a list of features.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.BaseCornersDetector.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Process image looking for corners.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            
            <returns>Returns list of found corners (X-Y coordinates).</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BaseCornersDetector.ProcessImage(Accord.Imaging.UnmanagedImage)">
            <summary>
            Process image looking for corners.
            </summary>
            
            <param name="input">Source image data to process.</param>
            
            <returns>Returns list of found corners (X-Y coordinates).</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Divide">
            <summary>
              Divide filter - divide pixel values of two images.
            </summary>
            
            <remarks><para>The divide filter takes two images (source and overlay images)
            of the same size and pixel format and produces an image, where each pixel equals
            to the division value of corresponding pixels from provided images:</para>
            
            <code>
             - For 8bpp:  (srcPix * 255f + 1f) / (ovrPix + 1f), 
             - For 16bpp: (srcPix * 65535f + 1f) / (ovrPix + 1f).
            </code>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Divide filter = new Divide(overlayImage);
            
            // apply the filter
            Bitmap resultImage = filter.Apply(sourceImage);
            </code>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.Merge"/>
            <seealso cref="T:Accord.Imaging.Filters.Intersect"/>
            <seealso cref="T:Accord.Imaging.Filters.Add"/>
            <seealso cref="T:Accord.Imaging.Filters.Difference"/>
            <seealso cref="T:Accord.Imaging.Filters.Multiply"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Divide.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Divide.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Divide"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Divide.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Divide"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Divide.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Divide"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Divide.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Multiply">
            <summary>
              Multiply filter - multiply pixel values of two images.
            </summary>
            
            <remarks><para>The multiply filter takes two images (source and overlay images)
            of the same size and pixel format and produces an image, where each pixel equals
            to the multiplication value of corresponding pixels from provided images.</para>
            
            <code>
             - For 8bpp: (srcPix * ovrPix) / 255, 
             - For 16bpp: (srcPix * ovrPix) / 65535.
            </code>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Multiply filter = new Multiply(overlayImage);
            
            // apply the filter
            Bitmap resultImage = filter.Apply(sourceImage);
            </code>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.Merge"/>
            <seealso cref="T:Accord.Imaging.Filters.Intersect"/>
            <seealso cref="T:Accord.Imaging.Filters.Add"/>
            <seealso cref="T:Accord.Imaging.Filters.Difference"/>
            <seealso cref="T:Accord.Imaging.Filters.Divide"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Multiply.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Multiply.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Multiply"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Multiply.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Multiply"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Multiply.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Multiply"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Multiply.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.FastBoxBlur">
            <summary>
              Fast Box Blur filter.
            </summary>
            
            <remarks>
              Reference: http://www.vcskicks.com/box-blur.php
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FastBoxBlur.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FastBoxBlur.HorizontalKernelSize">
            <summary>
            Horizontal kernel size between 3 and 99.
            Default value is 3.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FastBoxBlur.VerticalKernelSize">
            <summary>
            Vertical kernel size between 3 and 99.
            Default value is 3.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FastBoxBlur.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FastBoxBlur"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FastBoxBlur.#ctor(System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FastBoxBlur"/> class.
            </summary>
            
            <param name="horizontalKernelSize">Horizontal kernel size.</param>
            <param name="verticalKernelSize">Vertical kernel size.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FastBoxBlur.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ZhangSuenSkeletonization">
            <summary>
            Zhang-Suen skeletonization filter.
            </summary>
            
            <remarks><para>Zhang-Suen Thinning Algorithm. The filter uses
            <see cref="P:Accord.Imaging.Filters.ZhangSuenSkeletonization.Background"/> and <see cref="P:Accord.Imaging.Filters.ZhangSuenSkeletonization.Foreground"/> colors to distinguish
            between object and background.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ZhangSuenSkeletonization filter = new ZhangSuenSkeletonization( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample14.png" width="150" height="150" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\ZhangSuen_skeletonization.png" width="150" height="150" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ZhangSuenSkeletonization.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ZhangSuenSkeletonization.Background">
            <summary>
            Background pixel color.
            </summary>
            
            <remarks><para>The property sets background (none object) color to look for.</para>
            
            <para>Default value is set to <b>0</b> - black.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ZhangSuenSkeletonization.Foreground">
            <summary>
            Foreground pixel color.
            </summary>
            
            <remarks><para>The property sets objects' (none background) color to look for.</para>
            
            <para>Default value is set to <b>255</b> - white.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ZhangSuenSkeletonization.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SimpleSkeletonization"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.ZhangSuenSkeletonization.#ctor(System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SimpleSkeletonization"/> class.
            </summary>
            
            <param name="bg">Background pixel color.</param>
            <param name="fg">Foreground pixel color.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ZhangSuenSkeletonization.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="source">Source image data.</param>
            <param name="destination">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Add">
            <summary>
            Add fillter - add pixel values of two images.
            </summary>
            
            <remarks><para>The add filter takes two images (source and overlay images)
            of the same size and pixel format and produces an image, where each pixel equals
            to the sum value of corresponding pixels from provided images (if sum is greater
            than maximum allowed value, 255 or 65535, then it is truncated to that maximum).</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Add filter = new Add( overlayImage );
            // apply the filter
            Bitmap resultImage = filter.Apply( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="..\images\imaging\sample6.png" width="320" height="240" />
            <para><b>Overlay image:</b></para>
            <img src="..\images\imaging\sample7.png" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\add.png" width="320" height="240" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.Merge"/>
            <seealso cref="T:Accord.Imaging.Filters.Intersect"/>
            <seealso cref="T:Accord.Imaging.Filters.Subtract"/>
            <seealso cref="T:Accord.Imaging.Filters.Difference"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Add.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Add.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Add"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Add.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Add"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Add.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Add"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Add.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Difference">
             <summary>
             Difference filter - get the difference between overlay and source images.
             </summary>
             
             <remarks><para>The difference filter takes two images (source and
             <see cref="P:Accord.Imaging.Filters.BaseInPlaceFilter2.OverlayImage">overlay</see> images)
             of the same size and pixel format and produces an image, where each pixel equals
             to absolute difference between corresponding pixels from provided images.</para>
             
             <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
             color images for processing.</para>
             
             <para><note>In the case if images with alpha channel are used (32 or 64 bpp), visualization
             of the result image may seem a bit unexpected - most probably nothing will be seen
             (in the case if image is displayed according to its alpha channel). This may be
             caused by the fact that after differencing the entire alpha channel will be zeroed
             (zero difference between alpha channels), what means that the resulting image will be
             100% transparent.</note></para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Difference filter = new Difference( overlayImage );
             // apply the filter
             Bitmap resultImage = filter.Apply( sourceImage );
             </code>
            
             <para><b>Source image:</b></para>
             <img src="..\images\imaging\sample6.png" width="320" height="240" />
             <para><b>Overlay image:</b></para>
             <img src="..\images\imaging\sample7.png" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\difference.png" width="320" height="240" />
             </remarks>
            
             <seealso cref="T:Accord.Imaging.Filters.Intersect"/>
             <seealso cref="T:Accord.Imaging.Filters.Merge"/>
             <seealso cref="T:Accord.Imaging.Filters.Add"/>
             <seealso cref="T:Accord.Imaging.Filters.Subtract"/>
             
        </member>
        <member name="P:Accord.Imaging.Filters.Difference.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Difference.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Difference"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Difference.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Difference"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Difference.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Difference"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Difference.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Intersect">
            <summary>
            Intersect filter - get MIN of pixels in two images.
            </summary>
            
            <remarks><para>The intersect filter takes two images (source and overlay images)
            of the same size and pixel format and produces an image, where each pixel equals
            to the minimum value of corresponding pixels from provided images.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Intersect filter = new Intersect( overlayImage );
            // apply the filter
            Bitmap resultImage = filter.Apply( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="..\images\imaging\sample6.png" width="320" height="240" />
            <para><b>Overlay image:</b></para>
            <img src="..\images\imaging\sample7.png" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\intersect.png" width="320" height="240" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.Merge"/>
            <seealso cref="T:Accord.Imaging.Filters.Difference"/>
            <seealso cref="T:Accord.Imaging.Filters.Add"/>
            <seealso cref="T:Accord.Imaging.Filters.Subtract"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Intersect.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Intersect.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Merge"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Intersect.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Merge"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Intersect.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Intersect"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Intersect.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Merge">
             <summary>
             Merge filter - get MAX of pixels in two images.
             </summary>
             
             <remarks><para>The merge filter takes two images (source and overlay images)
             of the same size and pixel format and produces an image, where each pixel equals
             to the maximum value of corresponding pixels from provided images.</para>
             
             <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Merge filter = new Merge( overlayImage );
             // apply the filter
             Bitmap resultImage = filter.Apply( sourceImage );
             </code>
            
             <para><b>Source image:</b></para>
             <img src="..\images\imaging\sample6.png" width="320" height="240" />
             <para><b>Overlay image:</b></para>
             <img src="..\images\imaging\sample7.png" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\merge.png" width="320" height="240" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.Intersect"/>
             <seealso cref="T:Accord.Imaging.Filters.Difference"/>
             <seealso cref="T:Accord.Imaging.Filters.Add"/>
             <seealso cref="T:Accord.Imaging.Filters.Subtract"/>
             
        </member>
        <member name="P:Accord.Imaging.Filters.Merge.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Merge.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Merge"/> class
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Merge.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Merge"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Merge.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Merge"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Merge.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Morph">
            <summary>
            Morph filter.
            </summary>
            
            <remarks><para>The filter combines two images by taking
            <see cref="P:Accord.Imaging.Filters.Morph.SourcePercent">specified percent</see> of pixels' intensities from source
            image and the rest from overlay image. For example, if the
            <see cref="P:Accord.Imaging.Filters.Morph.SourcePercent">source percent</see> value is set to 0.8, then each pixel
            of the result image equals to <b>0.8 * source + 0.2 * overlay</b>, where <b>source</b>
            and <b>overlay</b> are corresponding pixels' values in source and overlay images.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Morph filter = new Morph( overlayImage );
            filter.SourcePercent = 0.75;
            // apply the filter
            Bitmap resultImage = filter.Apply( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="..\images\imaging\sample6.png" width="320" height="240" />
            <para><b>Overlay image:</b></para>
            <img src="..\images\imaging\sample7.png" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\morph.png" width="320" height="240" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Morph.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.Morph.SourcePercent">
            <summary>
            Percent of source image to keep, [0, 1].
            </summary>
            
            <remarks><para>The property specifies the percentage of source pixels' to take. The
            rest is taken from an overlay image.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Morph.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Morph"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Morph.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Morph"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Morph.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Morph"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Morph.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.MoveTowards">
             <summary>
             Move towards filter.
             </summary>
             
             <remarks><para>The result of this filter is an image, which is based on source image,
             but updated in the way to decrease diffirence with overlay image - source image is
             moved towards overlay image. The update equation is defined in the next way:
             <b>res = src + Min( Abs( ovr - src ), step ) * Sign( ovr - src )</b>.</para>
             
             <para>The bigger is <see cref="P:Accord.Imaging.Filters.MoveTowards.StepSize">step size</see> value the more resulting
             image will look like overlay image. For example, in the case if step size is equal
             to 255 (or 65535 for images with 16 bits per channel), the resulting image will be
             equal to overlay image regardless of source image's pixel values. In the case if step
             size is set to 1, the resulting image will very little differ from the source image.
             But, in the case if the filter is applied repeatedly to the resulting image again and
             again, it will become equal to overlay image in maximum 255 (65535 for images with 16
             bits per channel) iterations.</para>
             
             <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             MoveTowards filter = new MoveTowards( overlayImage, 20 );
             // apply the filter
             Bitmap resultImage = filter.Apply( sourceImage );
             </code>
            
             <para><b>Source image:</b></para>
             <img src="..\images\imaging\sample6.png" width="320" height="240" />
             <para><b>Overlay image:</b></para>
             <img src="..\images\imaging\sample7.png" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\move_towards.png" width="320" height="240" />
             </remarks>
             
        </member>
        <member name="P:Accord.Imaging.Filters.MoveTowards.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.MoveTowards.StepSize">
             <summary>
             Step size, [0, 65535].
             </summary>
            
             <remarks>
             <para>The property defines the maximum amount of changes per pixel in the source image.</para>
             
             <para>Default value is set to 1.</para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.MoveTowards.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.MoveTowards"/> class
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.MoveTowards.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.MoveTowards"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.MoveTowards.#ctor(System.Drawing.Bitmap,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.MoveTowards"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            <param name="stepSize">Step size.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.MoveTowards.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.MoveTowards"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.MoveTowards.#ctor(Accord.Imaging.UnmanagedImage,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.MoveTowards"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            <param name="stepSize">Step size.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.MoveTowards.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.StereoAnaglyph">
            <summary>
            Stereo anaglyph filter.
            </summary>
            
            <remarks><para>The image processing filter produces stereo anaglyph images which are
            aimed to be viewed through anaglyph glasses with red filter over the left eye and
            cyan over the right.</para>
            
            <img src="..\images\imaging\anaglyph_glasses.png" width="125" height="97" />
            
            <para>The stereo image is produced by combining two images of the same scene taken
            from a bit different points. The right image must be provided to the filter using
            <see cref="P:Accord.Imaging.Filters.BaseInPlaceFilter2.OverlayImage"/> property, but the left image must be provided to
            <see cref="M:Accord.Imaging.Filters.IFilter.Apply(System.Drawing.Bitmap)"/> method, which creates the anaglyph image.</para>
            
            <para>The filter accepts 24 bpp color images for processing.</para>
            
            <para>See <see cref="T:Accord.Imaging.Filters.StereoAnaglyph.Algorithm"/> enumeration for the list of supported anaglyph algorithms.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            StereoAnaglyph filter = new StereoAnaglyph( );
            // set right image as overlay
            filter.Overlay = rightImage
            // apply the filter (providing left image)
            Bitmap resultImage = filter.Apply( leftImage );
            </code>
            
            <para><b>Source image (left):</b></para>
            <img src="..\images\imaging\sample16_left.png" width="320" height="240" />
            <para><b>Overlay image (right):</b></para>
            <img src="..\images\imaging\sample16_right.png" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\anaglyph.png" width="320" height="240" />
            
            </remarks>
            
        </member>
        <member name="T:Accord.Imaging.Filters.StereoAnaglyph.Algorithm">
            <summary>
            Enumeration of algorithms for creating anaglyph images.
            </summary>
            
            <remarks><para>See <a href="http://www.3dtv.at/Knowhow/AnaglyphComparison_en.aspx">anaglyph methods comparison</a> for
            descipton of different algorithms.</para>
            </remarks>
            
        </member>
        <member name="F:Accord.Imaging.Filters.StereoAnaglyph.Algorithm.TrueAnaglyph">
            <summary>
            Creates anaglyph image using the below calculations:
            <list type="bullet">
            <item>R<sub>a</sub>=0.299*R<sub>l</sub>+0.587*G<sub>l</sub>+0.114*B<sub>l</sub>;</item>
            <item>G<sub>a</sub>=0;</item>
            <item>B<sub>a</sub>=0.299*R<sub>r</sub>+0.587*G<sub>r</sub>+0.114*B<sub>r</sub>.</item>
            </list>
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.StereoAnaglyph.Algorithm.GrayAnaglyph">
            <summary>
            Creates anaglyph image using the below calculations:
            <list type="bullet">
            <item>R<sub>a</sub>=0.299*R<sub>l</sub>+0.587*G<sub>l</sub>+0.114*B<sub>l</sub>;</item>
            <item>G<sub>a</sub>=0.299*R<sub>r</sub>+0.587*G<sub>r</sub>+0.114*B<sub>r</sub>;</item>
            <item>B<sub>a</sub>=0.299*R<sub>r</sub>+0.587*G<sub>r</sub>+0.114*B<sub>r</sub>.</item>
            </list>
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.StereoAnaglyph.Algorithm.ColorAnaglyph">
            <summary>
            Creates anaglyph image using the below calculations:
            <list type="bullet">
            <item>R<sub>a</sub>=R<sub>l</sub>;</item>
            <item>G<sub>a</sub>=G<sub>r</sub>;</item>
            <item>B<sub>a</sub>=B<sub>r</sub>.</item>
            </list>
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.StereoAnaglyph.Algorithm.HalfColorAnaglyph">
            <summary>
            Creates anaglyph image using the below calculations:
            <list type="bullet">
            <item>R<sub>a</sub>=0.299*R<sub>l</sub>+0.587*G<sub>l</sub>+0.114*B<sub>l</sub>;</item>
            <item>G<sub>a</sub>=G<sub>r</sub>;</item>
            <item>B<sub>a</sub>=B<sub>r</sub>.</item>
            </list>
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.StereoAnaglyph.Algorithm.OptimizedAnaglyph">
            <summary>
            Creates anaglyph image using the below calculations:
            <list type="bullet">
            <item>R<sub>a</sub>=0.7*G<sub>l</sub>+0.3*B<sub>l</sub>;</item>
            <item>G<sub>a</sub>=G<sub>r</sub>;</item>
            <item>B<sub>a</sub>=B<sub>r</sub>.</item>
            </list>
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.StereoAnaglyph.AnaglyphAlgorithm">
            <summary>
            Algorithm to use for creating anaglyph images.
            </summary>
            
            <remarks><para>Default value is set to <see cref="F:Accord.Imaging.Filters.StereoAnaglyph.Algorithm.GrayAnaglyph"/>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.StereoAnaglyph.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.StereoAnaglyph.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.StereoAnaglyph"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.StereoAnaglyph.#ctor(Accord.Imaging.Filters.StereoAnaglyph.Algorithm)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.StereoAnaglyph"/> class.
            </summary>
            
            <param name="anaglyphAlgorithm">Algorithm to use for creating anaglyph images.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.StereoAnaglyph.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data (left image).</param>
             <param name="overlay">Overlay image data (right image).</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Subtract">
            <summary>
            Subtract filter - subtract pixel values of two images.
            </summary>
            
            <remarks><para>The subtract filter takes two images (source and overlay images)
            of the same size and pixel format and produces an image, where each pixel equals
            to the difference value of corresponding pixels from provided images (if difference is less
            than minimum allowed value, 0, then it is truncated to that minimum value).</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Subtract filter = new Subtract( overlayImage );
            // apply the filter
            Bitmap resultImage = filter.Apply( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="..\images\imaging\sample6.png" width="320" height="240" />
            <para><b>Overlay image:</b></para>
            <img src="..\images\imaging\sample7.png" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\subtract.png" width="320" height="240" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.Merge"/>
            <seealso cref="T:Accord.Imaging.Filters.Intersect"/>
            <seealso cref="T:Accord.Imaging.Filters.Add"/>
            <seealso cref="T:Accord.Imaging.Filters.Difference"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Subtract.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Subtract.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Subtract"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Subtract.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Subtract"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Subtract.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Subtract"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Subtract.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ThresholdedDifference">
            <summary>
            Calculate difference between two images and threshold it.
            </summary>
            
            <remarks><para>The filter produces similar result as applying <see cref="T:Accord.Imaging.Filters.Difference"/> filter and
            then <see cref="P:Accord.Imaging.Filters.ThresholdedDifference.Threshold"/> filter - thresholded difference between two images. Result of this
            image processing routine may be useful in motion detection applications or finding areas of significant
            difference.</para>
            
            <para>The filter accepts 8 and 24/32color images for processing.
            In the case of color images, the image processing routine differences sum over 3 RGB channels (Manhattan distance), i.e.
            |diffR| + |diffG| + |diffB|.
            </para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ThresholdedDifference filter = new ThresholdedDifference( 60 );
            // apply the filter
            filter.OverlayImage = backgroundImage;
            Bitmap resultImage = filter.Apply( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="..\images\imaging\object.jpg" width="320" height="240" />
            <para><b>Background image:</b></para>
            <img src="..\images\imaging\background.jpg" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\thresholded_difference.png" width="320" height="240" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.ThresholdedEuclideanDifference"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ThresholdedDifference.Threshold">
            <summary>
            Difference threshold.
            </summary>
            
            <remarks><para>The property specifies difference threshold. If difference between pixels of processing image
            and overlay image is greater than this value, then corresponding pixel of result image is set to white; otherwise
            black.
            </para>
            
            <para>Default value is set to <b>15</b>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ThresholdedDifference.WhitePixelsCount">
             <summary>
             Number of pixels which were set to white in destination image during last image processing call.
             </summary>
            
             <remarks><para>The property may be useful to determine amount of difference between two images which,
             for example, may be treated as amount of motion in motion detection applications, etc.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ThresholdedDifference.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ThresholdedDifference.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ThresholdedDifference"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ThresholdedDifference.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ThresholdedDifference"/> class.
            </summary>
            
            <param name="threshold">Difference threshold (see <see cref="P:Accord.Imaging.Filters.ThresholdedDifference.Threshold"/>).</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ThresholdedDifference.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="overlay">Overlay image data.</param>
            <param name="destinationData">Destination image data</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ThresholdedEuclideanDifference">
            <summary>
            Calculate Euclidean difference between two images and threshold it.
            </summary>
            
            <remarks><para>The filter produces similar to <see cref="T:Accord.Imaging.Filters.ThresholdedDifference"/>, however it uses
            Euclidean distance for finding difference between pixel values instead of Manhattan distance. Result of this
            image processing routine may be useful in motion detection applications or finding areas of significant
            difference.</para>
            
            <para>The filter accepts 8 and 24/32color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ThresholdedEuclideanDifference filter = new ThresholdedEuclideanDifference( 60 );
            // apply the filter
            filter.OverlayImage = backgroundImage;
            Bitmap resultImage = filter.Apply( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="..\images\imaging\object.jpg" width="320" height="240" />
            <para><b>Background image:</b></para>
            <img src="..\images\imaging\background.jpg" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\thresholded_euclidean_difference.png" width="320" height="240" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.ThresholdedDifference"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ThresholdedEuclideanDifference.Threshold">
            <summary>
            Difference threshold.
            </summary>
            
            <remarks><para>The property specifies difference threshold. If difference between pixels of processing image
            and overlay image is greater than this value, then corresponding pixel of result image is set to white; otherwise
            black.
            </para>
            
            <para>Default value is set to <b>15</b>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ThresholdedEuclideanDifference.WhitePixelsCount">
             <summary>
             Number of pixels which were set to white in destination image during last image processing call.
             </summary>
            
             <remarks><para>The property may be useful to determine amount of difference between two images which,
             for example, may be treated as amount of motion in motion detection applications, etc.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ThresholdedEuclideanDifference.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ThresholdedEuclideanDifference.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ThresholdedEuclideanDifference"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ThresholdedEuclideanDifference.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ThresholdedEuclideanDifference"/> class.
            </summary>
            
            <param name="threshold">Difference threshold (see <see cref="P:Accord.Imaging.Filters.ThresholdedEuclideanDifference.Threshold"/>).</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ThresholdedEuclideanDifference.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="overlay">Overlay image data.</param>
            <param name="destinationData">Destination image data</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BradleyLocalThresholding">
            <summary>
            Adaptive thresholding using the internal image.
            </summary>
            
            <remarks><para>The image processing routine implements local thresholding technique described
            by Derek Bradley and Gerhard Roth in the "Adaptive Thresholding Using the Integral Image" paper.
            </para>
            
            <para>The brief idea of the algorithm is that every image's pixel is set to black if its brightness
            is <i>t</i> percent lower (see <see cref="P:Accord.Imaging.Filters.BradleyLocalThresholding.PixelBrightnessDifferenceLimit"/>) than the average brightness
            of surrounding pixels in the window of the specified size (see <see cref="P:Accord.Imaging.Filters.BradleyLocalThresholding.WindowSize"/>), othwerwise it is set
            to white.</para>
            
            <para>Sample usage:</para>
            <code>
            // create the filter
            BradleyLocalThresholding filter = new BradleyLocalThresholding( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample20.png" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\bradley_local_thresholding.png" width="320" height="240" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BradleyLocalThresholding.WindowSize">
            <summary>
            Window size to calculate average value of pixels for.
            </summary>
            
            <remarks><para>The property specifies window size around processing pixel, which determines number of
            neighbor pixels to use for calculating their average brightness.</para>
            
            <para>Default value is set to <b>41</b>.</para>
            
            <para><note>The value should be odd.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BradleyLocalThresholding.PixelBrightnessDifferenceLimit">
             <summary>
             Brightness difference limit between processing pixel and average value across neighbors.
             </summary>
            
             <remarks><para>The property specifies what is the allowed difference percent between processing pixel
             and average brightness of neighbor pixels in order to be set white. If the value of the
             current pixel is <i>t</i> percent (this property value) lower than the average then it is set
             to black, otherwise it is set to white. </para>
             
             <para>Default value is set to <b>0.15</b>.</para>
             </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BradleyLocalThresholding.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BradleyLocalThresholding.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BradleyLocalThresholding"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BradleyLocalThresholding.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.IterativeThreshold">
            <summary>
            Iterative threshold search and binarization.
            </summary>
            
            <remarks>
            <para>The algorithm works in the following way:
            <list type="bullet">
            <item>select any start threshold;</item>
            <item>compute average value of Background (ÂµB) and Object (ÂµO) values:
            1) all pixels with a value that is below threshold, belong to the Background values;
            2) all pixels greater or equal threshold, belong to the Object values.
            </item>
            <item>calculate new thresghold: (ÂµB + ÂµO) / 2;</item>
            <item>if |oldThreshold - newThreshold| is less than a given manimum allowed error, then stop iteration process
            and create the binary image with the new threshold.</item>
            </list>
            </para>
            
            <para>For additional information see <b>Digital Image Processing, Gonzalez/Woods. Ch.10 page:599</b>.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images for processing.</para>
            
            <para><note>Since the filter can be applied as to 8 bpp and to 16 bpp images,
            the initial value of <see cref="P:Accord.Imaging.Filters.Threshold.ThresholdValue"/> property should be set appropriately to the
            pixel format. In the case of 8 bpp images the threshold value is in the [0, 255] range, but
            in the case of 16 bpp images the threshold value is in the [0, 65535] range.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            IterativeThreshold filter = new IterativeThreshold( 2, 128 );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample11.png" width="256" height="256" />
            <para><b>Result image (calculated threshold is 102):</b></para>
            <img src="..\images\imaging\iterative_threshold.png" width="256" height="256" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.OtsuThreshold"/>
            <seealso cref="T:Accord.Imaging.Filters.SISThreshold"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.IterativeThreshold.MinimumError">
            <summary>
            Minimum error, value when iterative threshold search is stopped.
            </summary>
            
            <remarks>Default value is set to <b>0</b>.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IterativeThreshold.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.IterativeThreshold"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IterativeThreshold.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.IterativeThreshold"/> class.
            </summary>
            
            <param name="minError">Minimum allowed error, that ends the iteration process.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IterativeThreshold.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.IterativeThreshold"/> class.
            </summary>
            
            <param name="minError">Minimum allowed error, that ends the iteration process.</param>
            <param name="threshold">Initial threshold value.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IterativeThreshold.CalculateThreshold(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:Accord.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should
            8 bpp grayscale (indexed) or 16 bpp grayscale image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IterativeThreshold.CalculateThreshold(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:Accord.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should
            8 bpp grayscale (indexed) or 16 bpp grayscale image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IterativeThreshold.CalculateThreshold(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:Accord.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should
            8 bpp grayscale (indexed) or 16 bpp grayscale image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IterativeThreshold.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.OtsuThreshold">
            <summary>
            Otsu thresholding.
            </summary>
            
            <remarks><para>The class implements Otsu thresholding, which is described in
            <b>N. Otsu, "A threshold selection method from gray-level histograms", IEEE Trans. Systems,
            Man and Cybernetics 9(1), pp. 62â66, 1979.</b></para>
            
            <para>This implementation instead of minimizing the weighted within-class variance
            does maximization of between-class variance, what gives the same result. The approach is
            described in <a href="http://sampl.ece.ohio-state.edu/EE863/2004/ECE863-G-segclust2.ppt">this presentation</a>.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            OtsuThreshold filter = new OtsuThreshold( );
            // apply the filter
            filter.ApplyInPlace( image );
            // check threshold value
            byte t = filter.ThresholdValue;
            // ...
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample11.png" width="256" height="256" />
            <para><b>Result image (calculated threshold is 97):</b></para>
            <img src="..\images\imaging\otsu_threshold.png" width="256" height="256" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.IterativeThreshold"/>
            <seealso cref="T:Accord.Imaging.Filters.SISThreshold"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.OtsuThreshold.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.OtsuThreshold.ThresholdValue">
            <summary>
            Threshold value.
            </summary>
            
            <remarks>The property is read only and represents the value, which
            was automaticaly calculated using Otsu algorithm.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.OtsuThreshold.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.OtsuThreshold"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.OtsuThreshold.CalculateThreshold(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:Accord.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should be
            8 bpp grayscale (indexed) image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.OtsuThreshold.CalculateThreshold(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:Accord.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should be
            8 bpp grayscale (indexed) image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.OtsuThreshold.CalculateThreshold(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:Accord.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should be
            8 bpp grayscale (indexed) image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.OtsuThreshold.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.SISThreshold">
            <summary>
            Threshold using Simple Image Statistics (SIS).
            </summary>
            
            <remarks><para>The filter performs image thresholding calculating threshold automatically
            using simple image statistics method. For each pixel:
            <list type="bullet">
            <item>two gradients are calculated - ex = |I(x + 1, y) - I(x - 1, y)| and
            |I(x, y + 1) - I(x, y - 1)|;</item>
            <item>weight is calculated as maximum of two gradients;</item>
            <item>sum of weights is updated (weightTotal += weight);</item>
            <item>sum of weighted pixel values is updated (total += weight * I(x, y)).</item>
            </list>
            The result threshold is calculated as sum of weighted pixel values divided by sum of weight.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            SISThreshold filter = new SISThreshold( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample11.png" width="256" height="256" />
            <para><b>Result image (calculated threshold is 127):</b></para>
            <img src="..\images\imaging\sis_threshold.png" width="256" height="256" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.IterativeThreshold"/>
            <seealso cref="T:Accord.Imaging.Filters.OtsuThreshold"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SISThreshold.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.SISThreshold.ThresholdValue">
            <summary>
            Threshold value.
            </summary>
            
            <remarks><para>The property is read only and represents the value, which
            was automaticaly calculated using image statistics.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SISThreshold.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SISThreshold"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SISThreshold.CalculateThreshold(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:Accord.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should be
            8 bpp grayscale (indexed) image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SISThreshold.CalculateThreshold(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:Accord.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should be
            8 bpp grayscale (indexed) image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SISThreshold.CalculateThreshold(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Calculate binarization threshold for the given image.
            </summary>
            
            <param name="image">Image to calculate binarization threshold for.</param>
            <param name="rect">Rectangle to calculate binarization threshold for.</param>
            
            <returns>Returns binarization threshold.</returns>
            
            <remarks><para>The method is used to calculate binarization threshold only. The threshold
            later may be applied to the image using <see cref="T:Accord.Imaging.Filters.Threshold"/> image processing filter.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported by the routine. It should be
            8 bpp grayscale (indexed) image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SISThreshold.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BaseFilter">
            <summary>
            Base class for filters, which produce new image of the same size as a
            result of image processing.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters, which
            do image processing creating new image with the same size as source.
            Filters based on this class cannot be applied directly to the source
            image, which is kept unchanged.</para>
            
            <para>The base class itself does not define supported pixel formats of source
            image and resulting pixel formats of destination image. Filters inheriting from
            this base class, should specify supported pixel formats and their transformations
            overriding abstract <see cref="P:Accord.Imaging.Filters.BaseFilter.FormatTranslations"/> property.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BaseFilter.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>The dictionary defines, which pixel formats are supported for
             source images and which pixel format will be used for resulting image.
             </para>
             
             <para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseFilter.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseFilter.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The filter accepts bitmap data as input and returns the result
             of image processing filter as new image. The source image data are kept
             unchanged.</remarks>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseFilter.Apply(Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseFilter.Apply(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:Accord.Imaging.Filters.BaseFilter.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseFilter.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BaseFilter2">
            <summary>
            Base class for filters, which operate with two images of the same size and format and
            produce new image as a result.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters, which can
            be applied to an image producing new image as a result of image processing.</para>
            
            <para>The base class is aimed for such type of filters, which require additional image
            to process the source image. The additional image is set by <see cref="P:Accord.Imaging.Filters.BaseFilter2.OverlayImage"/>
            or <see cref="P:Accord.Imaging.Filters.BaseFilter2.UnmanagedOverlayImage"/> property and must have the same size and pixel format
            as source image. See documentation of particular inherited class for information
            about overlay image purpose.
            </para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BaseFilter2.OverlayImage">
             <summary>
             Overlay image.
             </summary>
             
             <remarks>
             <para>The property sets an overlay image, which will be used as the second image required
             to process source image. See documentation of particular inherited class for information
             about overlay image purpose.
             </para>
             
             <para><note>Overlay image must have the same size and pixel format as source image.
             Otherwise exception will be generated when filter is applied to source image.</note></para>
             
             <para><note>Setting this property will clear the <see cref="P:Accord.Imaging.Filters.BaseFilter2.UnmanagedOverlayImage"/> property -
             only one overlay image is allowed: managed or unmanaged.</note></para>
             </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BaseFilter2.UnmanagedOverlayImage">
             <summary>
             Unmanaged overlay image.
             </summary>
             
             <remarks>
             <para>The property sets an overlay image, which will be used as the second image required
             to process source image. See documentation of particular inherited class for information
             about overlay image purpose.
             </para>
             
             <para><note>Overlay image must have the same size and pixel format as source image.
             Otherwise exception will be generated when filter is applied to source image.</note></para>
             
             <para><note>Setting this property will clear the <see cref="P:Accord.Imaging.Filters.BaseFilter2.OverlayImage"/> property -
             only one overlay image is allowed: managed or unmanaged.</note></para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseFilter2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BaseFilter2"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseFilter2.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BaseFilter2"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseFilter2.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BaseFilter2"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseFilter2.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseFilter2.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="sourceData">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
             <param name="destinationData">Destination image data</param>
             
             <remarks><para>Overlay image size and pixel format is checked by this base class, before
             passing execution to inherited class.</para></remarks>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BaseInPlaceFilter">
            <summary>
            Base class for filters, which may be applied directly to the source image.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters, which can
            be applied to an image producing new image as a result of image processing or
            applied directly to the source image without changing its size and pixel format.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BaseInPlaceFilter.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>The dictionary defines, which pixel formats are supported for
             source images and which pixel format will be used for resulting image.
             </para>
             
             <para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlaceFilter.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlaceFilter.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The filter accepts bitmap data as input and returns the result
             of image processing filter as new image. The source image data are kept
             unchanged.</remarks>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlaceFilter.Apply(Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlaceFilter.Apply(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:Accord.Imaging.Filters.BaseInPlaceFilter.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlaceFilter.ApplyInPlace(System.Drawing.Bitmap)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlaceFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlaceFilter.ApplyInPlace(Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an unmanaged image.
             </summary>
             
             <param name="image">Unmanaged image to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source unmanaged image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlaceFilter.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BaseInPlaceFilter2">
            <summary>
            Base class for filters, which operate with two images of the same size and format and
            may be applied directly to the source image.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters, which can
            be applied to an image producing new image as a result of image processing or
            applied directly to the source image without changing its size and pixel format.</para>
            
            <para>The base class is aimed for such type of filters, which require additional image
            to process the source image. The additional image is set by <see cref="P:Accord.Imaging.Filters.BaseInPlaceFilter2.OverlayImage"/>
            or <see cref="P:Accord.Imaging.Filters.BaseInPlaceFilter2.UnmanagedOverlayImage"/> property and must have the same size and pixel format
            as source image. See documentation of particular inherited class for information
            about overlay image purpose.
            </para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BaseInPlaceFilter2.OverlayImage">
             <summary>
             Overlay image.
             </summary>
             
             <remarks>
             <para>The property sets an overlay image, which will be used as the second image required
             to process source image. See documentation of particular inherited class for information
             about overlay image purpose.
             </para>
             
             <para><note>Overlay image must have the same size and pixel format as source image.
             Otherwise exception will be generated when filter is applied to source image.</note></para>
             
             <para><note>Setting this property will clear the <see cref="P:Accord.Imaging.Filters.BaseInPlaceFilter2.UnmanagedOverlayImage"/> property -
             only one overlay image is allowed: managed or unmanaged.</note></para>
             </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BaseInPlaceFilter2.UnmanagedOverlayImage">
             <summary>
             Unmanaged overlay image.
             </summary>
             
             <remarks>
             <para>The property sets an overlay image, which will be used as the second image required
             to process source image. See documentation of particular inherited class for information
             about overlay image purpose.
             </para>
             
             <para><note>Overlay image must have the same size and pixel format as source image.
             Otherwise exception will be generated when filter is applied to source image.</note></para>
             
             <para><note>Setting this property will clear the <see cref="P:Accord.Imaging.Filters.BaseInPlaceFilter2.OverlayImage"/> property -
             only one overlay image is allowed: managed or unmanaged.</note></para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlaceFilter2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BaseInPlaceFilter2"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlaceFilter2.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BaseInPlaceFilter2"/> class.
            </summary>
            
            <param name="overlayImage">Overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlaceFilter2.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BaseInPlaceFilter2"/> class.
            </summary>
            
            <param name="unmanagedOverlayImage">Unmanaged overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlaceFilter2.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Source and overlay images have different pixel formats and/or size.</exception>
             <exception cref="T:System.NullReferenceException">Overlay image is not set.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlaceFilter2.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
             
             <remarks><para>Overlay image size and pixel format is checked by this base class, before
             passing execution to inherited class.</para></remarks>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BaseInPlacePartialFilter">
            <summary>
            Base class for filters, which may be applied directly to the source image or its part.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters, which can
            be applied to an image producing new image as a result of image processing or
            applied directly to the source image (or its part) without changing its size and
            pixel format.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BaseInPlacePartialFilter.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>The dictionary defines, which pixel formats are supported for
             source images and which pixel format will be used for resulting image.
             </para>
             
             <para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlacePartialFilter.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlacePartialFilter.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The filter accepts bitmap data as input and returns the result
             of image processing filter as new image. The source image data are kept
             unchanged.</remarks>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlacePartialFilter.Apply(Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlacePartialFilter.Apply(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:Accord.Imaging.Filters.BaseInPlacePartialFilter.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlacePartialFilter.ApplyInPlace(System.Drawing.Bitmap)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlacePartialFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlacePartialFilter.ApplyInPlace(Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an unmanaged image.
             </summary>
             
             <param name="image">Unmanaged image to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source unmanaged image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlacePartialFilter.ApplyInPlace(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image or its part.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlacePartialFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
             <summary>
             Apply filter to an image or its part.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlacePartialFilter.ApplyInPlace(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an unmanaged image or its part.
            </summary>
            
            <param name="image">Unmanaged image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseInPlacePartialFilter.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BaseResizeFilter">
            <summary>
            Base class for image resizing filters.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters,
            which implement image rotation algorithms.</para>
            </remarks>
            
        </member>
        <member name="F:Accord.Imaging.Filters.BaseResizeFilter.newWidth">
            <summary>
              New image width.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.BaseResizeFilter.newHeight">
            <summary>
              New image height.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BaseResizeFilter.NewWidth">
            <summary>
              Width of the new resized image.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BaseResizeFilter.NewHeight">
            <summary>
              Height of the new resized image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseResizeFilter.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BaseResizeFilter"/> class.
            </summary>
            
            <param name="newWidth">Width of the new resized image.</param>
            <param name="newHeight">Height of the new resize image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseResizeFilter.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BaseRotateFilter">
            <summary>
            Base class for image rotation filters.
            </summary>
            
            <remarks>The abstract class is the base class for all filters,
            which implement rotating algorithms.</remarks>
            
        </member>
        <member name="F:Accord.Imaging.Filters.BaseRotateFilter.angle">
            <summary>
            Rotation angle.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.BaseRotateFilter.keepSize">
            <summary>
            Keep image size or not.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.BaseRotateFilter.fillColor">
            <summary>
            Fill color.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.BaseRotateFilter.Angle">
            <summary>
            Rotation angle, [0, 360].
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.BaseRotateFilter.KeepSize">
            <summary>
            Keep image size or not.
            </summary>
            
            <remarks><para>The property determines if source image's size will be kept
            as it is or not. If the value is set to <b>false</b>, then the new image will have
            new dimension according to rotation angle. If the valus is set to
            <b>true</b>, then the new image will have the same size, which means that some parts
            of the image may be clipped because of rotation.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BaseRotateFilter.FillColor">
            <summary>
            Fill color.
            </summary>
            
            <remarks><para>The fill color is used to fill areas of destination image,
            which don't have corresponsing pixels in source image.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseRotateFilter.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BaseRotateFilter"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            
            <remarks><para>This constructor sets <see cref="P:Accord.Imaging.Filters.BaseRotateFilter.KeepSize"/> property to <b>false</b>.
            </para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseRotateFilter.#ctor(System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BaseRotateFilter"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            <param name="keepSize">Keep image size or not.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseRotateFilter.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BaseTransformationFilter">
            <summary>
            Base class for filters, which may produce new image of different size as a
            result of image processing.
            </summary>
            
            <remarks><para>The abstract class is the base class for all filters, which
            do image processing creating new image of the size, which may differ from the
            size of source image. Filters based on this class cannot be applied directly
            to the source image, which is kept unchanged.</para>
            
            <para>The base class itself does not define supported pixel formats of source
            image and resulting pixel formats of destination image. Filters inheriting from
            this base class, should specify supported pixel formats and their transformations
            overriding abstract <see cref="P:Accord.Imaging.Filters.BaseTransformationFilter.FormatTranslations"/> property.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BaseTransformationFilter.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>The dictionary defines, which pixel formats are supported for
             source images and which pixel format will be used for resulting image.
             </para>
             
             <para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseTransformationFilter.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseTransformationFilter.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The filter accepts bitmap data as input and returns the result
             of image processing filter as new image. The source image data are kept
             unchanged.</remarks>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseTransformationFilter.Apply(Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseTransformationFilter.Apply(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:Accord.Imaging.Filters.BaseTransformationFilter.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseTransformationFilter.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseTransformationFilter.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BaseUsingCopyPartialFilter">
             <summary>
             Base class for filters, which require source image backup to make them applicable to
             source image (or its part) directly.
             </summary>
             
             <remarks><para>The base class is used for filters, which can not do
             direct manipulations with source image. To make effect of in-place filtering,
             these filters create a background copy of the original image (done by this
             base class) and then do manipulations with it putting result back to the original
             source image.</para>
             
             <para><note>The background copy of the source image is created only in the case of in-place
             filtering. Otherwise background copy is not created - source image is processed and result is
             put to destination image.</note></para>
             
             <para>The base class is for those filters, which support as filtering entire image, as
             partial filtering of specified rectangle only.</para>
             </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BaseUsingCopyPartialFilter.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>The dictionary defines, which pixel formats are supported for
             source images and which pixel format will be used for resulting image.
             </para>
             
             <para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseUsingCopyPartialFilter.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseUsingCopyPartialFilter.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The filter accepts bitmap data as input and returns the result
             of image processing filter as new image. The source image data are kept
             unchanged.</remarks>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseUsingCopyPartialFilter.Apply(Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseUsingCopyPartialFilter.Apply(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:Accord.Imaging.Filters.BaseUsingCopyPartialFilter.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseUsingCopyPartialFilter.ApplyInPlace(System.Drawing.Bitmap)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseUsingCopyPartialFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseUsingCopyPartialFilter.ApplyInPlace(Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an unmanaged image.
             </summary>
             
             <param name="image">Unmanaged image to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source unmanaged image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseUsingCopyPartialFilter.ApplyInPlace(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image or its part.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseUsingCopyPartialFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
             <summary>
             Apply filter to an image or its part.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseUsingCopyPartialFilter.ApplyInPlace(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an unmanaged image or its part.
            </summary>
            
            <param name="image">Unmanaged image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BaseUsingCopyPartialFilter.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BayerDithering">
            <summary>
            Ordered dithering using Bayer matrix.
            </summary>
            
            <remarks><para>The filter represents <see cref="T:Accord.Imaging.Filters.OrderedDithering"/> filter initialized
            with the next threshold matrix:</para>
            <code>
            byte[,] matrix = new byte[4, 4]
            {
            	{   0, 192,  48, 240 },
            	{ 128,  64, 176, 112 },
            	{  32, 224,  16, 208 },
            	{ 160,  96, 144,  80 }
            };
            </code>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            BayerDithering filter = new BayerDithering( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\grayscale.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\bayer_dithering.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BayerDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BayerDithering"/> class.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BurkesDithering">
            <summary>
            Dithering using Burkes error diffusion.
            </summary>
            
            <remarks><para>The filter represents binarization filter, which is based on
            error diffusion dithering with Burkes coefficients. Error is diffused
            on 7 neighbor pixels with next coefficients:</para>
            <code lang="none">
                    | * | 8 | 4 |
            | 2 | 4 | 8 | 4 | 2 |
            
            / 32
            </code>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            BurkesDithering filter = new BurkesDithering( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\grayscale.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\burkes.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.FloydSteinbergDithering"/>
            <seealso cref="T:Accord.Imaging.Filters.JarvisJudiceNinkeDithering"/>
            <seealso cref="T:Accord.Imaging.Filters.SierraDithering"/>
            <seealso cref="T:Accord.Imaging.Filters.StuckiDithering"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BurkesDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BurkesDithering"/> class.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ErrorDiffusionDithering">
            <summary>
            Base class for error diffusion dithering.
            </summary>
            
            <remarks><para>The class is the base class for binarization algorithms based on
            <a href="http://en.wikipedia.org/wiki/Error_diffusion">error diffusion</a>.</para>
            
            <para>Binarization with error diffusion in its idea is similar to binarization based on thresholding
            of pixels' cumulative value (see <see cref="T:Accord.Imaging.Filters.ThresholdWithCarry"/>). Each pixel is binarized based not only
            on its own value, but on values of some surrounding pixels. During pixel's binarization, its <b>binarization
            error</b> is distributed (diffused) to some neighbor pixels with some coefficients. This error diffusion
            updates neighbor pixels changing their values, what affects their upcoming binarization. Error diffuses
            only on unprocessed yet neighbor pixels, which are right and bottom pixels usually (in the case if image
            processing is done from upper left corner to bottom right corner). <b>Binarization error</b> equals
            to processing pixel value, if it is below threshold value, or pixel value minus 255 otherwise.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ErrorDiffusionDithering.ThresholdValue">
            <summary>
            Threshold value.
            </summary>
            
            <remarks>Default value is 128.</remarks>
            
        </member>
        <member name="F:Accord.Imaging.Filters.ErrorDiffusionDithering.x">
            <summary>
            Current processing X coordinate.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.ErrorDiffusionDithering.y">
            <summary>
            Current processing Y coordinate.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.ErrorDiffusionDithering.startX">
            <summary>
            Processing X start position.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.ErrorDiffusionDithering.startY">
            <summary>
            Processing Y start position.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.ErrorDiffusionDithering.stopX">
            <summary>
            Processing X stop position.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.ErrorDiffusionDithering.stopY">
            <summary>
            Processing Y stop position.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.ErrorDiffusionDithering.stride">
            <summary>
            Processing image's stride (line size).
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ErrorDiffusionDithering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.ErrorDiffusionDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ErrorDiffusionDithering"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ErrorDiffusionDithering.Diffuse(System.Int32,System.Byte*)">
            <summary>
            Do error diffusion.
            </summary>
            
            <param name="errorValue">Current error value.</param>
            <param name="ptr">Pointer to current processing pixel.</param>
            
            <remarks>All parameters of the image and current processing pixel's coordinates
            are initialized in protected members.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ErrorDiffusionDithering.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ErrorDiffusionToAdjacentNeighbors">
            <summary>
            Base class for error diffusion dithering, where error is diffused to 
            adjacent neighbor pixels.
            </summary>
            
            <remarks><para>The class does error diffusion to adjacent neighbor pixels
            using specified set of coefficients. These coefficients are represented by
            2 dimensional jugged array, where first array of coefficients is for
            right-standing pixels, but the rest of arrays are for bottom-standing pixels.
            All arrays except the first one should have odd number of coefficients.</para>
            
            <para>Suppose that error diffusion coefficients are represented by the next
            jugged array:</para>
            
            <code>
            int[][] coefficients = new int[2][] {
                new int[1] { 7 },
                new int[3] { 3, 5, 1 }
            };
            </code>
            
            <para>The above coefficients are used to diffuse error over the next neighbor
            pixels (<b>*</b> marks current pixel, coefficients are placed to corresponding
            neighbor pixels):</para>
            <code lang="none">
                | * | 7 |
            | 3 | 5 | 1 |
            
            / 16
            </code>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ErrorDiffusionToAdjacentNeighbors filter = new ErrorDiffusionToAdjacentNeighbors(
                new int[3][] {
                    new int[2] { 5, 3 },
                    new int[5] { 2, 4, 5, 4, 2 },
                    new int[3] { 2, 3, 2 }
                } );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ErrorDiffusionToAdjacentNeighbors.Coefficients">
            <summary>
            Diffusion coefficients.
            </summary>
            
            <remarks>Set of coefficients, which are used for error diffusion to
            pixel's neighbors.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ErrorDiffusionToAdjacentNeighbors.#ctor(System.Int32[][])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ErrorDiffusionToAdjacentNeighbors"/> class.
            </summary>
            
            <param name="coefficients">Diffusion coefficients.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ErrorDiffusionToAdjacentNeighbors.Diffuse(System.Int32,System.Byte*)">
            <summary>
            Do error diffusion.
            </summary>
            
            <param name="errorValue">Current error value.</param>
            <param name="ptr">Pointer to current processing pixel.</param>
            
            <remarks>All parameters of the image and current processing pixel's coordinates
            are initialized by base class.</remarks>
            
        </member>
        <member name="T:Accord.Imaging.Filters.FloydSteinbergDithering">
            <summary>
            Dithering using Floyd-Steinberg error diffusion.
            </summary>
            
            <remarks><para>The filter represents binarization filter, which is based on
            error diffusion dithering with <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering">Floyd-Steinberg</a>
            coefficients. Error is diffused on 4 neighbor pixels with next coefficients:</para>
            
            <code lang="none">
                | * | 7 |
            | 3 | 5 | 1 |
            
            / 16
            </code>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            FloydSteinbergDithering filter = new FloydSteinbergDithering( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\grayscale.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\floyd_steinberg.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.BurkesDithering"/>
            <seealso cref="T:Accord.Imaging.Filters.JarvisJudiceNinkeDithering"/>
            <seealso cref="T:Accord.Imaging.Filters.SierraDithering"/>
            <seealso cref="T:Accord.Imaging.Filters.StuckiDithering"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FloydSteinbergDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FloydSteinbergDithering"/> class.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.Filters.JarvisJudiceNinkeDithering">
             <summary>
             Dithering using Jarvis, Judice and Ninke error diffusion.
             </summary>
             
             <remarks><para>The filter represents binarization filter, which is based on
             error diffusion dithering with Jarvis-Judice-Ninke coefficients. Error is diffused
             on 12 neighbor pixels with next coefficients:</para>
             <code lang="none">
                     | * | 7 | 5 |
             | 3 | 5 | 7 | 5 | 3 |
             | 1 | 3 | 5 | 3 | 1 |
             
             / 48
             </code>
             
             <para>The filter accepts 8 bpp grayscale images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             JarvisJudiceNinkeDithering filter = new JarvisJudiceNinkeDithering( );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\grayscale.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\jarvis_judice_ninke.jpg" width="480" height="361" />
             </remarks>
            
             <seealso cref="T:Accord.Imaging.Filters.BurkesDithering"/>
             <seealso cref="T:Accord.Imaging.Filters.FloydSteinbergDithering"/>
             <seealso cref="T:Accord.Imaging.Filters.SierraDithering"/>
             <seealso cref="T:Accord.Imaging.Filters.StuckiDithering"/>
             
        </member>
        <member name="M:Accord.Imaging.Filters.JarvisJudiceNinkeDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.JarvisJudiceNinkeDithering"/> class.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.Filters.OrderedDithering">
            <summary>
            Binarization with thresholds matrix.
            </summary>
            
            <remarks><para>Idea of the filter is the same as idea of <see cref="T:Accord.Imaging.Filters.Threshold"/> filter -
            change pixel value to white, if its intensity is equal or higher than threshold value, or
            to black otherwise. But instead of using single threshold value for all pixel, the filter
            uses matrix of threshold values. Processing image is divided to adjacent windows of matrix
            size each. For pixels binarization inside of each window, corresponding threshold values are
            used from specified threshold matrix.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create binarization matrix
            byte[,] matrix = new byte[4, 4]
            {
                {  95, 233, 127, 255 },
                { 159,  31, 191,  63 },
                { 111, 239,  79, 207 },
                { 175,  47, 143,  15 }
            };
            // create filter
            OrderedDithering filter = new OrderedDithering( matrix );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\grayscale.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\ordered_dithering.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.BayerDithering"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.OrderedDithering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.OrderedDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.OrderedDithering"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.OrderedDithering.#ctor(System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.OrderedDithering"/> class.
            </summary>
            
            <param name="matrix">Thresholds matrix.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.OrderedDithering.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.SierraDithering">
            <summary>
            Dithering using Sierra error diffusion.
            </summary>
            
            <remarks><para>The filter represents binarization filter, which is based on
            error diffusion dithering with Sierra coefficients. Error is diffused
            on 10 neighbor pixels with next coefficients:</para>
            <code lang="none">
                    | * | 5 | 3 |
            | 2 | 4 | 5 | 4 | 2 |
                | 2 | 3 | 2 |
            
            / 32
            </code>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            SierraDithering filter = new SierraDithering( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\grayscale.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\sierra.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.BurkesDithering"/>
            <seealso cref="T:Accord.Imaging.Filters.FloydSteinbergDithering"/>
            <seealso cref="T:Accord.Imaging.Filters.JarvisJudiceNinkeDithering"/>
            <seealso cref="T:Accord.Imaging.Filters.StuckiDithering"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SierraDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SierraDithering"/> class.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.Filters.StuckiDithering">
             <summary>
             Dithering using Stucki error diffusion.
             </summary>
             
             <remarks><para>The filter represents binarization filter, which is based on
             error diffusion dithering with Stucki coefficients. Error is diffused
             on 12 neighbor pixels with next coefficients:</para>
             <code lang="none">
                     | * | 8 | 4 |
             | 2 | 4 | 8 | 4 | 2 |
             | 1 | 2 | 4 | 2 | 1 |
             
             / 42
             </code>
             
             <para>The filter accepts 8 bpp grayscale images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             StuckiDithering filter = new StuckiDithering( );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\grayscale.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\stucki.jpg" width="480" height="361" />
             </remarks>
            
             <seealso cref="T:Accord.Imaging.Filters.BurkesDithering"/>
             <seealso cref="T:Accord.Imaging.Filters.FloydSteinbergDithering"/>
             <seealso cref="T:Accord.Imaging.Filters.JarvisJudiceNinkeDithering"/>
             <seealso cref="T:Accord.Imaging.Filters.SierraDithering"/>
             
        </member>
        <member name="M:Accord.Imaging.Filters.StuckiDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.StuckiDithering"/> class.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Threshold">
            <summary>
            Threshold binarization.
            </summary>
            
            <remarks><para>The filter does image binarization using specified threshold value. All pixels
            with intensities equal or higher than threshold value are converted to white pixels. All other
            pixels with intensities below threshold value are converted to black pixels.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images for processing.</para>
            
            <para><note>Since the filter can be applied as to 8 bpp and to 16 bpp images,
            the <see cref="P:Accord.Imaging.Filters.Threshold.ThresholdValue"/> value should be set appropriately to the pixel format.
            In the case of 8 bpp images the threshold value is in the [0, 255] range, but in the case
            of 16 bpp images the threshold value is in the [0, 65535] range.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Threshold filter = new Threshold( 100 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\grayscale.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\threshold.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="F:Accord.Imaging.Filters.Threshold.threshold">
            <summary>
            Threshold value.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.Threshold.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.Threshold.ThresholdValue">
            <summary>
            Threshold value.
            </summary>
            
            <remarks>Default value is set to <b>128</b>.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Threshold.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Threshold"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Threshold.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Threshold"/> class.
            </summary>
            
            <param name="threshold">Threshold value.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Threshold.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ThresholdWithCarry">
            <summary>
            Threshold binarization with error carry.
            </summary>
            
            <remarks><para>The filter is similar to <see cref="T:Accord.Imaging.Filters.Threshold"/> filter in the way,
            that it also uses threshold value for image binarization. Unlike regular threshold
            filter, this filter uses cumulative pixel value in comparing with threshold value.
            If cumulative pixel value is below threshold value, then image pixel becomes black.
            If cumulative pixel value is equal or higher than threshold value, then image pixel
            becomes white and cumulative pixel value is decreased by 255. In the beginning of each
            image line the cumulative value is reset to 0.
            </para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Threshold filter = new Threshold( 100 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\grayscale.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\threshold_carry.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ThresholdWithCarry.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ThresholdWithCarry.ThresholdValue">
            <summary>
            Threshold value.
            </summary>
            
            <remarks>Default value is 128.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ThresholdWithCarry.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ThresholdWithCarry"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ThresholdWithCarry.#ctor(System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ThresholdWithCarry"/> class.
            </summary>
            
            <param name="threshold">Threshold value.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ThresholdWithCarry.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BayerFilter">
            <summary>
            Generic Bayer fileter image processing routine.
            </summary>
            
            <remarks><para>The class implements <a href="http://en.wikipedia.org/wiki/Bayer_filter">Bayer filter</a>
            routine, which creates color image out of grayscale image produced by image sensor built with
            Bayer color matrix.</para>
            
            <para>This Bayer filter implementation is made generic by allowing user to specify used
            <see cref="P:Accord.Imaging.Filters.BayerFilter.BayerPattern">Bayer pattern</see>. This makes it slower. For optimized version
            of the Bayer filter see <see cref="T:Accord.Imaging.Filters.BayerFilterOptimized"/> class, which implements Bayer filter
            specifically optimized for some well known patterns.</para>
            
            <para>The filter accepts 8 bpp grayscale images and produces 24 bpp RGB image.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            BayerFilter filter = new BayerFilter( );
            // apply the filter
            Bitmap rgbImage = filter.Apply( image );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="..\images\imaging\sample23.png" width="640" height="480" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\bayer_filter.jpg" width="640" height="480" />
            </remarks>
            
            <see cref="T:Accord.Imaging.Filters.BayerFilterOptimized"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BayerFilter.PerformDemosaicing">
            <summary>
            Specifies if demosaicing must be done or not.
            </summary>
            
            <remarks><para>The property specifies if color demosaicing must be done or not.
            If the property is set to <see langword="false"/>, then pixels of the result color image
            are colored according to the <see cref="P:Accord.Imaging.Filters.BayerFilter.BayerPattern">Bayer pattern</see> used, i.e. every pixel
            of the source grayscale image is copied to corresponding color plane of the result image.
            If the property is set to <see langword="true"/>, then pixels of the result image
            are set to color, which is obtained by averaging color components from the 3x3 window - pixel
            itself plus 8 surrounding neighbors.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BayerFilter.BayerPattern">
            <summary>
            Specifies Bayer pattern used for decoding color image.
            </summary>
            
            <remarks><para>The property specifies 2x2 array of RGB color indexes, which set the
            Bayer patter used for decoding color image.</para>
            
            <para>By default the property is set to:
            <code>
            new int[2, 2] { { RGB.G, RGB.R }, { RGB.B, RGB.G } }
            </code>,
            which corresponds to
            <code lang="none">
            G R
            B G
            </code>
            pattern.
            </para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BayerFilter.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BayerFilter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BayerFilter"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BayerFilter.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BayerPattern">
            <summary>
            Set of Bayer patterns supported by <see cref="T:Accord.Imaging.Filters.BayerFilterOptimized"/>.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.BayerPattern.GRBG">
            <summary>
            Pattern:<br /><br />
            G R<br />
            B G
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.BayerPattern.BGGR">
            <summary>
            Pattern:<br /><br />
            B G<br />
            G R
            </summary>
        </member>
        <member name="T:Accord.Imaging.Filters.BayerFilterOptimized">
            <summary>
            Optimized Bayer fileter image processing routine.
            </summary>
            
            <remarks><para>The class implements <a href="http://en.wikipedia.org/wiki/Bayer_filter">Bayer filter</a>
            routine, which creates color image out of grayscale image produced by image sensor built with
            Bayer color matrix.</para>
            
            <para>This class does all the same as <see cref="T:Accord.Imaging.Filters.BayerFilter"/> class. However this version is
            optimized for some well known patterns defined in <see cref="T:Accord.Imaging.Filters.BayerPattern"/> enumeration.
            Also this class processes images with even width and height only. Image size must be at least 2x2 pixels.
            </para>
            
            <para>The filter accepts 8 bpp grayscale images and produces 24 bpp RGB image.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            BayerFilter filter = new BayerFilter( );
            // apply the filter
            Bitmap rgbImage = filter.Apply( image );
            </code>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.BayerFilter"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BayerFilterOptimized.Pattern">
            <summary>
            Bayer pattern of source images to decode.
            </summary>
            
            <remarks><para>The property specifies Bayer pattern of source images to be
            decoded into color images.</para>
            
            <para>Default value is set to <see cref="F:Accord.Imaging.Filters.BayerPattern.GRBG"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BayerFilterOptimized.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BayerFilterOptimized.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BayerFilterOptimized"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BayerFilterOptimized.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BrightnessCorrection">
            <summary>
            Brightness adjusting in RGB color space.
            </summary>
            
            <remarks><para>The filter operates in <b>RGB</b> color space and adjusts
            pixels' brightness by increasing every pixel's RGB values by the specified
            <see cref="P:Accord.Imaging.Filters.BrightnessCorrection.AdjustValue">adjust value</see>. The filter is based on <see cref="T:Accord.Imaging.Filters.LevelsLinear"/>
            filter and simply sets all input ranges to (0, 255-<see cref="P:Accord.Imaging.Filters.BrightnessCorrection.AdjustValue"/>) and
            all output range to (<see cref="P:Accord.Imaging.Filters.BrightnessCorrection.AdjustValue"/>, 255) in the case if the adjust value is positive.
            If the adjust value is negative, then all input ranges are set to
            (-<see cref="P:Accord.Imaging.Filters.BrightnessCorrection.AdjustValue"/>, 255 ) and all output ranges are set to
            ( 0, 255+<see cref="P:Accord.Imaging.Filters.BrightnessCorrection.AdjustValue"/>).</para>
            
            <para>See <see cref="T:Accord.Imaging.Filters.LevelsLinear"/> documentation for more information about the base filter.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            BrightnessCorrection filter = new BrightnessCorrection( -50 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\brightness_correction.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.LevelsLinear"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BrightnessCorrection.AdjustValue">
             <summary>
             Brightness adjust value, [-255, 255].
             </summary>
             
             <remarks>Default value is set to <b>10</b>, which corresponds to increasing
             RGB values of each pixel by 10.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BrightnessCorrection.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
             documentation for additional information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BrightnessCorrection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BrightnessCorrection"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BrightnessCorrection.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BrightnessCorrection"/> class.
            </summary>
            
            <param name="adjustValue">Brightness <see cref="P:Accord.Imaging.Filters.BrightnessCorrection.AdjustValue">adjust value</see>.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BrightnessCorrection.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ChannelFiltering">
            <summary>
            Channels filters.
            </summary>
            
            <remarks><para>The filter does color channels' filtering by clearing (filling with
            specified values) values, which are inside/outside of the specified value's
            range. The filter allows to fill certain ranges of RGB color channels with specified
            value.</para>
            
            <para>The filter is similar to <see cref="T:Accord.Imaging.Filters.ColorFiltering"/>, but operates with not
            entire pixels, but with their RGB values individually. This means that pixel itself may
            not be filtered (will be kept), but one of its RGB values may be filtered if they are
            inside/outside of specified range.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ChannelFiltering filter = new ChannelFiltering( );
            // set channels' ranges to keep
            filter.Red   = new IntRange(   0, 255 );
            filter.Green = new IntRange( 100, 255 );
            filter.Blue  = new IntRange( 100, 255 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\channel_filtering.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.ColorFiltering"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ChannelFiltering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ChannelFiltering.Red">
            <summary>
            Red channel's range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ChannelFiltering.FillRed">
            <summary>
            Red fill value.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ChannelFiltering.Green">
            <summary>
            Green channel's range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ChannelFiltering.FillGreen">
            <summary>
            Green fill value.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ChannelFiltering.Blue">
            <summary>
            Blue channel's range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ChannelFiltering.FillBlue">
            <summary>
            Blue fill value.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ChannelFiltering.RedFillOutsideRange">
            <summary>
            Determines, if red channel should be filled inside or outside filtering range.
            </summary>
            
            <remarks>Default value is set to <see langword="true"/>.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ChannelFiltering.GreenFillOutsideRange">
            <summary>
            Determines, if green channel should be filled inside or outside filtering range.
            </summary>
            
            <remarks>Default value is set to <see langword="true"/>.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ChannelFiltering.BlueFillOutsideRange">
             <summary>
             Determines, if blue channel should be filled inside or outside filtering range.
             </summary>
             
             <remarks>Default value is set to <see langword="true"/>.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ChannelFiltering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ChannelFiltering"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ChannelFiltering.#ctor(Accord.IntRange,Accord.IntRange,Accord.IntRange)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ChannelFiltering"/> class.
            </summary>
            
            <param name="red">Red channel's filtering range.</param>
            <param name="green">Green channel's filtering range.</param>
            <param name="blue">Blue channel's filtering range.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ChannelFiltering.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ChannelFiltering.CalculateMap(Accord.IntRange,System.Byte,System.Boolean,System.Byte[])">
            <summary>
            Calculate filtering map.
            </summary>
            
            <param name="range">Filtering range.</param>
            <param name="fill">Fillter value.</param>
            <param name="fillOutsideRange">Fill outside or inside the range.</param>
            <param name="map">Filtering map.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ColorFiltering">
            <summary>
            Color filtering.
            </summary>
            
            <remarks><para>The filter filters pixels inside/outside of specified RGB color range -
            it keeps pixels with colors inside/outside of specified range and fills the rest with
            <see cref="P:Accord.Imaging.Filters.ColorFiltering.FillColor">specified color</see>.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ColorFiltering filter = new ColorFiltering( );
            // set color ranges to keep
            filter.Red   = new IntRange( 100, 255 );
            filter.Green = new IntRange( 0, 75 );
            filter.Blue  = new IntRange( 0, 75 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\color_filtering.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.ChannelFiltering"/>
            <seealso cref="T:Accord.Imaging.Filters.EuclideanColorFiltering"/>
            <seealso cref="T:Accord.Imaging.Filters.HSLFiltering"/>
            <seealso cref="T:Accord.Imaging.Filters.YCbCrFiltering"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ColorFiltering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ColorFiltering.Red">
            <summary>
            Range of red color component.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ColorFiltering.Green">
            <summary>
            Range of green color component.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ColorFiltering.Blue">
            <summary>
            Range of blue color component.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ColorFiltering.FillColor">
            <summary>
            Fill color used to fill filtered pixels.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ColorFiltering.FillOutsideRange">
            <summary>
            Determines, if pixels should be filled inside or outside of specified
            color ranges.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/>, which means
            the filter removes colors outside of the specified range.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ColorFiltering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ColorFiltering"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ColorFiltering.#ctor(Accord.IntRange,Accord.IntRange,Accord.IntRange)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ColorFiltering"/> class.
            </summary>
            
            <param name="red">Red components filtering range.</param>
            <param name="green">Green components filtering range.</param>
            <param name="blue">Blue components filtering range.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ColorFiltering.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ColorRemapping">
            <summary>
            Color remapping.
            </summary>
            
            <remarks><para>The filter allows to remap colors of the image. Unlike <see cref="T:Accord.Imaging.Filters.LevelsLinear"/> filter
            the filter allow to do non-linear remapping. For each pixel of specified image the filter changes
            its values (value of each color plane) to values, which are stored in remapping arrays by corresponding
            indexes. For example, if pixel's RGB value equals to (32, 96, 128), the filter will change it to
            (<see cref="P:Accord.Imaging.Filters.ColorRemapping.RedMap"/>[32], <see cref="P:Accord.Imaging.Filters.ColorRemapping.GreenMap"/>[96], <see cref="P:Accord.Imaging.Filters.ColorRemapping.BlueMap"/>[128]).</para>
            
            <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create map
            byte[] map = new byte[256];
            for ( int i = 0; i &lt; 256; i++ )
            {
                map[i] = (byte) Math.Min( 255, Math.Pow( 2, (double) i / 32 ) );
            }
            // create filter
            ColorRemapping filter = new ColorRemapping( map, map, map );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\color_remapping.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ColorRemapping.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ColorRemapping.RedMap">
            <summary>
            Remapping array for red color plane.
            </summary>
            
            <remarks><para>The remapping array should contain 256 remapping values. The remapping occurs
            by changing pixel's red value <b>r</b> to <see cref="P:Accord.Imaging.Filters.ColorRemapping.RedMap"/>[r].</para></remarks>
            
            <exception cref="T:System.ArgumentException">A map should be array with 256 value.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ColorRemapping.GreenMap">
            <summary>
            Remapping array for green color plane.
            </summary>
            
            <remarks><para>The remapping array should contain 256 remapping values. The remapping occurs
            by changing pixel's green value <b>g</b> to <see cref="P:Accord.Imaging.Filters.ColorRemapping.GreenMap"/>[g].</para></remarks>
            
            <exception cref="T:System.ArgumentException">A map should be array with 256 value.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ColorRemapping.BlueMap">
            <summary>
            Remapping array for blue color plane.
            </summary>
            
            <remarks><para>The remapping array should contain 256 remapping values. The remapping occurs
            by changing pixel's blue value <b>b</b> to <see cref="P:Accord.Imaging.Filters.ColorRemapping.BlueMap"/>[b].</para></remarks>
            
            <exception cref="T:System.ArgumentException">A map should be array with 256 value.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ColorRemapping.GrayMap">
            <summary>
            Remapping array for gray color.
            </summary>
            
            <remarks><para>The remapping array should contain 256 remapping values. The remapping occurs
            by changing pixel's value <b>g</b> to <see cref="P:Accord.Imaging.Filters.ColorRemapping.GrayMap"/>[g].</para>
            
            <para>The gray map is for grayscale images only.</para></remarks>
            
            <exception cref="T:System.ArgumentException">A map should be array with 256 value.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ColorRemapping.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ColorRemapping"/> class.
            </summary>
            
            <remarks>Initializes the filter without any remapping. All
            pixel values are mapped to the same values.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ColorRemapping.#ctor(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ColorRemapping"/> class.
            </summary>
            
            <param name="redMap">Red map.</param>
            <param name="greenMap">Green map.</param>
            <param name="blueMap">Blue map.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ColorRemapping.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ColorRemapping"/> class.
            </summary>
            
            <param name="grayMap">Gray map.</param>
            
            <remarks>This constructor is supposed for grayscale images.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ColorRemapping.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ContrastCorrection">
             <summary>
             Contrast adjusting in RGB color space.
             </summary>
             
             <remarks><para>The filter operates in <b>RGB</b> color space and adjusts
             pixels' contrast value by increasing RGB values of bright pixel and decreasing
             RGB values of dark pixels (or vise versa if contrast needs to be decreased).
             The filter is based on <see cref="T:Accord.Imaging.Filters.LevelsLinear"/>
             filter and simply sets all input ranges to (<see cref="P:Accord.Imaging.Filters.ContrastCorrection.Factor"/>, 255-<see cref="P:Accord.Imaging.Filters.ContrastCorrection.Factor"/>) and
             all output range to (0, 255) in the case if the factor value is positive.
             If the factor value is negative, then all input ranges are set to
             (0, 255 ) and all output ranges are set to
             (-<see cref="P:Accord.Imaging.Filters.ContrastCorrection.Factor"/>, 255_<see cref="P:Accord.Imaging.Filters.ContrastCorrection.Factor"/>).</para>
             
             <para>See <see cref="T:Accord.Imaging.Filters.LevelsLinear"/> documentation forr more information about the base filter.</para>
             
             <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
             <para>Sample usage:</para>
             <code>
             // create filter
             ContrastCorrection filter = new ContrastCorrection( 15 );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\contrast_correction.jpg" width="480" height="361" />
             </remarks>
            
             <seealso cref="T:Accord.Imaging.Filters.LevelsLinear"/>
             
        </member>
        <member name="P:Accord.Imaging.Filters.ContrastCorrection.Factor">
            <summary>
            Contrast adjusting factor, [-127, 127].
            </summary>
            
            <remarks><para>Factor which is used to adjust contrast. Factor values greater than
            0 increase contrast making light areas lighter and dark areas darker. Factor values
            less than 0 decrease contrast - decreasing variety of contrast.</para>
            
            <para>Default value is set to <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ContrastCorrection.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
             documentation for additional information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ContrastCorrection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ContrastCorrection"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ContrastCorrection.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ContrastCorrection"/> class.
            </summary>
            
            <param name="factor">Contrast <see cref="P:Accord.Imaging.Filters.ContrastCorrection.Factor">adjusting factor</see>.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ContrastCorrection.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ContrastStretch">
            <summary>
            Contrast stretching filter.
            </summary>
            
            <remarks><para>Contrast stretching (or as it is often called normalization) is a simple image enhancement
            technique that attempts to improve the contrast in an image by 'stretching' the range of intensity values
            it contains to span a desired range of values, e.g. the full range of pixel values that the image type
            concerned allows. It differs from the more sophisticated <see cref="T:Accord.Imaging.Filters.HistogramEqualization">histogram equalization</see>
            in that it can only apply a linear scaling function to the image pixel values.</para>
            
            <para>The result of this filter may be achieved by using <see cref="T:Accord.Imaging.ImageStatistics"/> class, which allows to
            get pixels' intensities histogram, and <see cref="T:Accord.Imaging.Filters.LevelsLinear"/> filter, which does linear correction
            of pixel's intensities.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24 bpp color images.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ContrastStretch filter = new ContrastStretch( );
            // process image
            filter.ApplyInPlace( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="..\images\imaging\sample5.jpg" width="480" height="387" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\contrast_stretch.jpg" width="480" height="387" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ContrastStretch.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.ContrastStretch.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ContrastStretch"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.ContrastStretch.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.EuclideanColorFiltering">
             <summary>
             Euclidean color filtering.
             </summary>
             
             <remarks><para>The filter filters pixels, which color is inside/outside
             of RGB sphere with specified center and radius - it keeps pixels with
             colors inside/outside of the specified sphere and fills the rest with
             <see cref="P:Accord.Imaging.Filters.EuclideanColorFiltering.FillColor">specified color</see>.</para>
             
             <para>The filter accepts 24 and 32 bpp color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             EuclideanColorFiltering filter = new EuclideanColorFiltering( );
             // set center colol and radius
             filter.CenterColor = new RGB( 215, 30, 30 );
             filter.Radius = 100;
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
            
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\euclidean_filtering.jpg" width="480" height="361" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.ColorFiltering"/>
             
        </member>
        <member name="P:Accord.Imaging.Filters.EuclideanColorFiltering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.EuclideanColorFiltering.Radius">
            <summary>
            RGB sphere's radius, [0, 450].
            </summary>
            
            <remarks>Default value is 100.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.EuclideanColorFiltering.CenterColor">
            <summary>
            RGB sphere's center.
            </summary>
            
            <remarks>Default value is (255, 255, 255) - white color.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.EuclideanColorFiltering.FillColor">
            <summary>
            Fill color used to fill filtered pixels.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.EuclideanColorFiltering.FillOutside">
            <summary>
            Determines, if pixels should be filled inside or outside specified
            RGB sphere.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/>, which means
            the filter removes colors outside of the specified range.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.EuclideanColorFiltering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.EuclideanColorFiltering"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.EuclideanColorFiltering.#ctor(Accord.Imaging.RGB,System.Int16)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.EuclideanColorFiltering"/> class.
            </summary>
            
            <param name="center">RGB sphere's center.</param>
            <param name="radius">RGB sphere's radius.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.EuclideanColorFiltering.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ExtractChannel">
            <summary>
            Extract RGB channel from image.
            </summary>
            
            <remarks><para>Extracts specified channel of color image and returns
            it as grayscale image.</para>
            
            <para>The filter accepts 24, 32, 48 and 64 bpp color images and produces
            8 (if source is 24 or 32 bpp image) or 16 (if source is 48 or 64 bpp image)
            bpp grayscale image.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ExtractChannel filter = new ExtractChannel( RGB.G );
            // apply the filter
            Bitmap channelImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\extract_channel.jpg" width="480" height="361" />
            
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.ReplaceChannel"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ExtractChannel.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ExtractChannel.Channel">
            <summary>
            ARGB channel to extract.
            </summary>
            
            <remarks><para>Default value is set to <see cref="F:Accord.Imaging.RGB.R"/>.</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid channel is specified.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ExtractChannel.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ExtractChannel"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ExtractChannel.#ctor(System.Int16)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ExtractChannel"/> class.
            </summary>
            
            <param name="channel">ARGB channel to extract.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ExtractChannel.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Can not extract alpha channel from none ARGB image. The
            exception is throw, when alpha channel is requested from RGB image.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.GammaCorrection">
            <summary>
            Gamma correction filter.
            </summary>
            
            <remarks><para>The filter performs <a href="http://en.wikipedia.org/wiki/Gamma_correction">gamma correction</a>
            of specified image in RGB color space. Each pixels' value is converted using the V<sub>out</sub>=V<sub>in</sub><sup>g</sup>
            equation, where <b>g</b> is <see cref="P:Accord.Imaging.Filters.GammaCorrection.Gamma">gamma value</see>.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            GammaCorrection filter = new GammaCorrection( 0.5 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\gamma.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.GammaCorrection.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.GammaCorrection.Gamma">
            <summary>
            Gamma value, [0.1, 5.0].
            </summary>
            
            <remarks>Default value is set to <b>2.2</b>.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GammaCorrection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GammaCorrection"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.GammaCorrection.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GammaCorrection"/> class.
            </summary>
            
            <param name="gamma">Gamma value.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GammaCorrection.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Grayscale">
             <summary>
             Base class for image grayscaling.
             </summary>
             
             <remarks><para>This class is the base class for image grayscaling. Other
             classes should inherit from this class and specify <b>RGB</b>
             coefficients used for color image conversion to grayscale.</para>
             
             <para>The filter accepts 24, 32, 48 and 64 bpp color images and produces
             8 (if source is 24 or 32 bpp image) or 16 (if source is 48 or 64 bpp image)
             bpp grayscale image.</para>
             
             <para>Sample usage:</para>
             <code>
             // create grayscale filter (BT709)
             Grayscale filter = new Grayscale( 0.2125, 0.7154, 0.0721 );
             // apply the filter
             Bitmap grayImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\grayscale.jpg" width="480" height="361" />
             </remarks>
            
             <seealso cref="T:Accord.Imaging.Filters.GrayscaleBT709"/>
             <seealso cref="T:Accord.Imaging.Filters.GrayscaleRMY"/>
             <seealso cref="T:Accord.Imaging.Filters.GrayscaleY"/>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Grayscale.CommonAlgorithms">
            <summary>
              Set of predefined common grayscaling algorithms, which have
              already initialized grayscaling coefficients.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.Grayscale.CommonAlgorithms.BT709">
            <summary>
              Grayscale image using BT709 algorithm.
            </summary>
            
            <remarks>
            <para>The instance uses <b>BT709</b> algorithm to convert color image
              to grayscale. The conversion coefficients are:
              <list type="bullet">
              <item>Red: 0.2125;</item>
              <item>Green: 0.7154;</item>
              <item>Blue: 0.0721.</item>
              </list></para>
            
            <para>Sample usage:</para>
            
            <code>
              // apply the filter
              Bitmap grayImage = Grayscale.CommonAlgorithms.BT709.Apply( image );
            </code>
            </remarks>
            
        </member>
        <member name="F:Accord.Imaging.Filters.Grayscale.CommonAlgorithms.RMY">
            <summary>
              Grayscale image using R-Y algorithm.
            </summary>
            
            <remarks>
              <para>The instance uses <b>R-Y</b> algorithm to convert color image
              to grayscale. The conversion coefficients are:
              <list type="bullet">
              <item>Red: 0.5;</item>
              <item>Green: 0.419;</item>
              <item>Blue: 0.081.</item>
              </list></para>
            
            <para>Sample usage:</para>
            
            <code>
              // apply the filter
              Bitmap grayImage = Grayscale.CommonAlgorithms.RMY.Apply( image );
            </code>
            </remarks>
            
        </member>
        <member name="F:Accord.Imaging.Filters.Grayscale.CommonAlgorithms.Y">
            <summary>
              Grayscale image using Y algorithm.
            </summary>
            
            <remarks>
              <para>The instance uses <b>Y</b> algorithm to convert color image
              to grayscale. The conversion coefficients are:
              <list type="bullet">
              <item>Red: 0.299;</item>
              <item>Green: 0.587;</item>
              <item>Blue: 0.114.</item>
              </list></para>
            
            <para>Sample usage:</para>
              
              <code>
              // apply the filter
              Bitmap grayImage = Grayscale.CommonAlgorithms.Y.Apply( image );
              </code>
            </remarks>
            
        </member>
        <member name="F:Accord.Imaging.Filters.Grayscale.RedCoefficient">
            <summary>
              Portion of red channel's value to use during conversion from RGB to grayscale.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.Grayscale.GreenCoefficient">
            <summary>
              Portion of green channel's value to use during conversion from RGB to grayscale.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.Grayscale.BlueCoefficient">
            <summary>
              Portion of blue channel's value to use during conversion from RGB to grayscale.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Grayscale.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Grayscale.#ctor(System.Double,System.Double,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Grayscale"/> class.
            </summary>
            
            <param name="cr">Red coefficient.</param>
            <param name="cg">Green coefficient.</param>
            <param name="cb">Blue coefficient.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Grayscale.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.GrayscaleBT709">
             <summary>
             Grayscale image using BT709 algorithm.
             </summary>
             
             <remarks>The class uses <b>BT709</b> algorithm to convert color image
             to grayscale. The conversion coefficients are:
             <list type="bullet">
             <item>Red: 0.2125;</item>
             <item>Green: 0.7154;</item>
             <item>Blue: 0.0721.</item>
             </list>
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.Grayscale"/>
             <seealso cref="T:Accord.Imaging.Filters.GrayscaleRMY"/>
             <seealso cref="T:Accord.Imaging.Filters.GrayscaleY"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GrayscaleBT709.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GrayscaleBT709"/> class.
            </summary>
        </member>
        <member name="T:Accord.Imaging.Filters.GrayscaleRMY">
             <summary>
             Grayscale image using R-Y algorithm.
             </summary>
             
             <remarks>The class uses <b>R-Y</b> algorithm to convert color image
             to grayscale. The conversion coefficients are:
             <list type="bullet">
             <item>Red: 0.5;</item>
             <item>Green: 0.419;</item>
             <item>Blue: 0.081.</item>
             </list>
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.Grayscale"/>
             <seealso cref="T:Accord.Imaging.Filters.GrayscaleBT709"/>
             <seealso cref="T:Accord.Imaging.Filters.GrayscaleY"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GrayscaleRMY.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GrayscaleRMY"/> class.
            </summary>
        </member>
        <member name="T:Accord.Imaging.Filters.GrayscaleToRGB">
            <summary>
            Convert grayscale image to RGB.
            </summary>
            
            <remarks><para>The filter creates color image from specified grayscale image
            initializing all RGB channels to the same value - pixel's intensity of grayscale image.</para>
            
            <para>The filter accepts 8 bpp grayscale images and produces
            24 bpp RGB image.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            GrayscaleToRGB filter = new GrayscaleToRGB( );
            // apply the filter
            Bitmap rgbImage = filter.Apply( image );
            </code>
            
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.GrayscaleToRGB.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.GrayscaleToRGB.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GrayscaleToRGB"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GrayscaleToRGB.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.GrayscaleY">
             <summary>
             Grayscale image using Y algorithm.
             </summary>
             
             <remarks>The class uses <b>Y</b> algorithm to convert color image
             to grayscale. The conversion coefficients are:
             <list type="bullet">
             <item>Red: 0.299;</item>
             <item>Green: 0.587;</item>
             <item>Blue: 0.114.</item>
             </list>
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.Grayscale"/>
             <seealso cref="T:Accord.Imaging.Filters.GrayscaleBT709"/>
             <seealso cref="T:Accord.Imaging.Filters.GrayscaleRMY"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GrayscaleY.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GrayscaleY"/> class.
            </summary>
        </member>
        <member name="T:Accord.Imaging.Filters.HistogramEqualization">
             <summary>
             Histogram equalization filter.
             </summary>
            
             <remarks><para>The filter does histogram equalization increasing local contrast in images. The effect
             of histogram equalization can be better seen on images, where pixel values have close contrast values.
             Through this adjustment, pixels intensities can be better distributed on the histogram. This allows for
             areas of lower local contrast to gain a higher contrast without affecting the global contrast.
             </para>
             
             <para>The filter accepts 8 bpp grayscale images and 24/32 bpp
             color images for processing.</para>
             
             <para><note>For color images the histogram equalization is applied to each color plane separately.</note></para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             HistogramEqualization filter = new HistogramEqualization( );
             // process image
             filter.ApplyInPlace( sourceImage );
             </code>
             
             <para><b>Source image:</b></para>
             <img src="..\images\imaging\sample5.jpg" width="480" height="387" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\equalized.jpg" width="480" height="387" />
             </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HistogramEqualization.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.HistogramEqualization.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HistogramEqualization"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.HistogramEqualization.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Invert">
             <summary>
             Invert image.
             </summary>
             
             <remarks><para>The filter inverts colored and grayscale images.</para>
            
             <para>The filter accepts 8, 16 bpp grayscale and 24, 48 bpp color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Invert filter = new Invert( );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\invert.jpg" width="480" height="361" />
             </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Invert.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Invert.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Invert"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Invert.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.LevelsLinear">
            <summary>
            Linear correction of RGB channels.
            </summary>
            
            <remarks><para>The filter performs linear correction of RGB channels by mapping specified
            channels' input ranges to output ranges. It is similar to the
            <see cref="T:Accord.Imaging.Filters.ColorRemapping"/>, but the remapping is linear.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            LevelsLinear filter = new LevelsLinear( );
            // set ranges
            filter.InRed   = new IntRange( 30, 230 );
            filter.InGreen = new IntRange( 50, 240 );
            filter.InBlue  = new IntRange( 10, 210 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\levels_linear.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.HSLLinear"/>
            <seealso cref="T:Accord.Imaging.Filters.YCbCrLinear"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear.InRed">
            <summary>
            Red component's input range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear.InGreen">
            <summary>
            Green component's input range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear.InBlue">
            <summary>
            Blue component's input range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear.InGray">
            <summary>
            Gray component's input range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear.Input">
            <summary>
            Input range for RGB components.
            </summary>
            
            <remarks>The property allows to set red, green and blue input ranges to the same value.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear.OutRed">
            <summary>
            Red component's output range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear.OutGreen">
            <summary>
            Green component's output range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear.OutBlue">
            <summary>
            Blue component's output range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear.OutGray">
            <summary>
            Gray component's output range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear.Output">
            <summary>
            Output range for RGB components.
            </summary>
            
            <remarks>The property allows to set red, green and blue output ranges to the same value.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.LevelsLinear.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.LevelsLinear"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.LevelsLinear.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.LevelsLinear.CalculateMap(Accord.IntRange,Accord.IntRange,System.Byte[])">
            <summary>
            Calculate conversion map.
            </summary>
            
            <param name="inRange">Input range.</param>
            <param name="outRange">Output range.</param>
            <param name="map">Conversion map.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.LevelsLinear16bpp">
            <summary>
            Linear correction of RGB channels for images, which have 16 bpp planes (16 bit gray images or 48/64 bit colour images).
            </summary>
            
            <remarks><para>The filter performs linear correction of RGB channels by mapping specified
            channels' input ranges to output ranges. This version of the filter processes only images
            with 16 bpp colour planes. See <see cref="T:Accord.Imaging.Filters.LevelsLinear"/> for 8 bpp version.</para>
            
            <para>The filter accepts 16 bpp grayscale and 48/64 bpp colour images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            LevelsLinear16bpp filter = new LevelsLinear16bpp( );
            // set ranges
            filter.InRed   = new IntRange( 3000, 42000 );
            filter.InGreen = new IntRange( 5000, 37500 );
            filter.InBlue  = new IntRange( 1000, 60000 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.LevelsLinear"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear16bpp.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear16bpp.InRed">
            <summary>
            Red component's input range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear16bpp.InGreen">
            <summary>
            Green component's input range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear16bpp.InBlue">
            <summary>
            Blue component's input range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear16bpp.InGray">
            <summary>
            Gray component's input range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear16bpp.Input">
            <summary>
            Input range for RGB components.
            </summary>
            
            <remarks>The property allows to set red, green and blue input ranges to the same value.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear16bpp.OutRed">
            <summary>
            Red component's output range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear16bpp.OutGreen">
            <summary>
            Green component's output range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear16bpp.OutBlue">
            <summary>
            Blue component's output range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear16bpp.OutGray">
            <summary>
            Gray component's output range.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LevelsLinear16bpp.Output">
            <summary>
            Output range for RGB components.
            </summary>
            
            <remarks>The property allows to set red, green and blue output ranges to the same value.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.LevelsLinear16bpp.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.LevelsLinear"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.LevelsLinear16bpp.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.LevelsLinear16bpp.CalculateMap(Accord.IntRange,Accord.IntRange,System.UInt16[])">
            <summary>
            Calculate conversion map.
            </summary>
            
            <param name="inRange">Input range.</param>
            <param name="outRange">Output range.</param>
            <param name="map">Conversion map.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ReplaceChannel">
            <summary>
            Replace RGB channel of color imgae.
            </summary>
            
            <remarks><para>Replaces specified RGB channel of color image with
            specified grayscale image.</para>
            
            <para>The filter is quite useful in conjunction with <see cref="T:Accord.Imaging.Filters.ExtractChannel"/> filter
            (however may be used alone in some cases). Using the <see cref="T:Accord.Imaging.Filters.ExtractChannel"/> filter
            it is possible to extract one of RGB channel, perform some image processing with it and then
            put it back into the original color image.</para>
            
            <para>The filter accepts 24, 32, 48 and 64 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // extract red channel
            ExtractChannel extractFilter = new ExtractChannel( RGB.R );
            Bitmap channel = extractFilter.Apply( image );
            // threshold channel
            Threshold thresholdFilter = new Threshold( 230 );
            thresholdFilter.ApplyInPlace( channel );            
            // put the channel back
            ReplaceChannel replaceFilter = new ReplaceChannel( RGB.R, channel );
            replaceFilter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\replace_channel.jpg" width="480" height="361" />
            
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.ExtractChannel"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ReplaceChannel.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ReplaceChannel.Channel">
            <summary>
            ARGB channel to replace.
            </summary>
            
            <remarks><para>Default value is set to <see cref="F:Accord.Imaging.RGB.R"/>.</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid channel is specified.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ReplaceChannel.ChannelImage">
             <summary>
             Grayscale image to use for channel replacement.
             </summary>
             
             <remarks>
             <para><note>Setting this property will clear the <see cref="P:Accord.Imaging.Filters.ReplaceChannel.UnmanagedChannelImage"/> property -
             only one channel image is allowed: managed or unmanaged.</note></para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Channel image should be 8 bpp indexed or 16 bpp grayscale image.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ReplaceChannel.UnmanagedChannelImage">
            <summary>
            Unmanaged grayscale image to use for channel replacement.
            </summary>
            
            <remarks>
            <para><note>Setting this property will clear the <see cref="P:Accord.Imaging.Filters.ReplaceChannel.ChannelImage"/> property -
            only one channel image is allowed: managed or unmanaged.</note></para>
            </remarks>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Channel image should be 8 bpp indexed or 16 bpp grayscale image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ReplaceChannel.#ctor(System.Int16)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ReplaceChannel"/> class.
            </summary>
            
            <param name="channel">ARGB channel to replace.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ReplaceChannel.#ctor(System.Int16,System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ReplaceChannel"/> class.
            </summary>
            
            <param name="channel">ARGB channel to replace.</param>
            <param name="channelImage">Channel image to use for replacement.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ReplaceChannel.#ctor(System.Int16,Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.YCbCrReplaceChannel"/> class.
            </summary>
            
            <param name="channel">RGB channel to replace.</param>
            <param name="channelImage">Unmanaged channel image to use for replacement.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ReplaceChannel.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <exception cref="T:System.NullReferenceException">Channel image was not specified.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Channel image size does not match source
             image size.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Channel image's format does not correspond to format of the source image.</exception>
            
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Can not replace alpha channel of none ARGB image. The
             exception is throw, when alpha channel is requested to be replaced in RGB image.</exception>
             
        </member>
        <member name="T:Accord.Imaging.Filters.RotateChannels">
            <summary>
            Rotate RGB channels.
            </summary>
            
            <remarks><para>The filter rotates RGB channels: red channel is replaced with green,
            green channel is replaced with blue, blue channel is replaced with red.</para>
            
            <para>The filter accepts 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            RotateChannels filter = new RotateChannels( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\rotate_channels.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.RotateChannels.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.RotateChannels.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.RotateChannels"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.RotateChannels.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Sepia">
             <summary>
             Sepia filter - old brown photo.
             </summary>
            
             <remarks><para>The filter makes an image look like an old brown photo. The main
             idea of the algorithm:
             <list type="bullet">
             <item>transform to YIQ color space;</item>
             <item>modify it;</item>
             <item>transform back to RGB.</item>
             </list></para>
             
             <para>
             <b>1) RGB -> YIQ</b>:
             <code lang="none">
            	Y = 0.299 * R + 0.587 * G + 0.114 * B
            	I = 0.596 * R - 0.274 * G - 0.322 * B
            	Q = 0.212 * R - 0.523 * G + 0.311 * B
            	</code>
            	</para>
            	
             <para>
             <b>2) update</b>:
             <code lang="none">
            	I = 51
            	Q = 0
            	</code>
            	</para>
            	
             <para>
            	<b>3) YIQ -> RGB</b>:
             <code lang="none">
            	R = 1.0 * Y + 0.956 * I + 0.621 * Q
            	G = 1.0 * Y - 0.272 * I - 0.647 * Q
            	B = 1.0 * Y - 1.105 * I + 1.702 * Q
            	</code>
            	</para>
             
             <para>The filter accepts 24/32 bpp color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Sepia filter = new Sepia( );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\sepia.jpg" width="480" height="361" />
             </remarks> 
            
        </member>
        <member name="P:Accord.Imaging.Filters.Sepia.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Sepia.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Sepia"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Sepia.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.SimplePosterization">
             <summary>
             Simple posterization of an image.
             </summary>
             
             <remarks><para>The class implements simple <a href="http://en.wikipedia.org/wiki/Posterization">posterization</a> of an image by splitting
             each color plane into adjacent areas of the <see cref="P:Accord.Imaging.Filters.SimplePosterization.PosterizationInterval">specified size</see>. After the process
             is done, each color plane will contain maximum of 256/<see cref="P:Accord.Imaging.Filters.SimplePosterization.PosterizationInterval">PosterizationInterval</see> levels.
             For example, if grayscale image is posterized with posterization interval equal to 64,
             then result image will contain maximum of 4 tones. If color image is posterized with the
             same posterization interval, then it will contain maximum of 4<sup>3</sup>=64 colors.
             See <see cref="P:Accord.Imaging.Filters.SimplePosterization.FillingType"/> property to get information about the way how to control
             color used to fill posterization areas.</para>
             
             <para>Posterization is a process in photograph development which converts normal photographs
             into an image consisting of distinct, but flat, areas of different tones or colors.</para>
            
             <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             SimplePosterization filter = new SimplePosterization( );
             // process image
             filter.ApplyInPlace( sourceImage );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\posterization.png" width="480" height="361" />
             </remarks>
             
        </member>
        <member name="T:Accord.Imaging.Filters.SimplePosterization.PosterizationFillingType">
            <summary>
            Enumeration of possible types of filling posterized areas.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.SimplePosterization.PosterizationFillingType.Min">
            <summary>
            Fill area with minimum color's value.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.SimplePosterization.PosterizationFillingType.Max">
            <summary>
            Fill area with maximum color's value.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.SimplePosterization.PosterizationFillingType.Average">
            <summary>
            Fill area with average color's value.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.SimplePosterization.PosterizationInterval">
            <summary>
            Posterization interval, which specifies size of posterization areas.
            </summary>
            
            <remarks><para>The property specifies size of adjacent posterization areas
            for each color plane. The value has direct effect on the amount of colors
            in the result image. For example, if grayscale image is posterized with posterization
            interval equal to 64, then result image will contain maximum of 4 tones. If color
            image is posterized with same posterization interval, then it will contain maximum
            of 4<sup>3</sup>=64 colors.</para>
            
            <para>Default value is set to <b>64</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SimplePosterization.FillingType">
            <summary>
            Posterization filling type.
            </summary>
            
            <remarks><para>The property controls the color, which is used to substitute
            colors within the same posterization interval - minimum, maximum or average value.
            </para>
            
            <para>Default value is set to <see cref="F:Accord.Imaging.Filters.SimplePosterization.PosterizationFillingType.Average"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SimplePosterization.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.SimplePosterization.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SimplePosterization"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.SimplePosterization.#ctor(Accord.Imaging.Filters.SimplePosterization.PosterizationFillingType)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SimplePosterization"/> class.
            </summary>
            
            <param name="fillingType">Specifies <see cref="P:Accord.Imaging.Filters.SimplePosterization.FillingType">filling type</see> of posterization areas.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SimplePosterization.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Blur">
             <summary>
             Blur filter.
             </summary>
             
             <remarks><para>The filter performs <see cref="T:Accord.Imaging.Filters.Convolution">convolution filter</see> using
             the blur kernel:</para>
             
             <code lang="none">
             1  2  3  2  1
             2  4  5  4  2
             3  5  6  5  3
             2  4  5  4  2
             1  2  3  2  1
             </code>
             
             <para>For the list of supported pixel formats, see the documentation to <see cref="T:Accord.Imaging.Filters.Convolution"/>
             filter.</para>
             
             <para><note>By default this filter sets <see cref="P:Accord.Imaging.Filters.Convolution.ProcessAlpha"/> property to
             <see langword="true"/>, so the alpha channel of 32 bpp and 64 bpp images is blurred as well.
             </note></para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Blur filter = new Blur( );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
            
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\blur.jpg" width="480" height="361" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.Convolution"/>
             
        </member>
        <member name="M:Accord.Imaging.Filters.Blur.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Blur"/> class.
            </summary>
        </member>
        <member name="T:Accord.Imaging.Filters.Convolution">
            <summary>
            Convolution filter.
            </summary>
            
            <remarks><para>The filter implements convolution operator, which calculates each pixel
            of the result image as weighted sum of the correspond pixel and its neighbors in the source
            image. The weights are set by <see cref="P:Accord.Imaging.Filters.Convolution.Kernel">convolution kernel</see>. The weighted
            sum is divided by <see cref="P:Accord.Imaging.Filters.Convolution.Divisor"/> before putting it into result image and also
            may be thresholded using <see cref="P:Accord.Imaging.Filters.Convolution.Threshold"/> value.</para>
            
            <para>Convolution is a simple mathematical operation which is fundamental to many common
            image processing filters. Depending on the type of provided kernel, the filter may produce
            different results, like blur image, sharpen it, find edges, etc.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing. Note: depending on the value of <see cref="P:Accord.Imaging.Filters.Convolution.ProcessAlpha"/>
            property, the alpha channel is either copied as is or processed with the kernel.</para>
            
            <para>Sample usage:</para>
            <code>
            // define emboss kernel
            int[,] kernel = {
                        { -2, -1,  0 },
                        { -1,  1,  1 },
                        {  0,  1,  2 } };
            // create filter
            Convolution filter = new Convolution( kernel );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample5.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\emboss.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Convolution.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.Convolution.Kernel">
            <summary>
            Convolution kernel.
            </summary>
            
            <remarks>
            <para><note>Convolution kernel must be square and its width/height
            should be odd and should be in the [3, 99] range.</note></para>
            
            <para><note>Setting convolution kernel through this property does not
            affect <see cref="P:Accord.Imaging.Filters.Convolution.Divisor"/> - it is not recalculated automatically.</note></para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">Invalid kernel size is specified.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Convolution.Divisor">
            <summary>
            Division factor.
            </summary>
            
            <remarks><para>The value is used to divide convolution - weighted sum
            of pixels is divided by this value.</para>
            
            <para><note>The value may be calculated automatically in the case if constructor
            with one parameter is used (<see cref="M:Accord.Imaging.Filters.Convolution.#ctor(System.Int32[0:,0:])"/>).</note></para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">Divisor can not be equal to zero.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Convolution.Threshold">
            <summary>
            Threshold to add to weighted sum.
            </summary>
            
            <remarks><para>The property specifies threshold value, which is added to each weighted
            sum of pixels. The value is added right after division was done by <see cref="P:Accord.Imaging.Filters.Convolution.Divisor"/>
            value.</para>
            
            <para>Default value is set to <b>0</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Convolution.DynamicDivisorForEdges">
            <summary>
            Use dynamic divisor for edges or not.
            </summary>
            
            <remarks><para>The property specifies how to handle edges. If it is set to
            <see langword="false"/>, then the same divisor (which is specified by <see cref="P:Accord.Imaging.Filters.Convolution.Divisor"/>
            property or calculated automatically) will be applied both for non-edge regions
            and for edge regions. If the value is set to <see langword="true"/>, then dynamically
            calculated divisor will be used for edge regions, which is sum of those kernel
            elements, which are taken into account for particular processed pixel
            (elements, which are not outside image).</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Convolution.ProcessAlpha">
            <summary>
            Specifies if alpha channel must be processed or just copied.
            </summary>
            
            <remarks><para>The property specifies the way how alpha channel is handled for 32 bpp
            and 64 bpp images. If the property is set to <see langword="false"/>, then alpha
            channel's values are just copied as is. If the property is set to <see langword="true"/>
            then alpha channel is convolved using the specified kernel same way as RGB channels.</para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Convolution.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Convolution"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Convolution.#ctor(System.Int32[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Convolution"/> class.
            </summary>
            
            <param name="kernel">Convolution kernel.</param>
            
            <remarks><para>Using this constructor (specifying only convolution kernel),
            <see cref="P:Accord.Imaging.Filters.Convolution.Divisor">division factor</see> will be calculated automatically
            summing all kernel values. In the case if kernel's sum equals to zero,
            division factor will be assigned to 1.</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid kernel size is specified. Kernel must be
            square, its width/height should be odd and should be in the [3, 25] range.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Convolution.#ctor(System.Int32[0:,0:],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Convolution"/> class.
            </summary>
            
            <param name="kernel">Convolution kernel.</param>
            <param name="divisor">Divisor, used used to divide weighted sum.</param>
            
            <exception cref="T:System.ArgumentException">Invalid kernel size is specified. Kernel must be
            square, its width/height should be odd and should be in the [3, 25] range.</exception>
            <exception cref="T:System.ArgumentException">Divisor can not be equal to zero.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Convolution.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Edges">
             <summary>
             Simple edge detector.
             </summary>
             
             <remarks><para>The filter performs <see cref="T:Accord.Imaging.Filters.Convolution">convolution filter</see> using
             the edges kernel:</para>
             
             <code lang="none">
              0  -1   0
             -1   4  -1
              0  -1   0
             </code>
             
             <para>For the list of supported pixel formats, see the documentation to <see cref="T:Accord.Imaging.Filters.Convolution"/>
             filter.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Edges filter = new Edges( );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
            
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\edges.png" width="480" height="361" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.Convolution"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Edges.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Edges"/> class.
            </summary>
        </member>
        <member name="T:Accord.Imaging.Filters.GaussianBlur">
             <summary>
             Gaussian blur filter.
             </summary>
             
             <remarks><para>The filter performs <see cref="T:Accord.Imaging.Filters.Convolution">convolution filter</see> using
             the kernel, which is calculate with the help of <see cref="M:AForge.Math.Gaussian.Kernel2D(System.Int32)"/>
             method and then converted to integer kernel by dividing all elements by the element with the
             smallest value. Using the kernel the convolution filter is known as Gaussian blur.</para>
             
             <para>Using <see cref="P:Accord.Imaging.Filters.GaussianBlur.Sigma"/> property it is possible to configure
             <see cref="P:AForge.Math.Gaussian.Sigma">sigma value of Gaussian function</see>.</para>
             
             <para>For the list of supported pixel formats, see the documentation to <see cref="T:Accord.Imaging.Filters.Convolution"/>
             filter.</para>
             
             <para><note>By default this filter sets <see cref="P:Accord.Imaging.Filters.Convolution.ProcessAlpha"/> property to
             <see langword="true"/>, so the alpha channel of 32 bpp and 64 bpp images is blurred as well.
             </note></para>
             
             <para>Sample usage:</para>
             <code>
             // create filter with kernel size equal to 11
             // and Gaussia sigma value equal to 4.0
             GaussianBlur filter = new GaussianBlur( 4, 11 );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
            
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\gaussian_blur.jpg" width="480" height="361" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.Convolution"/>
             
        </member>
        <member name="P:Accord.Imaging.Filters.GaussianBlur.Sigma">
            <summary>
            Gaussian sigma value, [0.5, 5.0].
            </summary>
            
            <remarks><para>Sigma value for Gaussian function used to calculate
            the kernel.</para>
            
            <para>Default value is set to <b>1.4</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.GaussianBlur.Size">
            <summary>
            Kernel size, [3, 21].
            </summary>
            
            <remarks><para>Size of Gaussian kernel.</para>
            
            <para>Default value is set to <b>5</b>.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GaussianBlur.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GaussianBlur"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GaussianBlur.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GaussianBlur"/> class.
            </summary>
            
            <param name="sigma">Gaussian sigma value.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GaussianBlur.#ctor(System.Double,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GaussianBlur"/> class.
            </summary>
            
            <param name="sigma">Gaussian sigma value.</param>
            <param name="size">Kernel size.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Mean">
            <summary>
            Mean filter.
            </summary>
            
            <remarks><para>The filter performs each pixel value's averaging with its 8 neighbors, which is 
            <see cref="T:Accord.Imaging.Filters.Convolution">convolution filter</see> using the mean kernel:</para>
            
            <code lang="none">
            1  1  1
            1  1  1
            1  1  1
            </code>
            
            <para>For the list of supported pixel formats, see the documentation to <see cref="T:Accord.Imaging.Filters.Convolution"/>
            filter.</para>
            
            <para>With the above kernel the convolution filter is just calculates each pixel's value
            in result image as average of 9 corresponding pixels in the source image.</para>
            
            <para><note>By default this filter sets <see cref="P:Accord.Imaging.Filters.Convolution.ProcessAlpha"/> property to
            <see langword="true"/>, so the alpha channel of 32 bpp and 64 bpp images is blurred as well.
            </note></para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Mean filter = new Mean( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample13.png" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\mean.png" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.Convolution"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Mean.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Mean"/> class.
            </summary>
        </member>
        <member name="T:Accord.Imaging.Filters.Sharpen">
            <summary>
            Sharpen filter
            </summary>
            
            <remarks><para>The filter performs <see cref="T:Accord.Imaging.Filters.Convolution">convolution filter</see> using
            the sharpen kernel:</para>
            
            <code lang="none">
             0  -1   0
            -1   5  -1
             0  -1   0
            </code>
            
            <para>For the list of supported pixel formats, see the documentation to <see cref="T:Accord.Imaging.Filters.Convolution"/>
            filter.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Sharpen filter = new Sharpen( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\sharpen.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.Convolution"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Sharpen.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Sharpen"/> class.
            </summary>
        </member>
        <member name="T:Accord.Imaging.Filters.GaussianSharpen">
             <summary>
             Gaussian sharpen filter.
             </summary>
             
             <remarks><para>The filter performs <see cref="T:Accord.Imaging.Filters.Convolution">convolution filter</see> using
             the kernel, which is calculate with the help of <see cref="M:AForge.Math.Gaussian.Kernel2D(System.Int32)"/>
             method and then converted to integer sharpening kernel. First of all the integer kernel
             is calculated from <see cref="M:AForge.Math.Gaussian.Kernel2D(System.Int32)"/> by dividing all elements by
             the element with the smallest value. Then the integer kernel is converted to sharpen kernel by
             negating all kernel's elements (multiplying with <b>-1</b>), but the central kernel's element
             is calculated as <b>2 * sum - centralElement</b>, where <b>sum</b> is the sum off elements
             in the integer kernel before negating.</para>
             
             <para>For the list of supported pixel formats, see the documentation to <see cref="T:Accord.Imaging.Filters.Convolution"/>
             filter.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter with kernel size equal to 11
             // and Gaussia sigma value equal to 4.0
             GaussianSharpen filter = new GaussianSharpen( 4, 11 );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
            
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\gaussian_sharpen.jpg" width="480" height="361" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.Convolution"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.GaussianSharpen.Sigma">
            <summary>
            Gaussian sigma value, [0.5, 5.0].
            </summary>
            
            <remarks><para>Sigma value for Gaussian function used to calculate
            the kernel.</para>
            
            <para>Default value is set to <b>1.4</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.GaussianSharpen.Size">
             <summary>
             Kernel size, [3, 5].
             </summary>
             
             <remarks><para>Size of Gaussian kernel.</para>
             
             <para>Default value is set to <b>5</b>.</para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GaussianSharpen.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GaussianSharpen"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GaussianSharpen.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GaussianSharpen"/> class.
            </summary>
            
            <param name="sigma">Gaussian sigma value.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GaussianSharpen.#ctor(System.Double,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GaussianSharpen"/> class.
            </summary>
            
            <param name="sigma">Gaussian sigma value.</param>
            <param name="size">Kernel size.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.CannyEdgeDetector">
            <summary>
            Canny edge detector.
            </summary>
            
            <remarks><para>The filter searches for objects' edges by applying Canny edge detector.
            The implementation follows
            <a href="http://www.pages.drexel.edu/~weg22/can_tut.html">Bill Green's Canny edge detection tutorial</a>.</para>
            
            <para><note>The implemented canny edge detector has one difference with the above linked algorithm.
            The difference is in hysteresis step, which is a bit simplified (getting faster as a result). On the
            hysteresis step each pixel is compared with two threshold values: <see cref="P:Accord.Imaging.Filters.CannyEdgeDetector.HighThreshold"/> and
            <see cref="P:Accord.Imaging.Filters.CannyEdgeDetector.LowThreshold"/>. If pixel's value is greater or equal to <see cref="P:Accord.Imaging.Filters.CannyEdgeDetector.HighThreshold"/>, then
            it is kept as edge pixel. If pixel's value is greater or equal to <see cref="P:Accord.Imaging.Filters.CannyEdgeDetector.LowThreshold"/>, then
            it is kept as edge pixel only if there is at least one neighbouring pixel (8 neighbours are checked) which
            has value greater or equal to <see cref="P:Accord.Imaging.Filters.CannyEdgeDetector.HighThreshold"/>; otherwise it is none edge pixel. In the case
            if pixel's value is less than <see cref="P:Accord.Imaging.Filters.CannyEdgeDetector.LowThreshold"/>, then it is marked as none edge immediately.
            </note></para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            CannyEdgeDetector filter = new CannyEdgeDetector( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample2.jpg" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\canny_edges.png" width="320" height="240" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CannyEdgeDetector.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.CannyEdgeDetector.LowThreshold">
            <summary>
            Low threshold.
            </summary>
            
            <remarks><para>Low threshold value used for hysteresis
            (see  <a href="http://www.pages.drexel.edu/~weg22/can_tut.html">tutorial</a>
            for more information).</para>
            
            <para>Default value is set to <b>20</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CannyEdgeDetector.HighThreshold">
            <summary>
            High threshold.
            </summary>
            
            <remarks><para>High threshold value used for hysteresis
            (see  <a href="http://www.pages.drexel.edu/~weg22/can_tut.html">tutorial</a>
            for more information).</para>
            
            <para>Default value is set to <b>100</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CannyEdgeDetector.GaussianSigma">
            <summary>
            Gaussian sigma.
            </summary>
            
            <remarks>Sigma value for <see cref="P:Accord.Imaging.Filters.GaussianBlur.Sigma">Gaussian bluring</see>.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CannyEdgeDetector.GaussianSize">
            <summary>
            Gaussian size.
            </summary>
            
            <remarks>Size of <see cref="P:Accord.Imaging.Filters.GaussianBlur.Size">Gaussian kernel</see>.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CannyEdgeDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CannyEdgeDetector"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CannyEdgeDetector.#ctor(System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CannyEdgeDetector"/> class.
            </summary>
            
            <param name="lowThreshold">Low threshold.</param>
            <param name="highThreshold">High threshold.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CannyEdgeDetector.#ctor(System.Byte,System.Byte,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CannyEdgeDetector"/> class.
            </summary>
            
            <param name="lowThreshold">Low threshold.</param>
            <param name="highThreshold">High threshold.</param>
            <param name="sigma">Gaussian sigma.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CannyEdgeDetector.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.DifferenceEdgeDetector">
            <summary>
            Difference edge detector.
            </summary>
            
            <remarks><para>The filter finds objects' edges by calculating maximum difference
            between pixels in 4 directions around the processing pixel.</para>
            
            <para>Suppose 3x3 square element of the source image (x - is currently processed
            pixel):
            <code lang="none">
            P1 P2 P3
            P8  x P4
            P7 P6 P5
            </code>
            The corresponding pixel of the result image equals to:
            <code lang="none">
            max( |P1-P5|, |P2-P6|, |P3-P7|, |P4-P8| )
            </code>
            </para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            DifferenceEdgeDetector filter = new DifferenceEdgeDetector( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample2.jpg" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\difference_edges.png" width="320" height="240" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.HomogenityEdgeDetector"/>
            <seealso cref="T:Accord.Imaging.Filters.SobelEdgeDetector"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.DifferenceEdgeDetector.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.DifferenceEdgeDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.DifferenceEdgeDetector"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.DifferenceEdgeDetector.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.HomogenityEdgeDetector">
            <summary>
            Homogenity edge detector.
            </summary>
            
            <remarks><para>The filter finds objects' edges by calculating maximum difference
            of processing pixel with neighboring pixels in 8 direction.</para>
            
            <para>Suppose 3x3 square element of the source image (x - is currently processed
            pixel):
            <code lang="none">
            P1 P2 P3
            P8  x P4
            P7 P6 P5
            </code>
            The corresponding pixel of the result image equals to:
            <code lang="none">
            max( |x-P1|, |x-P2|, |x-P3|, |x-P4|,
                 |x-P5|, |x-P6|, |x-P7|, |x-P8| )
            </code>
            </para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            HomogenityEdgeDetector filter = new HomogenityEdgeDetector( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample2.jpg" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\homogenity_edges.png" width="320" height="240" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.DifferenceEdgeDetector"/>
            <seealso cref="T:Accord.Imaging.Filters.SobelEdgeDetector"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HomogenityEdgeDetector.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.HomogenityEdgeDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HomogenityEdgeDetector"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HomogenityEdgeDetector.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.SobelEdgeDetector">
            <summary>
            Sobel edge detector.
            </summary>
            
            <remarks><para>The filter searches for objects' edges by applying Sobel operator.</para>
            
            <para>Each pixel of the result image is calculated as approximated absolute gradient
            magnitude for corresponding pixel of the source image:
            <code lang="none">
            |G| = |Gx| + |Gy] ,
            </code>
            where Gx and Gy are calculate utilizing Sobel convolution kernels:
            <code lang="none">
               Gx         Gy
            -1 0 +1    +1 +2 +1
            -2 0 +2     0  0  0
            -1 0 +1    -1 -2 -1
            </code>
            Using the above kernel the approximated magnitude for pixel <b>x</b> is calculate using
            the next equation:
            <code lang="none">
            P1 P2 P3
            P8  x P4
            P7 P6 P5
            
            |G| = |P1 + 2P2 + P3 - P7 - 2P6 - P5| +
                  |P3 + 2P4 + P5 - P1 - 2P8 - P7|
            </code>
            </para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            SobelEdgeDetector filter = new SobelEdgeDetector( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample2.jpg" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\sobel_edges.png" width="320" height="240" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.DifferenceEdgeDetector"/>
            <seealso cref="T:Accord.Imaging.Filters.HomogenityEdgeDetector"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SobelEdgeDetector.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.SobelEdgeDetector.ScaleIntensity">
            <summary>
            Scale intensity or not.
            </summary>
            
            <remarks><para>The property determines if edges' pixels intensities of the result image
            should be scaled in the range of the lowest and the highest possible intensity
            values.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SobelEdgeDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SobelEdgeDetector"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SobelEdgeDetector.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.FilterIterator">
            <summary>
            Filter iterator.
            </summary>
            
            <remarks><para>Filter iterator performs specified amount of filter's iterations.
            The filter take the specified <see cref="P:Accord.Imaging.Filters.FilterIterator.BaseFilter">base filter</see> and applies it
            to source image <see cref="P:Accord.Imaging.Filters.FilterIterator.Iterations">specified amount of times</see>.</para>
            
            <para><note>The filter itself does not have any restrictions to pixel format of source
            image. This is set by <see cref="P:Accord.Imaging.Filters.FilterIterator.BaseFilter">base filter</see>.</note></para>
            
            <para><note>The filter does image processing using only <see cref="T:Accord.Imaging.Filters.IFilter"/>
            interface of the specified <see cref="P:Accord.Imaging.Filters.FilterIterator.BaseFilter">base filter</see>. This means
            that this filter may not utilize all potential features of the base filter, like
            in-place processing (see <see cref="T:Accord.Imaging.Filters.IInPlaceFilter"/>) and region based processing
            (see <see cref="T:Accord.Imaging.Filters.IInPlacePartialFilter"/>). To utilize those features, it is required to
            do filter's iteration manually.</note></para>
            
            <para>Sample usage (morphological thinning):</para>
            <code>
            // create filter sequence
            FiltersSequence filterSequence = new FiltersSequence( );
            // add 8 thinning filters with different structuring elements
            filterSequence.Add( new HitAndMiss(
                new short [,] { { 0, 0, 0 }, { -1, 1, -1 }, { 1, 1, 1 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { -1, 0, 0 }, { 1, 1, 0 }, { -1, 1, -1 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { 1, -1, 0 }, { 1, 1, 0 }, { 1, -1, 0 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { -1, 1, -1 }, { 1, 1, 0 }, { -1, 0, 0 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { 1, 1, 1 }, { -1, 1, -1 }, { 0, 0, 0 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { -1, 1, -1 }, { 0, 1, 1 }, { 0, 0, -1 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { 0, -1, 1 }, { 0, 1, 1 }, { 0, -1, 1 } },
                HitAndMiss.Modes.Thinning ) );
            filterSequence.Add( new HitAndMiss(
                new short [,] { { 0, 0, -1 }, { 0, 1, 1 }, { -1, 1, -1 } },
                HitAndMiss.Modes.Thinning ) );
            // create filter iterator for 10 iterations
            FilterIterator filter = new FilterIterator( filterSequence, 10 );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample14.png" width="150" height="150" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\thinning.png" width="150" height="150" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FilterIterator.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para>
            
            <para><note>The filter provides format translation dictionary taken from
            <see cref="P:Accord.Imaging.Filters.FilterIterator.BaseFilter"/> filter.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FilterIterator.BaseFilter">
            <summary>
            Base filter.
            </summary>
            
            <remarks><para>The base filter is the filter to be applied specified amount of iterations to
            a specified image.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FilterIterator.Iterations">
            <summary>
            Iterations amount, [1, 255].
            </summary>
            
            <remarks><para>The amount of times to apply specified filter to a specified image.</para>
            
            <para>Default value is set to <b>1</b>.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FilterIterator.#ctor(Accord.Imaging.Filters.IFilter)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FilterIterator"/> class.
            </summary>
            
            <param name="baseFilter">Filter to iterate.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FilterIterator.#ctor(Accord.Imaging.Filters.IFilter,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FilterIterator"/> class.
            </summary>
            
            <param name="baseFilter">Filter to iterate.</param>
            <param name="iterations">Iterations amount.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FilterIterator.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks> 
            
        </member>
        <member name="M:Accord.Imaging.Filters.FilterIterator.Apply(System.Drawing.Imaging.BitmapData)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="imageData">Source image to apply filter to.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
            <remarks>The filter accepts bitmap data as input and returns the result
            of image processing filter as new image. The source image data are kept
            unchanged.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FilterIterator.Apply(Accord.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image in unmanaged memory.
            </summary>
            
            <param name="image">Source image in unmanaged memory to apply filter to.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
            <remarks>The method keeps the source image unchanged and returns
            the result of image processing filter as new image.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FilterIterator.Apply(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image in unmanaged memory.
            </summary>
            
            <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
            <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
            
            <remarks><para>The method keeps the source image unchanged and puts result of image processing
            into destination image.</para>
            
            <para><note>The destination image must have the same width and height as source image. Also
            destination image must have pixel format, which is expected by particular filter (see
            <see cref="P:Accord.Imaging.Filters.FilterIterator.FormatTranslations"/> property for information about pixel format conversions).</note></para>
            </remarks>
            
        </member>
        <member name="T:Accord.Imaging.Filters.FiltersSequence">
            <summary>
            Filters' collection to apply to an image in sequence.
            </summary>
            
            <remarks><para>The class represents collection of filters, which need to be applied
            to an image in sequence. Using the class user may specify set of filters, which will
            be applied to source image one by one in the order user defines them.</para>
            
            <para>The class itself does not define which pixel formats are accepted for the source
            image and which pixel formats may be produced by the filter. Format of acceptable source
            and possible output is defined by filters, which added to the sequence.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter, which is binarization sequence
            FiltersSequence filter = new FiltersSequence(
                new GrayscaleBT709( ),
                new Threshold( )
            );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FiltersSequence.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FiltersSequence"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FiltersSequence.#ctor(Accord.Imaging.Filters.IFilter[])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FiltersSequence"/> class.
            </summary>
            
            <param name="filters">Sequence of filters to apply.</param>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FiltersSequence.Item(System.Int32)">
            <summary>
            Get filter at the specified index.
            </summary>
            
            <param name="index">Index of filter to get.</param>
            
            <returns>Returns filter at specified index.</returns>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FiltersSequence.Add(Accord.Imaging.Filters.IFilter)">
            <summary>
            Add new filter to the sequence.
            </summary>
            
            <param name="filter">Filter to add to the sequence.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FiltersSequence.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:System.ApplicationException">No filters were added into the filters' sequence.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FiltersSequence.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The filter accepts bitmap data as input and returns the result
             of image processing filter as new image. The source image data are kept
             unchanged.</remarks>
            
             <exception cref="T:System.ApplicationException">No filters were added into the filters' sequence.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FiltersSequence.Apply(Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:System.ApplicationException">No filters were added into the filters' sequence.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FiltersSequence.Apply(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have width, height and pixel format as it is expected by
             the final filter in the sequence.</note></para>
             </remarks>
             
             <exception cref="T:System.ApplicationException">No filters were added into the filters' sequence.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.PointedColorFloodFill">
            <summary>
            Flood filling with specified color starting from specified point.
            </summary>
            
            <remarks><para>The filter performs image's area filling (4 directional) starting
            from the <see cref="P:Accord.Imaging.Filters.PointedColorFloodFill.StartingPoint">specified point</see>. It fills
            the area of the pointed color, but also fills other colors, which
            are similar to the pointed within specified <see cref="P:Accord.Imaging.Filters.PointedColorFloodFill.Tolerance">tolerance</see>.
            The area is filled using <see cref="P:Accord.Imaging.Filters.PointedColorFloodFill.FillColor">specified fill color</see>.
            </para>
            
            <para>The filter accepts 8 bpp grayscale images and 24 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            PointedColorFloodFill filter = new PointedColorFloodFill( );
            // configure the filter
            filter.Tolerance = Color.FromArgb( 150, 92, 92 );
            filter.FillColor = Color.FromArgb( 255, 255, 255 );
            filter.StartingPoint = new IntPoint( 150, 100 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\pointed_color_fill.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.PointedMeanFloodFill"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.PointedColorFloodFill.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.PointedColorFloodFill.Tolerance">
            <summary>
            Flood fill tolerance.
            </summary>
            
            <remarks><para>The tolerance value determines which colors to fill. If the
            value is set to 0, then only color of the <see cref="P:Accord.Imaging.Filters.PointedColorFloodFill.StartingPoint">pointed pixel</see>
            is filled. If the value is not 0, then other colors may be filled as well,
            which are similar to the color of the pointed pixel within the specified
            tolerance.</para>
            
            <para>The tolerance value is specified as <see cref="T:System.Drawing.Color"/>,
            where each component (R, G and B) represents tolerance for the corresponding
            component of color. This allows to set different tolerances for red, green
            and blue components.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.PointedColorFloodFill.FillColor">
            <summary>
            Fill color.
            </summary>
            
            <remarks><para>The fill color is used to fill image's area starting from the
            <see cref="P:Accord.Imaging.Filters.PointedColorFloodFill.StartingPoint">specified point</see>.</para>
            
            <para>For grayscale images the color needs to be specified with all three
            RGB values set to the same value, (128, 128, 128) for example.</para>
            
            <para>Default value is set to <b>black</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.PointedColorFloodFill.StartingPoint">
            <summary>
            Point to start filling from.
            </summary>
            
            <remarks><para>The property allows to set the starting point, where filling is
            started from.</para>
            
            <remarks>Default value is set to <b>(0, 0)</b>.</remarks>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointedColorFloodFill.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.PointedColorFloodFill"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointedColorFloodFill.#ctor(System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.PointedColorFloodFill"/> class.
            </summary>
            
            <param name="fillColor">Fill color.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointedColorFloodFill.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.PointedMeanFloodFill">
            <summary>
            Flood filling with mean color starting from specified point.
            </summary>
            
            <remarks><para>The filter performs image's area filling (4 directional) starting
            from the <see cref="P:Accord.Imaging.Filters.PointedMeanFloodFill.StartingPoint">specified point</see>. It fills
            the area of the pointed color, but also fills other colors, which
            are similar to the pointed within specified <see cref="P:Accord.Imaging.Filters.PointedMeanFloodFill.Tolerance">tolerance</see>.
            The area is filled using its mean color.
            </para>
            
            <para>The filter is similar to <see cref="T:Accord.Imaging.Filters.PointedColorFloodFill"/> filter, but instead
            of filling the are with specified color, it fills the area with its mean color. This means
            that this is a two pass filter - first pass is to calculate the mean value and the second pass is to
            fill the area. Unlike to <see cref="T:Accord.Imaging.Filters.PointedColorFloodFill"/> filter, this filter has nothing
            to do in the case if zero <see cref="P:Accord.Imaging.Filters.PointedMeanFloodFill.Tolerance">tolerance</see> is specified.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            PointedMeanFloodFill filter = new PointedMeanFloodFill( );
            // configre the filter
            filter.Tolerance = Color.FromArgb( 150, 92, 92 );
            filter.StartingPoint = new IntPoint( 150, 100 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\pointed_mean_fill.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.PointedColorFloodFill"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.PointedMeanFloodFill.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.PointedMeanFloodFill.Tolerance">
            <summary>
            Flood fill tolerance.
            </summary>
            
            <remarks><para>The tolerance value determines the level of similarity between
            colors to fill and the pointed color. If the value is set to zero, then the
            filter does nothing, since the filling area contains only one color and its
            filling with mean is meaningless.</para>
            
            <para>The tolerance value is specified as <see cref="T:System.Drawing.Color"/>,
            where each component (R, G and B) represents tolerance for the corresponding
            component of color. This allows to set different tolerances for red, green
            and blue components.</para>
            
            <para>Default value is set to <b>(16, 16, 16)</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.PointedMeanFloodFill.StartingPoint">
            <summary>
            Point to start filling from.
            </summary>
            
            <remarks><para>The property allows to set the starting point, where filling is
            started from.</para>
            
            <remarks>Default value is set to <b>(0, 0)</b>.</remarks>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointedMeanFloodFill.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.PointedMeanFloodFill"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointedMeanFloodFill.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.HSLFiltering">
            <summary>
            Color filtering in HSL color space.
            </summary>
            
            <remarks><para>The filter operates in <b>HSL</b> color space and filters
            pixels, which color is inside/outside of the specified HSL range -
            it keeps pixels with colors inside/outside of the specified range and fills the
            rest with <see cref="P:Accord.Imaging.Filters.HSLFiltering.FillColor">specified color</see>.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            HSLFiltering filter = new HSLFiltering( );
            // set color ranges to keep
            filter.Hue = new IntRange( 335, 0 );
            filter.Saturation = new Range( 0.6f, 1 );
            filter.Luminance = new Range( 0.1f, 1 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\hsl_filtering.jpg" width="480" height="361" />
            
            <para>Sample usage with saturation update only:</para>
            <code>
            // create filter
            HSLFiltering filter = new HSLFiltering( );
            // configure the filter
            filter.Hue = new IntRange( 340, 20 );
            filter.UpdateLuminance = false;
            filter.UpdateHue = false;
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\hsl_filtering2.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.ColorFiltering"/>
            <seealso cref="T:Accord.Imaging.Filters.YCbCrFiltering"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HSLFiltering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.HSLFiltering.Hue">
            <summary>
            Range of hue component, [0, 359].
            </summary>
            
            <remarks><note>Because of hue values are cycled, the minimum value of the hue
            range may have bigger integer value than the maximum value, for example [330, 30].</note></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HSLFiltering.Saturation">
            <summary>
            Range of saturation component, [0, 1].
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.HSLFiltering.Luminance">
            <summary>
            Range of luminance component, [0, 1].
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.HSLFiltering.FillColor">
            <summary>
            Fill color used to fill filtered pixels.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.HSLFiltering.FillOutsideRange">
            <summary>
            Determines, if pixels should be filled inside or outside specified
            color range.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/>, which means
            the filter removes colors outside of the specified range.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HSLFiltering.UpdateHue">
            <summary>
            Determines, if hue value of filtered pixels should be updated.
            </summary>
            
            <remarks><para>The property specifies if hue of filtered pixels should be
            updated with value from <see cref="P:Accord.Imaging.Filters.HSLFiltering.FillColor">fill color</see> or not.</para>
            
            <para>Default value is set to <see langword="true"/>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HSLFiltering.UpdateSaturation">
            <summary>
            Determines, if saturation value of filtered pixels should be updated.
            </summary>
            
            <remarks><para>The property specifies if saturation of filtered pixels should be
            updated with value from <see cref="P:Accord.Imaging.Filters.HSLFiltering.FillColor">fill color</see> or not.</para>
            
            <para>Default value is set to <see langword="true"/>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HSLFiltering.UpdateLuminance">
            <summary>
            Determines, if luminance value of filtered pixels should be updated.
            </summary>
            
            <remarks><para>The property specifies if luminance of filtered pixels should be
            updated with value from <see cref="P:Accord.Imaging.Filters.HSLFiltering.FillColor">fill color</see> or not.</para>
            
            <para>Default value is set to <see langword="true"/>.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HSLFiltering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HSLFiltering"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.HSLFiltering.#ctor(Accord.IntRange,Accord.Range,Accord.Range)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HSLFiltering"/> class.
            </summary>
            
            <param name="hue">Range of hue component.</param>
            <param name="saturation">Range of saturation component.</param>
            <param name="luminance">Range of luminance component.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HSLFiltering.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.HSLLinear">
            <summary>
            Luminance and saturation linear correction.
            </summary>
            
            <remarks><para>The filter operates in <b>HSL</b> color space and provides
            with the facility of luminance and saturation linear correction - mapping specified channels'
            input ranges to specified output ranges.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            HSLLinear filter = new HSLLinear( );
            // configure the filter
            filter.InLuminance   = new Range( 0, 0.85f );
            filter.OutSaturation = new Range( 0.25f, 1 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\hsl_linear.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.LevelsLinear"/>
            <seealso cref="T:Accord.Imaging.Filters.YCbCrLinear"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HSLLinear.InLuminance">
            <summary>
            Luminance input range.
            </summary>
            
            <remarks>Luminance component is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HSLLinear.OutLuminance">
            <summary>
            Luminance output range.
            </summary>
            
            <remarks>Luminance component is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HSLLinear.InSaturation">
            <summary>
            Saturation input range.
            </summary>
            
            <remarks>Saturation component is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HSLLinear.OutSaturation">
            <summary>
            Saturation output range.
            </summary>
            
            <remarks>Saturation component is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HSLLinear.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.HSLLinear.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HSLLinear"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HSLLinear.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.HueModifier">
             <summary>
             Hue modifier.
             </summary>
             
             <remarks><para>The filter operates in <b>HSL</b> color space and updates
             pixels' hue values setting it to the specified value (luminance and
             saturation are kept unchanged). The result of the filter looks like the image
             is observed through a glass of the given color.</para>
            
             <para>The filter accepts 24 and 32 bpp color images for processing.</para>
             <para>Sample usage:</para>
             <code>
             // create filter
             HueModifier filter = new HueModifier( 180 );
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\hue_modifier.jpg" width="480" height="361" />
             </remarks>
             
        </member>
        <member name="P:Accord.Imaging.Filters.HueModifier.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.HueModifier.Hue">
            <summary>
            Hue value to set, [0, 359].
            </summary>
            
            <remarks><para>Default value is set to <b>0</b>.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HueModifier.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HueModifier"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HueModifier.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HueModifier"/> class.
            </summary>
            
            <param name="hue">Hue value to set.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HueModifier.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.SaturationCorrection">
            <summary>
            Saturation adjusting in HSL color space.
            </summary>
            
            <remarks><para>The filter operates in <b>HSL</b> color space and adjusts
            pixels' saturation value, increasing it or decreasing by specified percentage.
            The filters is based on <see cref="T:Accord.Imaging.Filters.HSLLinear"/> filter, passing work to it after
            recalculating saturation <see cref="P:Accord.Imaging.Filters.SaturationCorrection.AdjustValue">adjust value</see> to input/output
            ranges of the <see cref="T:Accord.Imaging.Filters.HSLLinear"/> filter.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            SaturationCorrection filter = new SaturationCorrection( -0.5f );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\saturation_correction.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SaturationCorrection.AdjustValue">
            <summary>
            Saturation adjust value, [-1, 1].
            </summary>
            
            <remarks>Default value is set to <b>0.1</b>, which corresponds to increasing
            saturation by 10%.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SaturationCorrection.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.SaturationCorrection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SaturationCorrection"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SaturationCorrection.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SaturationCorrection"/> class.
            </summary>
            
            <param name="adjustValue">Saturation adjust value.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SaturationCorrection.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.IFilter">
            <summary>
            Image processing filter interface.
            </summary>
            
            <remarks>The interface defines the set of methods, which should be
            provided by all image processing filters. Methods of this interface
            keep the source image unchanged and returt the result of image processing
            filter as new image.</remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.IInPlaceFilter"/>
            <seealso cref="T:Accord.Imaging.Filters.IInPlacePartialFilter"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IFilter.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks> 
            
        </member>
        <member name="M:Accord.Imaging.Filters.IFilter.Apply(System.Drawing.Imaging.BitmapData)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="imageData">Source image to apply filter to.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
            <remarks>The filter accepts bitmap data as input and returns the result
            of image processing filter as new image. The source image data are kept
            unchanged.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IFilter.Apply(Accord.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image in unmanaged memory.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
            <remarks>The method keeps the source image unchanged and returns
            the result of image processing filter as new image.</remarks> 
            
        </member>
        <member name="M:Accord.Imaging.Filters.IFilter.Apply(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="sourceImage">Source image to be processed.</param>
            <param name="destinationImage">Destination image to store filter's result.</param>
            
            <remarks><para>The method keeps the source image unchanged and puts the
            the result of image processing filter into destination image.</para>
            
            <para><note>The destination image must have the size, which is expected by
            the filter.</note></para>
            </remarks>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">In the case if destination image has incorrect
            size.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.IFilterInformation">
            <summary>
            Interface which provides information about image processing filter.
            </summary>
            
            <remarks><para>The interface defines set of properties, which provide different type
            of information about image processing filters implementing <see cref="T:Accord.Imaging.Filters.IFilter"/> interface
            or another filter's interface.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>The dictionary defines, which pixel formats are supported for
            source images and which pixel format will be used for resulting image.
            </para>
            
            <para>Keys of this dictionary defines all pixel formats which are supported for source
            images, but corresponding values define what will be resulting pixel format. For
            example, if value <see cref="T:System.Drawing.Imaging.PixelFormat">Format16bppGrayScale</see>
            is put into the dictionary with the
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format48bppRgb</see> key, then it means
            that the filter accepts color 48 bpp image and produces 16 bpp grayscale image as a result
            of image processing.</para>
            
            <para>The information provided by this property is mostly actual for filters, which can not
            be applied directly to the source image, but provide new image a result. Since usually all
            filters implement <see cref="T:Accord.Imaging.Filters.IFilter"/> interface, the information provided by this property
            (if filter also implements <see cref="T:Accord.Imaging.Filters.IFilterInformation"/> interface) may be useful to
            user to resolve filter's capabilities.</para>
            
            <para>Sample usage:</para>
            <code>
            // get filter's IFilterInformation interface
            IFilterInformation info = (IFilterInformation) filter;
            // check if the filter supports our image's format
            if ( info.FormatTranslations.ContainsKey( image.PixelFormat )
            {
                // format is supported, check what will be result of image processing
                PixelFormat resultingFormat = info.FormatTranslations[image.PixelFormat];
            }
            /// </code>
            </remarks>
            
        </member>
        <member name="T:Accord.Imaging.Filters.IInPlaceFilter">
            <summary>
            In-place filter interface.
            </summary>
            
            <remarks>The interface defines the set of methods, which should be
            implemented by filters, which are capable to do image processing
            directly on the source image. Not all image processing filters
            can be applied directly to the source image - only filters, which do not
            change image's dimension and pixel format, can be applied directly to the
            source image.</remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.IFilter"/>
            <seealso cref="T:Accord.Imaging.Filters.IInPlacePartialFilter"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IInPlaceFilter.ApplyInPlace(System.Drawing.Bitmap)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            
            <remarks>The method applies filter directly to the provided image data.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IInPlaceFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="imageData">Image to apply filter to.</param>
            
            <remarks>The method applies filter directly to the provided image data.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IInPlaceFilter.ApplyInPlace(Accord.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image in unmanaged memory.
            </summary>
            
            <param name="image">Image in unmanaged memory.</param>
            
            <remarks>The method applies filter directly to the provided image data.</remarks>
            
        </member>
        <member name="T:Accord.Imaging.Filters.IInPlacePartialFilter">
            <summary>
            In-place partial filter interface.
            </summary>
            
            <remarks><para>The interface defines the set of methods, which should be
            implemented by filters, which are capable to do image processing
            directly on the source image. Not all image processing filters
            can be applied directly to the source image - only filters, which do not
            change image dimension and pixel format, can be applied directly to the
            source image.</para>
            
            <para>The interface also supports partial image filtering, allowing to specify
            image rectangle, which should be filtered.</para>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.IFilter"/>
            <seealso cref="T:Accord.Imaging.Filters.IInPlaceFilter"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IInPlacePartialFilter.ApplyInPlace(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image or its part.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by filter.</param>
            
            <remarks>The method applies filter directly to the provided image data.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IInPlacePartialFilter.ApplyInPlace(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image or its part.
            </summary>
            
            <param name="imageData">Image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by filter.</param>
            
            <remarks>The method applies filter directly to the provided image data.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.IInPlacePartialFilter.ApplyInPlace(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image in unmanaged memory.
            </summary>
            
            <param name="image">Image in unmanaged memory.</param>
            <param name="rect">Image rectangle for processing by filter.</param>
            
            <remarks>The method applies filter directly to the provided image.</remarks>
            
        </member>
        <member name="T:Accord.Imaging.Filters.FlatFieldCorrection">
            <summary>
            Flat field correction filter.
            </summary>
            
            <remarks><para>The goal of flat-field correction is to remove artifacts from 2-D images that
            are caused by variations in the pixel-to-pixel sensitivity of the detector and/or by distortions
            in the optical path. The filter requires two images for the input - source image, which represents
            acquisition of some objects (using microscope, for example), and background image, which is taken
            without any objects presented. The source image is corrected using the formula: <b>src = bgMean * src / bg</b>,
            where <b>src</b> - source image's pixel value, <b>bg</b> - background image's pixel value, <b>bgMean</b> - mean
            value of background image.</para>
            
            <para><note>If background image is not provided, then it will be automatically generated on each filter run
            from source image. The automatically generated background image is produced running Gaussian Blur on the
            original image with (sigma value is set to 5, kernel size is set to 21). Before blurring the original image
            is resized to 1/3 of its original size and then the result of blurring is resized back to the original size.
            </note></para>
            
            <para><note>The class processes only grayscale (8 bpp indexed) and color (24 bpp) images.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            FlatFieldCorrection filter = new FlatFieldCorrection( bgImage );
            // process image
            filter.ApplyInPlace( sourceImage );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="..\images\imaging\sample4.jpg" width="480" height="387" />
            <para><b>Background image:</b></para>
            <img src="..\images\imaging\bg.jpg" width="480" height="387" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\flat_field.jpg" width="480" height="387" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FlatFieldCorrection.BackgoundImage">
            <summary>
            Background image used for flat field correction.
            </summary>
            
            <remarks><para>The property sets the background image (without any objects), which will be used
            for illumination correction of an image passed to the filter.</para>
            
            <para><note>The background image must have the same size and pixel format as source image.
            Otherwise exception will be generated when filter is applied to source image.</note></para>
            
            <para><note>Setting this property will clear the <see cref="P:Accord.Imaging.Filters.FlatFieldCorrection.UnmanagedBackgoundImage"/> property -
            only one background image is allowed: managed or unmanaged.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FlatFieldCorrection.UnmanagedBackgoundImage">
            <summary>
            Background image used for flat field correction.
            </summary>
            
            <remarks><para>The property sets the background image (without any objects), which will be used
            for illumination correction of an image passed to the filter.</para>
            
            <para><note>The background image must have the same size and pixel format as source image.
            Otherwise exception will be generated when filter is applied to source image.</note></para>
            
            <para><note>Setting this property will clear the <see cref="P:Accord.Imaging.Filters.FlatFieldCorrection.BackgoundImage"/> property -
            only one background image is allowed: managed or unmanaged.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FlatFieldCorrection.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
            
             <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FlatFieldCorrection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FlatFieldCorrection"/> class.
            </summary>
            
            <remarks><para>This constructor does not set background image, which means that background
            image will be generated on the fly on each filter run. The automatically generated background
            image is produced running Gaussian Blur on the original image with (sigma value is set to 5,
            kernel size is set to 21). Before blurring the original image is resized to 1/3 of its original size
            and then the result of blurring is resized back to the original size.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FlatFieldCorrection.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FlatFieldCorrection"/> class.
            </summary>
            
            <param name="backgroundImage">Background image used for flat field correction.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FlatFieldCorrection.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BottomHat">
             <summary>
             Bottop-hat operator from Mathematical Morphology.
             </summary>
             
             <remarks><para>Bottom-hat morphological operator <see cref="T:Accord.Imaging.Filters.Subtract">subtracts</see>
             input image from the result of <see cref="T:Accord.Imaging.Filters.Closing">morphological closing</see> on the
             the input image.</para>
             
             <para>Applied to binary image, the filter allows to get all object parts, which were
             added by <see cref="T:Accord.Imaging.Filters.Closing">closing</see> filter, but were not removed after that due
             to formed connections/fillings.</para>
             
             <para>The filter accepts 8 and 16 bpp grayscale images and 24 and 48 bpp
             color images for processing.</para>
            
             <para>Sample usage:</para>
             <code>
             // create filter
             BottomHat filter = new BottomHat( );
             // apply the filter
             filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample12.png" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\bottomhat.png" width="320" height="240" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.TopHat"/>
             
        </member>
        <member name="P:Accord.Imaging.Filters.BottomHat.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.BottomHat.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BottomHat"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BottomHat.#ctor(System.Int16[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BottomHat"/> class.
            </summary>
            
            <param name="se">Structuring element to pass to <see cref="T:Accord.Imaging.Filters.Closing"/> operator.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BottomHat.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Closing">
            <summary>
            Closing operator from Mathematical Morphology.
            </summary>
            
            <remarks><para>Closing morphology operator equals to <see cref="T:Accord.Imaging.Filters.Dilation">ditation</see> followed
            by <see cref="T:Accord.Imaging.Filters.Erosion">erosion</see>.</para>
            
            <para>Applied to binary image, the filter may be used connect or fill objects. Since dilation is used
            first, it may connect/fill object areas. Then erosion restores objects. But since dilation may connect
            something before, erosion may not remove after that because of the formed connection.</para>
            
            <para>See documentation to <see cref="T:Accord.Imaging.Filters.Erosion"/> and <see cref="T:Accord.Imaging.Filters.Dilation"/> classes for more
            information and list of supported pixel formats.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Closing filter = new Closing( );
            // apply the filter
            filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample12.png" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\closing.png" width="320" height="240" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.Erosion"/>
            <seealso cref="T:Accord.Imaging.Filters.Dilation"/>
            <seealso cref="T:Accord.Imaging.Filters.Opening"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Closing.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Closing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Closing"/> class.
            </summary>
            
            <remarks><para>Initializes new instance of the <see cref="T:Accord.Imaging.Filters.Closing"/> class using
            default structuring element for both <see cref="T:Accord.Imaging.Filters.Erosion"/> and <see cref="T:Accord.Imaging.Filters.Dilation"/>
            classes - 3x3 structuring element with all elements equal to 1.
            </para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Closing.#ctor(System.Int16[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Closing"/> class.
            </summary>
            
            <param name="se">Structuring element.</param>
            
            <remarks><para>See documentation to <see cref="T:Accord.Imaging.Filters.Erosion"/> and <see cref="T:Accord.Imaging.Filters.Dilation"/>
            classes for information about structuring element constraints.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Closing.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Closing.Apply(System.Drawing.Imaging.BitmapData)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="imageData">Source image to apply filter to.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
            <remarks>The filter accepts bitmap data as input and returns the result
            of image processing filter as new image. The source image data are kept
            unchanged.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Closing.Apply(Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Closing.Apply(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:Accord.Imaging.Filters.Closing.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Closing.ApplyInPlace(System.Drawing.Bitmap)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:Accord.Imaging.Filters.Closing.ApplyInPlace(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Closing.ApplyInPlace(Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an unmanaged image.
             </summary>
             
             <param name="image">Unmanaged image to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source unmanaged image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Closing.ApplyInPlace(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image or its part.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:Accord.Imaging.Filters.Closing.ApplyInPlace(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
             <summary>
             Apply filter to an image or its part.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Closing.ApplyInPlace(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an unmanaged image or its part.
            </summary>
            
            <param name="image">Unmanaged image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Dilation">
            <summary>
            dilation operator from Mathematical Morphology.
            </summary>
            
            <remarks><para>The filter assigns maximum value of surrounding pixels to each pixel of
            the result image. Surrounding pixels, which should be processed, are specified by
            structuring element: 1 - to process the neighbor, -1 - to skip it.</para>
            
            <para>The filter especially useful for binary image processing, where it allows to grow
            separate objects or join objects.</para>
            
            <para>For processing image with 3x3 structuring element, there are different optimizations
            available, like <see cref="T:Accord.Imaging.Filters.Dilation3x3"/> and <see cref="T:Accord.Imaging.Filters.BinaryDilation3x3"/>.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24 and 48 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            dilation filter = new dilation( );
            // apply the filter
            filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample12.png" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\dilation.png" width="320" height="240" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.Erosion"/>
            <seealso cref="T:Accord.Imaging.Filters.Closing"/>
            <seealso cref="T:Accord.Imaging.Filters.Opening"/>
            <seealso cref="T:Accord.Imaging.Filters.Dilation3x3"/>
            <seealso cref="T:Accord.Imaging.Filters.BinaryDilation3x3"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Dilation.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Dilation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Dilation"/> class.
            </summary>
            
            <remarks><para>Initializes new instance of the <see cref="T:Accord.Imaging.Filters.Dilation"/> class using
            default structuring element - 3x3 structuring element with all elements equal to 1.
            </para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Dilation.#ctor(System.Int16[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Dilation"/> class.
            </summary>
            
            <param name="se">Structuring element.</param>
            
            <remarks><para>Structuring elemement for the dilation morphological operator
            must be square matrix with odd size in the range of [3, 99].</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid size of structuring element.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Dilation.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Erosion">
            <summary>
            Erosion operator from Mathematical Morphology.
            </summary>
            
            <remarks><para>The filter assigns minimum value of surrounding pixels to each pixel of
            the result image. Surrounding pixels, which should be processed, are specified by
            structuring element: 1 - to process the neighbor, -1 - to skip it.</para>
            
            <para>The filter especially useful for binary image processing, where it removes pixels, which
            are not surrounded by specified amount of neighbors. It gives ability to remove noisy pixels
            (stand-alone pixels) or shrink objects.</para>
            
            <para>For processing image with 3x3 structuring element, there are different optimizations
            available, like <see cref="T:Accord.Imaging.Filters.Erosion3x3"/> and <see cref="T:Accord.Imaging.Filters.BinaryErosion3x3"/>.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24 and 48 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Erosion filter = new Erosion( );
            // apply the filter
            filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample12.png" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\erosion.png" width="320" height="240" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.Dilation"/>
            <seealso cref="T:Accord.Imaging.Filters.Closing"/>
            <seealso cref="T:Accord.Imaging.Filters.Opening"/>
            <seealso cref="T:Accord.Imaging.Filters.Erosion3x3"/>
            <seealso cref="T:Accord.Imaging.Filters.BinaryErosion3x3"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Erosion.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Erosion.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Erosion"/> class.
            </summary>
            
            <remarks><para>Initializes new instance of the <see cref="T:Accord.Imaging.Filters.Erosion"/> class using
            default structuring element - 3x3 structuring element with all elements equal to 1.
            </para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Erosion.#ctor(System.Int16[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Erosion"/> class.
            </summary>
            
            <param name="se">Structuring element.</param>
            
            <remarks><para>Structuring elemement for the erosion morphological operator
            must be square matrix with odd size in the range of [3, 99].</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid size of structuring element.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Erosion.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.HitAndMiss">
            <summary>
            Hit-And-Miss operator from Mathematical Morphology.
            </summary>
            
            <remarks><para>The hit-and-miss filter represents generalization of <see cref="T:Accord.Imaging.Filters.Erosion"/>
            and <see cref="T:Accord.Imaging.Filters.Dilation"/> filters by extending flexibility of structuring element and
            providing different modes of its work. Structuring element may contain:
            <list type="bullet">
            <item>1 - foreground;</item>
            <item>0 - background;</item>
            <item>-1 - don't care.</item>
            </list>
            </para>
            
            <para>Filter's mode is set by <see cref="P:Accord.Imaging.Filters.HitAndMiss.Mode"/> property. The list of modes and its
            documentation may be found in <see cref="T:Accord.Imaging.Filters.HitAndMiss.Modes"/> enumeration.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing. <b>Note</b>: grayscale images are treated
            as binary with 0 value equals to black and 255 value equals to white.</para>
            
            <para>Sample usage:</para>
            <code>
            // define kernel to remove pixels on the right side of objects
            // (pixel is removed, if there is white pixel on the left and
            // black pixel on the right)
            short[,] se = new short[,] {
                { -1, -1, -1 },
                {  1,  1,  0 },
                { -1, -1, -1 }
            };
            // create filter
            HitAndMiss filter = new HitAndMiss( se, HitAndMiss.Modes.Thinning );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample12.png" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\hit-and-miss.png" width="320" height="240" />
            </remarks>
            
        </member>
        <member name="T:Accord.Imaging.Filters.HitAndMiss.Modes">
            <summary>
            Hit and Miss modes.
            </summary>
            
            <remarks><para>Bellow is a list of modes meaning depending on pixel's correspondence
            to specified structuring element:
            <list type="bullet">
            <item><see cref="F:Accord.Imaging.Filters.HitAndMiss.Modes.HitAndMiss"/> - on match pixel is set to white, otherwise to black;</item>
            <item><see cref="F:Accord.Imaging.Filters.HitAndMiss.Modes.Thinning"/> - on match pixel is set to black, otherwise not changed.</item>
            <item><see cref="F:Accord.Imaging.Filters.HitAndMiss.Modes.Thickening"/> - on match pixel is set to white, otherwise not changed.</item>
            </list>
            </para></remarks>
            
        </member>
        <member name="F:Accord.Imaging.Filters.HitAndMiss.Modes.HitAndMiss">
            <summary>
            Hit and miss mode.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.HitAndMiss.Modes.Thinning">
            <summary>
            Thinning mode.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.HitAndMiss.Modes.Thickening">
            <summary>
            Thickening mode.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.HitAndMiss.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.HitAndMiss.Mode">
            <summary>
            Operation mode.
            </summary>
            
            <remarks><para>Mode to use for the filter. See <see cref="T:Accord.Imaging.Filters.HitAndMiss.Modes"/> enumeration
            for the list of available modes and their documentation.</para>
            
            <para>Default mode is set to <see cref="F:Accord.Imaging.Filters.HitAndMiss.Modes.HitAndMiss"/>.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HitAndMiss.#ctor(System.Int16[0:,0:])">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HitAndMiss"/> class.
             </summary>
             
             <param name="se">Structuring element.</param>
            
             <remarks><para>Structuring elemement for the hit-and-miss morphological operator
             must be square matrix with odd size in the range of [3, 99].</para></remarks>
             
             <exception cref="T:System.ArgumentException">Invalid size of structuring element.</exception>
             
        </member>
        <member name="M:Accord.Imaging.Filters.HitAndMiss.#ctor(System.Int16[0:,0:],Accord.Imaging.Filters.HitAndMiss.Modes)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HitAndMiss"/> class.
            </summary>
            
            <param name="se">Structuring element.</param>
            <param name="mode">Operation mode.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HitAndMiss.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Opening">
             <summary>
             Opening operator from Mathematical Morphology.
             </summary>
             
             <remarks><para>Opening morphology operator equals to <see cref="T:Accord.Imaging.Filters.Erosion">erosion</see> followed
             by <see cref="T:Accord.Imaging.Filters.Dilation">dilation</see>.</para>
             
             <para>Applied to binary image, the filter may be used for removing small object keeping big objects
             unchanged. Since erosion is used first, it removes all small objects. Then dilation restores big
             objects, which were not removed by erosion.</para>
             
             <para>See documentation to <see cref="T:Accord.Imaging.Filters.Erosion"/> and <see cref="T:Accord.Imaging.Filters.Dilation"/> classes for more
             information and list of supported pixel formats.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             Opening filter = new Opening( );
             // apply the filter
             filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample12.png" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\opening.png" width="320" height="240" />
             </remarks>
            
             <seealso cref="T:Accord.Imaging.Filters.Erosion"/>
             <seealso cref="T:Accord.Imaging.Filters.Dilation"/>
             <seealso cref="T:Accord.Imaging.Filters.Closing"/>
             
        </member>
        <member name="P:Accord.Imaging.Filters.Opening.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Opening.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Opening"/> class.
            </summary>
            
            <remarks><para>Initializes new instance of the <see cref="T:Accord.Imaging.Filters.Opening"/> class using
            default structuring element for both <see cref="T:Accord.Imaging.Filters.Erosion"/> and <see cref="T:Accord.Imaging.Filters.Dilation"/>
            classes - 3x3 structuring element with all elements equal to 1.
            </para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Opening.#ctor(System.Int16[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Opening"/> class.
            </summary>
            
            <param name="se">Structuring element.</param>
            
            <remarks><para>See documentation to <see cref="T:Accord.Imaging.Filters.Erosion"/> and <see cref="T:Accord.Imaging.Filters.Dilation"/>
            classes for information about structuring element constraints.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Opening.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Opening.Apply(System.Drawing.Imaging.BitmapData)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="imageData">Source image to apply filter to.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
            <remarks>The filter accepts bitmap data as input and returns the result
            of image processing filter as new image. The source image data are kept
            unchanged.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Opening.Apply(Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="image">Source image in unmanaged memory to apply filter to.</param>
             
             <returns>Returns filter's result obtained by applying the filter to
             the source image.</returns>
             
             <remarks>The method keeps the source image unchanged and returns
             the result of image processing filter as new image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Opening.Apply(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an image in unmanaged memory.
             </summary>
             
             <param name="sourceImage">Source image in unmanaged memory to apply filter to.</param>
             <param name="destinationImage">Destination image in unmanaged memory to put result into.</param>
             
             <remarks><para>The method keeps the source image unchanged and puts result of image processing
             into destination image.</para>
             
             <para><note>The destination image must have the same width and height as source image. Also
             destination image must have pixel format, which is expected by particular filter (see
             <see cref="P:Accord.Imaging.Filters.Opening.FormatTranslations"/> property for information about pixel format conversions).</note></para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Incorrect destination pixel format.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Destination image has wrong width and/or height.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Opening.ApplyInPlace(System.Drawing.Bitmap)">
            <summary>
            Apply filter to an image.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:Accord.Imaging.Filters.Opening.ApplyInPlace(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Opening.ApplyInPlace(Accord.Imaging.UnmanagedImage)">
             <summary>
             Apply filter to an unmanaged image.
             </summary>
             
             <param name="image">Unmanaged image to apply filter to.</param>
             
             <remarks>The method applies the filter directly to the provided source unmanaged image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Opening.ApplyInPlace(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an image or its part.
            </summary>
            
            <param name="image">Image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:Accord.Imaging.Filters.Opening.ApplyInPlace(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
             <summary>
             Apply filter to an image or its part.
             </summary>
             
             <param name="imageData">Image data to apply filter to.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <remarks>The method applies the filter directly to the provided source image.</remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Opening.ApplyInPlace(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Apply filter to an unmanaged image or its part.
            </summary>
            
            <param name="image">Unmanaged image to apply filter to.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <remarks>The method applies the filter directly to the provided source image.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BinaryDilation3x3">
            <summary>
            Binary dilation operator from Mathematical Morphology with 3x3 structuring element.
            </summary>
            
            <remarks><para>The filter represents an optimized version of <see cref="T:Accord.Imaging.Filters.Dilation"/>
            filter, which is aimed for binary images (containing black and white pixels) processed
            with 3x3 structuring element. This makes this filter ideal for growing objects in binary
            images â it puts white pixel to the destination image in the case if there is at least
            one white neighbouring pixel in the source image.</para>
            
            <para>See <see cref="T:Accord.Imaging.Filters.Dilation"/> filter, which represents generic version of
            dilation filter supporting custom structuring elements and wider range of image formats.</para>
            
            <para>The filter accepts 8 bpp grayscale (binary) images for processing.</para>
            </remarks>
            
            <example>
            <code source="Unit Tests\Accord.Tests.Imaging\Filters\MorphologicalTests.cs" region="doc_binary_dilation_3x3" />
            <para>
              Binarized image:</para>
            <img src="..\images\imaging\morpho-dilation3x3-binary.png" />
            <para>
              Result image:</para>
            <img src="..\images\imaging\morpho-dilation3x3-result.png" />
            </example>
            
            <seealso cref="T:Accord.Imaging.Filters.Dilation"/>
            <seealso cref="T:Accord.Imaging.Filters.Dilation3x3"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BinaryDilation3x3.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.BinaryDilation3x3.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BinaryDilation3x3"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BinaryDilation3x3.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Processing rectangle mast be at least 3x3 in size.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BinaryErosion3x3">
            <summary>
            Binary erosion operator from Mathematical Morphology with 3x3 structuring element.
            </summary>
            
            <remarks><para>The filter represents an optimized version of <see cref="T:Accord.Imaging.Filters.Erosion"/>
            filter, which is aimed for binary images (containing black and white pixels) processed
            with 3x3 structuring element. This makes this filter ideal for removing noise in binary
            images â it removes all white pixels, which are neighbouring with at least one blank pixel.
            </para>
            
            <para>See <see cref="T:Accord.Imaging.Filters.Erosion"/> filter, which represents generic version of
            erosion filter supporting custom structuring elements and wider range of image formats.</para>
            
            <para>The filter accepts 8 bpp grayscale (binary) images for processing.</para>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.Erosion"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BinaryErosion3x3.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.BinaryErosion3x3.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BinaryErosion3x3"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BinaryErosion3x3.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Processing rectangle mast be at least 3x3 in size.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Dilation3x3">
            <summary>
            dilation operator from Mathematical Morphology with 3x3 structuring element.
            </summary>
            
            <remarks><para>The filter represents an optimized version of <see cref="T:Accord.Imaging.Filters.Dilation"/>
            filter, which is aimed for grayscale image processing with 3x3 structuring element.</para>
            
            <para>See <see cref="T:Accord.Imaging.Filters.Dilation"/> filter, which represents generic version of
            dilation filter supporting custom structuring elements and wider range of image formats.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.Dilation"/>
            <seealso cref="T:Accord.Imaging.Filters.BinaryDilation3x3"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Dilation3x3.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Dilation3x3.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Dilation3x3"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Dilation3x3.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Processing rectangle mast be at least 3x3 in size.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Erosion3x3">
            <summary>
            Erosion operator from Mathematical Morphology with 3x3 structuring element.
            </summary>
            
            <remarks><para>The filter represents an optimized version of <see cref="T:Accord.Imaging.Filters.Erosion"/>
            filter, which is aimed for grayscale image processing with 3x3 structuring element.</para>
            
            <para>See <see cref="T:Accord.Imaging.Filters.Erosion"/> filter, which represents generic version of
            erosion filter supporting custom structuring elements and wider range of image formats.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.Erosion"/>
            <seealso cref="T:Accord.Imaging.Filters.BinaryErosion3x3"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Erosion3x3.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Erosion3x3.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Erosion3x3"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Erosion3x3.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Processing rectangle mast be at least 3x3 in size.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.TopHat">
            <summary>
            Top-hat operator from Mathematical Morphology.
            </summary>
            
            <remarks><para>Top-hat morphological operator <see cref="T:Accord.Imaging.Filters.Subtract">subtracts</see>
            result of <see cref="T:Accord.Imaging.Filters.Opening">morphological opening</see> on the input image
            from the input image itself.</para>
            
             <para>Applied to binary image, the filter allows to get all those object (their parts)
             which were removed by <see cref="T:Accord.Imaging.Filters.Opening">opening</see> filter, but never restored.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24 and 48 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            TopHat filter = new TopHat( );
            // apply the filter
            filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample12.png" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\tophat.png" width="320" height="240" />
            </remarks>
            
            <see cref="T:Accord.Imaging.Filters.BottomHat"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TopHat.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.TopHat.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.TopHat"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TopHat.#ctor(System.Int16[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.TopHat"/> class.
            </summary>
            
            <param name="se">Structuring element to pass to <see cref="T:Accord.Imaging.Filters.Opening"/> operator.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TopHat.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.AdditiveNoise">
            <summary>
            Additive noise filter.
            </summary>
            
            <remarks><para>The filter adds random value to each pixel of the source image.
            The distribution of random values can be specified by <see cref="P:Accord.Imaging.Filters.AdditiveNoise.Generator">random generator</see>.
            </para>
            
            <para>The filter accepts 8 bpp grayscale images and 24 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create random generator
            IRandomNumberGenerator generator = new UniformGenerator( new Range( -50, 50 ) );
            // create filter
            AdditiveNoise filter = new AdditiveNoise( generator );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\additive_noise.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.AdditiveNoise.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.AdditiveNoise.Generator">
            <summary>
            Random number generator used to add noise.
            </summary>
            
            <remarks>Default generator is uniform generator in the range of (-10, 10).</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.AdditiveNoise.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.AdditiveNoise"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.AdditiveNoise.#ctor(Accord.Math.Random.IRandomNumberGenerator{System.Double})">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.AdditiveNoise"/> class.
            </summary>
            
            <param name="generator">Random number generator used to add noise.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.AdditiveNoise.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.SaltAndPepperNoise">
            <summary>
            Salt and pepper noise.
            </summary>
            
            <remarks><para>The filter adds random salt and pepper noise - sets
            maximum or minimum values to randomly selected pixels.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            SaltAndPepperNoise filter = new SaltAndPepperNoise( 10 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\salt_noise.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SaltAndPepperNoise.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.SaltAndPepperNoise.NoiseAmount">
            <summary>
            Amount of noise to generate in percents, [0, 100].
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SaltAndPepperNoise.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SaltAndPepperNoise"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SaltAndPepperNoise.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SaltAndPepperNoise"/> class.
            </summary>
            
            <param name="noiseAmount">Amount of noise to generate in percents, [0, 100].</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SaltAndPepperNoise.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ExtractNormalizedRGBChannel">
            <summary>
            Extract normalized RGB channel from color image.
            </summary>
            
            <remarks><para>Extracts specified normalized RGB channel of color image and returns
            it as grayscale image.</para>
            
            <para><note>Normalized RGB color space is defined as:
            <code lang="none">
            r = R / (R + G + B ),
            g = G / (R + G + B ),
            b = B / (R + G + B ),
            </code>
            where <b>R</b>, <b>G</b> and <b>B</b> are components of RGB color space and
            <b>r</b>, <b>g</b> and <b>b</b> are components of normalized RGB color space.
            </note></para>
            
            <para>The filter accepts 24, 32, 48 and 64 bpp color images and produces
            8 (if source is 24 or 32 bpp image) or 16 (if source is 48 or 64 bpp image)
            bpp grayscale image.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ExtractNormalizedRGBChannel filter = new ExtractNormalizedRGBChannel( RGB.G );
            // apply the filter
            Bitmap channelImage = filter.Apply( image );
            </code>
            
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.ExtractChannel"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ExtractNormalizedRGBChannel.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ExtractNormalizedRGBChannel.Channel">
            <summary>
            Normalized RGB channel to extract.
            </summary>
            
            <remarks><para>Default value is set to <see cref="F:Accord.Imaging.RGB.R"/>.</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid channel is specified.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ExtractNormalizedRGBChannel.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ExtractNormalizedRGBChannel"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ExtractNormalizedRGBChannel.#ctor(System.Int16)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ExtractNormalizedRGBChannel"/> class.
            </summary>
            
            <param name="channel">Normalized RGB channel to extract.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ExtractNormalizedRGBChannel.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ApplyMask">
            <summary>
            Apply mask to the specified image.
            </summary>
            
            <remarks><para>The filter applies mask to the specified image - keeps all pixels
            in the image if corresponding pixels/values of the mask are not equal to 0. For all
            0 pixels/values in mask, corresponding pixels in the source image are set to 0.</para>
            
            <para>Mask can be specified as <see cref="P:Accord.Imaging.Filters.ApplyMask.MaskImage">.NET's managed Bitmap</see>, as
            <see cref="P:Accord.Imaging.Filters.ApplyMask.UnmanagedMaskImage">UnmanagedImage</see> or as <see cref="P:Accord.Imaging.Filters.ApplyMask.Mask">byte array</see>.
            In the case if mask is specified as image, it must be 8 bpp grayscale image. In all case
            mask size must be the same as size of the image to process.</para>
            
            <para>The filter accepts 8/16 bpp grayscale and 24/32/48/64 bpp color images for processing.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ApplyMask.MaskImage">
            <summary>
            Mask image to apply.
            </summary>
            
            <remarks><para>The property specifies mask image to use. The image must be grayscale
            (8 bpp format) and have the same size as the source image to process.</para>
            
            <para>When the property is set, both <see cref="P:Accord.Imaging.Filters.ApplyMask.UnmanagedMaskImage"/> and
            <see cref="P:Accord.Imaging.Filters.ApplyMask.Mask"/> properties are set to <see langword="null"/>.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">The mask image must be 8 bpp grayscale image.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ApplyMask.UnmanagedMaskImage">
            <summary>
            Unmanaged mask image to apply.
            </summary>
            
            <remarks><para>The property specifies unmanaged mask image to use. The image must be grayscale
            (8 bpp format) and have the same size as the source image to process.</para>
            
            <para>When the property is set, both <see cref="P:Accord.Imaging.Filters.ApplyMask.MaskImage"/> and
            <see cref="P:Accord.Imaging.Filters.ApplyMask.Mask"/> properties are set to <see langword="null"/>.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">The mask image must be 8 bpp grayscale image.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ApplyMask.Mask">
            <summary>
            Mask to apply.
            </summary>
            
            <remarks><para>The property specifies mask array to use. Size of the array must
            be the same size as the size of the source image to process - its 0<sup>th</sup> dimension
            must be equal to image's height and its 1<sup>st</sup> dimension must be equal to width. For
            example, for 640x480 image, the mask array must be defined as:
            <code>
            byte[,] mask = new byte[480, 640];
            </code>
            </para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ApplyMask.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ApplyMask.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ApplyMask"/> class.
            </summary>
            
            <param name="maskImage"><see cref="P:Accord.Imaging.Filters.ApplyMask.MaskImage">Mask image</see> to use.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ApplyMask.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ApplyMask"/> class.
            </summary>
            
            <param name="unmanagedMaskImage"><see cref="P:Accord.Imaging.Filters.ApplyMask.UnmanagedMaskImage">Unmanaged mask image</see> to use.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ApplyMask.#ctor(System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ApplyMask"/> class.
            </summary>
            
            <param name="mask"><see cref="P:Accord.Imaging.Filters.ApplyMask.Mask"/> to use.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ApplyMask.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <exception cref="T:System.NullReferenceException">None of the possible mask properties were set. Need to provide mask before applying the filter.</exception>
             <exception cref="T:System.ArgumentException">Invalid size of provided mask. Its size must be the same as the size of the image to mask.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BinaryWatershed">
            <summary>
              Watershed filter.
            </summary>
            
            <remarks>
            <para>
              In the study of image processing, a watershed is a transformation defined on a grayscale image. 
              The name refers metaphorically to a geological watershed, or drainage divide, which separates 
              adjacent drainage basins. The watershed transformation treats the image it operates upon like a
              topographic map, with the brightness of each point representing its height, and finds the lines 
              that run along the tops of ridges.</para>
            <para>
              There are different technical definitions of a watershed. In graphs, watershed lines may be 
              defined on the nodes, on the edges, or hybrid lines on both nodes and edges. Watersheds may
              also be defined in the continuous domain.[1] There are also many different algorithms to compute 
              watersheds. Watershed algorithm is used in image processing primarily for segmentation purposes.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description><a href="https://en.wikipedia.org/wiki/Watershed_(image_processing)">
                  Wikipedia contributors. "Watershed (image processing)." Wikipedia, The Free Encyclopedia. 
                  Available on: https://en.wikipedia.org/wiki/Watershed_(image_processing) </a>
                  </description></item>
               </list></para>
            </remarks>
            
            <example>
            <code>
              Bitmap input = ... 
            
              // Apply the transform
              var dt = new BinaryWatershed();
              Bitmap output = dt.Apply(input);
            
              // Show results on screen
              ImageBox.Show("input", input);
              ImageBox.Show("output", output);
              
              // Mark points using PointsMarker
              var marker = new PointsMarker(Color.Red, 5)
              {
                  Points = bw.MaxPoints
              };
              
              Bitmap marked = marker.Apply(result);
              ImageBox.Show("markers", marked);
            </code>
            </example>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BinaryWatershed.MaxPoints">
            <summary>
              Gets the list of maximum points found in the image.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BinaryWatershed.Tolerance">
            <summary>
              Gets or sets the tolerance. Default is 0.5f.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BinaryWatershed.Distance">
            <summary>
              Gets or sets the distance method to be used in the 
              underlying <see cref="T:Accord.Imaging.Filters.DistanceTransform"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BinaryWatershed.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BinaryWatershed.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BinaryWatershed"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BinaryWatershed.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BinaryWatershed"/> class.
            </summary>
            
            <param name="tolerance">The tolerance. Default is 0.5f.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BinaryWatershed.#ctor(System.Single,Accord.Imaging.Filters.DistanceTransformMethod)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BinaryWatershed"/> class.
            </summary>
            
            <param name="tolerance">The tolerance. Default is 0.5f.</param>
            <param name="distance">The distance method.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BinaryWatershed.#ctor(Accord.Imaging.Filters.DistanceTransformMethod)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BinaryWatershed"/> class.
            </summary>
            
            <param name="distance">The distance method.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BinaryWatershed.ProcessFilter(Accord.Imaging.UnmanagedImage)">
            <summary>
            Processes the filter.
            </summary>
            <param name="image">The image.</param>
        </member>
        <member name="T:Accord.Imaging.Filters.DistanceTransformMethod">
            <summary>
              Distance functions that can be used with <see cref="T:Accord.Imaging.Filters.DistanceTransform"/>.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.DistanceTransformMethod.Chessboard">
            <summary>
              Chessboard distance.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.DistanceTransformMethod.Euclidean">
            <summary>
              Euclidean distance.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.DistanceTransformMethod.Manhattan">
            <summary>
              Manhattan distance.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.DistanceTransformMethod.SquaredEuclidean">
            <summary>
              Squared Euclidean distance.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.Filters.DistanceTransform">
            <summary>
              Distance transform filter.
            </summary>
            
            <remarks>
            <para>
              A distance transform, also known as distance map or distance field, is a derived
              representation of a digital image.The choice of the term depends on the point of 
              view on the object in question: whether the initial image is transformed into another 
              representation, or it is simply endowed with an additional map or field.</para>
            <para>
              Distance fields can also be signed, in the case where it is important to distinguish whether
              the point is inside or outside of the shape. The map labels each pixel of the image with 
              the distance to the nearest obstacle pixel. A most common type of obstacle pixel is a boundary 
              pixel in a binary image.See the image for an example of a chessboard distance transform 
              on a binary image.</para>
              
            <para>
              Usually the transform/map is qualified with the chosen metric.For example, one may 
              speak of <see cref="F:Accord.Imaging.Filters.DistanceTransformMethod.Manhattan"/>distance transform, if the 
              underlying metric is <see cref="T:Accord.Math.Distances.Manhattan">Manhattan distance</see>. Common metrics are:
              The <see cref="F:Accord.Imaging.Filters.DistanceTransformMethod.Euclidean">Euclidean distance</see>; the Taxicab 
              geometry, also known as City block distance or <see cref="F:Accord.Imaging.Filters.DistanceTransformMethod.Manhattan">Manhattan 
              distance</see>; and the <see cref="F:Accord.Imaging.Filters.DistanceTransformMethod.Chessboard">Chessboard distance</see>.
              </para>
              
            <para>
              References:
              <list type="bullet">
                <item><description><a href="https://en.wikipedia.org/wiki/Distance_transform">
                  Wikipedia contributors. "Distance transform." Wikipedia, The Free Encyclopedia. 
                  Available on: https://en.wikipedia.org/wiki/Distance_transform </a>
                  </description></item>
               </list></para>
            </remarks>
            
            <example>
            <code>
              Bitmap input = ... 
            
              // Apply the transform
              DistanceTransform dt = new DistanceTransform();
              Bitmap output = dt.Apply(input);
            
              // Show results on screen
              ImageBox.Show("input", input);
              ImageBox.Show("output", output);
            </code>
            </example>
            
        </member>
        <member name="P:Accord.Imaging.Filters.DistanceTransform.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.DistanceTransform.Pixels">
            <summary>
              Gets the resulting pixels of the last transfomed image as a float[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.DistanceTransform.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.DistanceTransform"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.DistanceTransform.#ctor(Accord.Imaging.Filters.DistanceTransformMethod)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.DistanceTransform"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.DistanceTransform.MaximumDistance">
            <summary>
              Gets the maximum distance from the transform.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.DistanceTransform.UltimateErodedPoint">
            <summary>
              Gets the ultimate eroded point.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.DistanceTransform.ProcessFilter(Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BlobsFiltering">
             <summary>
             Blobs filtering by size.
             </summary>
             
             <remarks><para>The filter performs filtering of blobs by their size in the specified
             source image - all blobs, which are smaller or bigger then specified limits, are
             removed from the image.</para>
             
             <para><note>The image processing filter treats all none black pixels as objects'
             pixels and all black pixel as background.</note></para>
             
             <para>The filter accepts 8 bpp grayscale images and 24/32
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             BlobsFiltering filter = new BlobsFiltering( );
             // configure filter
             filter.CoupledSizeFiltering = true;
             filter.MinWidth  = 70;
             filter.MinHeight = 70;
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample2.jpg" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\blobs_filtering.jpg" width="320" height="240" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.BlobCounter"/>
             <seealso cref="T:Accord.Imaging.BlobCounterBase"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BlobsFiltering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.BlobsFiltering.CoupledSizeFiltering">
            <summary>
            Specifies if size filetering should be coupled or not.
            </summary>
            
            <remarks><para>See documentation for <see cref="P:Accord.Imaging.BlobCounterBase.CoupledSizeFiltering"/> property
            of <see cref="T:Accord.Imaging.BlobCounterBase"/> class for more information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BlobsFiltering.MinWidth">
            <summary>
            Minimum allowed width of blob.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BlobsFiltering.MinHeight">
            <summary>
            Minimum allowed height of blob.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BlobsFiltering.MaxWidth">
            <summary>
            Maximum allowed width of blob.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BlobsFiltering.MaxHeight">
            <summary>
            Maximum allowed height of blob.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BlobsFiltering.BlobsFilter">
            <summary>
            Custom blobs' filter to use.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter"/> for information
            about custom blobs' filtering routine.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BlobsFiltering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BlobsFiltering"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BlobsFiltering.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BlobsFiltering"/> class.
            </summary>
            
            <param name="minWidth">Minimum allowed width of blob.</param>
            <param name="minHeight">Minimum allowed height of blob.</param>
            <param name="maxWidth">Maximum allowed width of blob.</param>
            <param name="maxHeight">Maximum allowed height of blob.</param>
            
            <remarks>This constructor creates an instance of <see cref="T:Accord.Imaging.Filters.BlobsFiltering"/> class
            with <see cref="P:Accord.Imaging.Filters.BlobsFiltering.CoupledSizeFiltering"/> property set to <b>false</b>.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BlobsFiltering.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BlobsFiltering"/> class.
            </summary>
            
            <param name="minWidth">Minimum allowed width of blob.</param>
            <param name="minHeight">Minimum allowed height of blob.</param>
            <param name="maxWidth">Maximum allowed width of blob.</param>
            <param name="maxHeight">Maximum allowed height of blob.</param>
            <param name="coupledSizeFiltering">Specifies if size filetering should be coupled or not.</param>
            
            <remarks><para>For information about coupled filtering mode see documentation for
            <see cref="P:Accord.Imaging.BlobCounterBase.CoupledSizeFiltering"/> property of <see cref="T:Accord.Imaging.BlobCounterBase"/>
            class.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BlobsFiltering.#ctor(Accord.Imaging.IBlobsFilter)">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BlobsFiltering"/> class.
             </summary>
             
             <param name="blobsFilter">Custom blobs' filtering routine to use
             (see <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter"/>).</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BlobsFiltering.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.CanvasCrop">
            <summary>
            Fill areas outiside of specified region.
            </summary>
            
            <remarks>
            <para>The filter fills areas outside of specified region using the specified color.</para>
            
            <para>The filter accepts 8bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            CanvasCrop filter = new CanvasCrop( new Rectangle(
                                    5, 5, image.Width - 10, image.Height - 10 ), Color.Red );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\canvas_crop.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.CanvasFill"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CanvasCrop.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CanvasCrop.FillColorRGB">
            <summary>
            RGB fill color.
            </summary>
            
            <remarks><para>The color is used to fill areas out of specified region in color images.</para>
            
            <para>Default value is set to white - RGB(255, 255, 255).</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CanvasCrop.FillColorGray">
            <summary>
            Gray fill color.
            </summary>
            
            <remarks><para>The color is used to fill areas out of specified region in grayscale images.</para>
            
            <para>Default value is set to white - 255.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CanvasCrop.Region">
            <summary>
            Region to keep.
            </summary>
            
            <remarks>Pixels inside of the specified region will keep their values, but
            pixels outside of the region will be filled with specified color.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasCrop.#ctor(System.Drawing.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CanvasCrop"/> class.
            </summary>
            
            <param name="region">Region to keep.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasCrop.#ctor(System.Drawing.Rectangle,System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CanvasCrop"/> class.
            </summary>
            
            <param name="region">Region to keep.</param>
            <param name="fillColorRgb">RGB color to use for filling areas outside of specified region in color images.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasCrop.#ctor(System.Drawing.Rectangle,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CanvasCrop"/> class.
            </summary>
            
            <param name="region">Region to keep.</param>
            <param name="fillColorGray">Gray color to use for filling areas outside of specified region in grayscale images.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasCrop.#ctor(System.Drawing.Rectangle,System.Drawing.Color,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CanvasCrop"/> class.
            </summary>
            
            <param name="region">Region to keep.</param>
            <param name="fillColorRgb">RGB color to use for filling areas outside of specified region in color images.</param>
            <param name="fillColorGray">Gray color to use for filling areas outside of specified region in grayscale images.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasCrop.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.CanvasFill">
            <summary>
            Fill areas iniside of the specified region.
            </summary>
            
            <remarks>
            <para>The filter fills areas inside of specified region using the specified color.</para>
            
            <para>The filter accepts 8bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            CanvasFill filter = new CanvasFill( new Rectangle(
                                    5, 5, image.Width - 10, image.Height - 10 ), Color.Red );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.CanvasCrop"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CanvasFill.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CanvasFill.FillColorRGB">
            <summary>
            RGB fill color.
            </summary>
            
            <remarks><para>The color is used to fill areas out of specified region in color images.</para>
            
            <para>Default value is set to white - RGB(255, 255, 255).</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CanvasFill.FillColorGray">
            <summary>
            Gray fill color.
            </summary>
            
            <remarks><para>The color is used to fill areas out of specified region in grayscale images.</para>
            
            <para>Default value is set to white - 255.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CanvasFill.Region">
            <summary>
            Region to fill.
            </summary>
            
            <remarks>Pixels inside of the specified region will be filled with specified color.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasFill.#ctor(System.Drawing.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CanvasFill"/> class.
            </summary>
            
            <param name="region">Region to fill.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasFill.#ctor(System.Drawing.Rectangle,System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CanvasFill"/> class.
            </summary>
            
            <param name="region">Region to fill.</param>
            <param name="fillColorRGB">RGB color to use for filling areas inside of specified region in color images.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasFill.#ctor(System.Drawing.Rectangle,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CanvasFill"/> class.
            </summary>
            
            <param name="region">Region to fill.</param>
            <param name="fillColorGray">Gray color to use for filling areas inside of specified region in grayscale images.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasFill.#ctor(System.Drawing.Rectangle,System.Drawing.Color,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CanvasFill"/> class.
            </summary>
            
            <param name="region">Region to fill.</param>
            <param name="fillColorRGB">RGB color to use for filling areas inside of specified region in color images.</param>
            <param name="fillColorGray">Gray color to use for filling areas inside of specified region in grayscale images.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasFill.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.CanvasMove">
            <summary>
            Move canvas to the specified point.
            </summary>
            
            <remarks>
            <para>The filter moves canvas to the specified area filling unused empty areas with specified color.</para>
            
            <para>The filter accepts 8/16 bpp grayscale images and 24/32/48/64 bpp color image
            for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            CanvasMove filter = new CanvasMove( new IntPoint( -50, -50 ), Color.Green );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\canvas_move.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CanvasMove.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CanvasMove.FillColorRGB">
            <summary>
            RGB fill color.
            </summary>
            
            <remarks><para>The color is used to fill empty areas in color images.</para>
            
            <para>Default value is set to white - ARGB(255, 255, 255, 255).</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CanvasMove.FillColorGray">
             <summary>
             Gray fill color.
             </summary>
             
             <remarks><para>The color is used to fill empty areas in grayscale images.</para>
             
             <para>Default value is set to white - 255.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CanvasMove.MovePoint">
            <summary>
            Point to move the canvas to.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasMove.#ctor(Accord.IntPoint)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CanvasMove"/> class.
            </summary>
            
            <param name="movePoint">Point to move the canvas to.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasMove.#ctor(Accord.IntPoint,System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CanvasMove"/> class.
            </summary>
            
            <param name="movePoint">Point to move the canvas.</param>
            <param name="fillColorRGB">RGB color to use for filling areas empty areas in color images.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasMove.#ctor(Accord.IntPoint,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CanvasMove"/> class.
            </summary>
            
            <param name="movePoint">Point to move the canvas.</param>
            <param name="fillColorGray">Gray color to use for filling empty areas in grayscale images.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasMove.#ctor(Accord.IntPoint,System.Drawing.Color,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CanvasMove"/> class.
            </summary>
            
            <param name="movePoint">Point to move the canvas.</param>
            <param name="fillColorRGB">RGB color to use for filling areas empty areas in color images.</param>
            <param name="fillColorGray">Gray color to use for filling empty areas in grayscale images.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CanvasMove.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ConnectedComponentsLabeling">
             <summary>
             Connected components labeling.
             </summary>
             
             <remarks><para>The filter performs labeling of objects in the source image. It colors
             each separate object using different color. The image processing filter treats all none
             black pixels as objects' pixels and all black pixel as background.</para>
             
             <para>The filter accepts 8 bpp grayscale images and 24/32 bpp color images and produces
             24 bpp RGB image.</para>
            
             <para>Sample usage:</para>
             <code>
             // create filter
             var filter = new ConnectedComponentsLabeling();
             
             // apply the filter
             Bitmap newImage = filter.Apply(image);
             
             // check objects count
             int objectCount = filter.ObjectCount;
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample2.jpg" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\labeling.jpg" width="320" height="240" />
             </remarks>
             
        </member>
        <member name="P:Accord.Imaging.Filters.ConnectedComponentsLabeling.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ConnectedComponentsLabeling.BlobCounter">
            <summary>
            Blob counter used to locate separate blobs.
            </summary>
            
            <remarks><para>The property allows to set blob counter to use for blobs' localization.</para>
            
            <para>Default value is set to <see cref="P:Accord.Imaging.Filters.ConnectedComponentsLabeling.BlobCounter"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ConnectedComponentsLabeling.ColorTable">
            <summary>
            Colors used to color the binary image.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ConnectedComponentsLabeling.FilterBlobs">
            <summary>
            Specifies if blobs should be filtered.
            </summary>
            
            <remarks><para>See documentation for <see cref="P:Accord.Imaging.BlobCounterBase.FilterBlobs"/> property
            of <see cref="T:Accord.Imaging.BlobCounterBase"/> class for more information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ConnectedComponentsLabeling.CoupledSizeFiltering">
            <summary>
            Specifies if size filetering should be coupled or not.
            </summary>
            
            <remarks><para>See documentation for <see cref="P:Accord.Imaging.BlobCounterBase.CoupledSizeFiltering"/> property
            of <see cref="T:Accord.Imaging.BlobCounterBase"/> class for more information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ConnectedComponentsLabeling.MinWidth">
            <summary>
            Minimum allowed width of blob.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ConnectedComponentsLabeling.MinHeight">
            <summary>
            Minimum allowed height of blob.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ConnectedComponentsLabeling.MaxWidth">
            <summary>
            Maximum allowed width of blob.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ConnectedComponentsLabeling.MaxHeight">
            <summary>
            Maximum allowed height of blob.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ConnectedComponentsLabeling.ObjectCount">
            <summary>
            Objects count.
            </summary>
            
            <remarks>The amount of objects found in the last processed image.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ConnectedComponentsLabeling.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ConnectedComponentsLabeling"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ConnectedComponentsLabeling.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.CornersMarker">
            <summary>
            Filter to mark (highlight) corners of objects.
            </summary>
            
            <remarks>
            <para>The filter highlights corners of objects on the image using provided corners
            detection algorithm.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24/32 color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create corner detector's instance
            SusanCornersDetector scd = new SusanCornersDetector( );
            // create corner maker filter
            CornersMarker filter = new CornersMarker( scd, Color.Red );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample2.jpg" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\susan_corners.png" width="320" height="240" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CornersMarker.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.CornersMarker.MarkerColor">
            <summary>
            Color used to mark corners.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.CornersMarker.Detector">
            <summary>
            Interface of corners' detection algorithm used to detect corners.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.CornersMarker.#ctor(Accord.Imaging.ICornersDetector)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CornersMarker"/> class.
            </summary>
            
            <param name="detector">Interface of corners' detection algorithm.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CornersMarker.#ctor(Accord.Imaging.ICornersDetector,System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CornersMarker"/> class.
            </summary>
            
            <param name="detector">Interface of corners' detection algorithm.</param>
            <param name="markerColor">Marker's color used to mark corner.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CornersMarker.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.FillHoles">
            <summary>
            Fill holes in objects in binary image.
            </summary>
            
            <remarks><para>The filter allows to fill black holes in white object in a binary image.
            It is possible to specify maximum holes' size to fill using <see cref="P:Accord.Imaging.Filters.FillHoles.MaxHoleWidth"/>
            and <see cref="P:Accord.Imaging.Filters.FillHoles.MaxHoleHeight"/> properties.</para>
            
            <para>The filter accepts binary image only, which are represented  as 8 bpp images.</para>
            
            <para>Sample usage:</para>
            <code>
            // create and configure the filter
            FillHoles filter = new FillHoles( );
            filter.MaxHoleHeight = 20;
            filter.MaxHoleWidth  = 20;
            filter.CoupledSizeFiltering = false;
            // apply the filter
            Bitmap result = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample19.png" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\filled_holes.png" width="320" height="240" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FillHoles.CoupledSizeFiltering">
            <summary>
            Specifies if size filetering should be coupled or not.
            </summary>
            
            <remarks><para>In uncoupled filtering mode, holes are filled in the case if
            their width is smaller than or equal to <see cref="P:Accord.Imaging.Filters.FillHoles.MaxHoleWidth"/> or height is smaller than 
            or equal to <see cref="P:Accord.Imaging.Filters.FillHoles.MaxHoleHeight"/>. But in coupled filtering mode, holes are filled only in
            the case if both width and height are smaller or equal to the corresponding value.</para>
            
            <para>Default value is set to <see langword="true"/>, what means coupled filtering by size.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FillHoles.MaxHoleWidth">
             <summary>
             Maximum width of a hole to fill.
             </summary>
            
             <remarks><para>All holes, which have width greater than this value, are kept unfilled.
             See <see cref="P:Accord.Imaging.Filters.FillHoles.CoupledSizeFiltering"/> for additional information.</para>
             
             <para>Default value is set to <see cref="F:System.Int32.MaxValue"/>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FillHoles.MaxHoleHeight">
             <summary>
             Maximum height of a hole to fill.
             </summary>
            
             <remarks><para>All holes, which have height greater than this value, are kept unfilled.
             See <see cref="P:Accord.Imaging.Filters.FillHoles.CoupledSizeFiltering"/> for additional information.</para>
             
             <para>Default value is set to <see cref="F:System.Int32.MaxValue"/>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FillHoles.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.FillHoles.#ctor">
            <summary>   
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FillHoles"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.FillHoles.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.HorizontalRunLengthSmoothing">
             <summary>
             Horizontal run length smoothing algorithm.
             </summary>
             
             <remarks><para>The class implements horizontal run length smoothing algorithm, which
             is described in: <b>K.Y. Wong, R.G. Casey and F.M. Wahl, "Document analysis system,"
             IBM J. Res. Devel., Vol. 26, NO. 6,111). 647-656, 1982.</b></para>
             
             <para>Unlike the original description of this algorithm, this implementation must be applied
             to inverted binary images containing document, i.e. white text on black background. So this
             implementation fills horizontal black gaps between white pixels.</para>
             
             <para><note>This algorithm is usually used together with <see cref="T:Accord.Imaging.Filters.VerticalRunLengthSmoothing"/>,
             <see cref="T:Accord.Imaging.Filters.Intersect"/> and then further analysis of white blobs.</note></para>
             
             <para>The filter accepts 8 bpp grayscale images, which are supposed to be binary inverted documents.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             HorizontalRunLengthSmoothing hrls = new HorizontalRunLengthSmoothing( 32 );
             // apply the filter
             hrls.ApplyInPlace( image );
             </code>
            
             <para><b>Source image:</b></para>
             <img src="..\images\imaging\sample24.png" width="480" height="320" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\hrls.png" width="480" height="320" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.VerticalRunLengthSmoothing"/>
             
        </member>
        <member name="P:Accord.Imaging.Filters.HorizontalRunLengthSmoothing.MaxGapSize">
             <summary>
             Maximum gap size to fill (in pixels).
             </summary>
             
             <remarks><para>The property specifies maximum horizontal gap between white pixels to fill.
             If number of black pixels between some white pixels is bigger than this value, then those
             black pixels are left as is; otherwise the gap is filled with white pixels.
             </para>
             
             <para>Default value is set to <b>10</b>. Minimum value is 1. Maximum value is 1000.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HorizontalRunLengthSmoothing.ProcessGapsWithImageBorders">
            <summary>
            Process gaps between objects and image borders or not.
            </summary>
            
            <remarks><para>The property sets if gaps between image borders and objects must be treated as
            gaps between objects and also filled.</para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HorizontalRunLengthSmoothing.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HorizontalRunLengthSmoothing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HorizontalRunLengthSmoothing"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HorizontalRunLengthSmoothing.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HorizontalRunLengthSmoothing"/> class.
            </summary>
            
            <param name="maxGapSize">Maximum gap size to fill (see <see cref="P:Accord.Imaging.Filters.HorizontalRunLengthSmoothing.MaxGapSize"/>).</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HorizontalRunLengthSmoothing.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ImageWarp">
             <summary>
             Image warp effect filter.
             </summary>
             
             <remarks><para>The image processing filter implements a warping filter, which
             sets pixels in destination image to values from source image taken with specified offset
             (see <see cref="P:Accord.Imaging.Filters.ImageWarp.WarpMap"/>).
             </para>
             
             <para>The filter accepts 8 bpp grayscale images and 24/32
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // build warp map
             int width  = image.Width;
             int height = image.Height;
             
             IntPoint[,] warpMap = new IntPoint[height, width];
            
             int size = 8;
             int maxOffset = -size + 1;
            
             for ( int y = 0; y &lt; height; y++ )
             {
                 for ( int x = 0; x &lt; width; x++ )
                 {
                     int dx = ( x / size ) * size - x;
                     int dy = ( y / size ) * size - y;
            
                     if ( dx + dy &lt;= maxOffset )
                     {
                         dx = ( x / size + 1 ) * size - 1 - x;
                     }
            
                     warpMap[y, x] = new IntPoint( dx, dy );
                 }
             }
             // create filter
             ImageWarp filter = new ImageWarp( warpMap );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\image_warp.png" width="480" height="361" />
             </remarks>
             
        </member>
        <member name="P:Accord.Imaging.Filters.ImageWarp.WarpMap">
            <summary>
            Map used for warping images.
            </summary>
            
            <remarks><para>The property sets displacement map used for warping images.
            The map sets offsets of pixels in source image, which are used to set values in destination
            image. In other words, each pixel in destination image is set to the same value
            as pixel in source image with corresponding offset (coordinates of pixel in source image
            are calculated as sum of destination coordinate and corresponding value from warp map).
            </para>
            
            <para><note>The map array is accessed using [y, x] indexing, i.e.
            first dimension in the map array corresponds to Y axis of image.</note></para>
            
            <para><note>If the map is smaller or bigger than the image to process, then only minimum
            overlapping area of the image is processed. This allows to prepare single big map and reuse
            it for a set of images for creating similar effects.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ImageWarp.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ImageWarp.#ctor(Accord.IntPoint[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ImageWarp"/> class.
            </summary>
            
            <param name="warpMap">Map used for warping images (see <see cref="P:Accord.Imaging.Filters.ImageWarp.WarpMap"/>).</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ImageWarp.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Jitter">
            <summary>
            Jitter filter.
            </summary>
            
            <remarks><para>The filter moves each pixel of a source image in
            random direction within a window of specified <see cref="P:Accord.Imaging.Filters.Jitter.Radius">radius</see>.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Jitter filter = new Jitter( 4 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\jitter.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Jitter.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Jitter.Radius">
            <summary>
            Jittering radius, [1, 10]
            </summary>
            
            <remarks><para>Determines radius in which pixels can move.</para>
            
            <para>Default value is set to <b>2</b>.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Jitter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Jitter"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Jitter.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Jitter"/> class.
            </summary>
            
            <param name="radius">Jittering radius.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Jitter.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.MaskedFilter">
            <summary>
            Apply filter according to the specified mask.
            </summary>
            
            <remarks><para>The image processing routine applies the specified <see cref="P:Accord.Imaging.Filters.MaskedFilter.BaseFilter"/> to
            a source image according to the specified mask - if a pixel/value in the specified mask image/array
            is set to 0, then the original pixel's value is kept; otherwise the pixel is filtered using the
            specified base filter.</para>
            
            <para>Mask can be specified as <see cref="P:Accord.Imaging.Filters.MaskedFilter.MaskImage">.NET's managed Bitmap</see>, as
            <see cref="P:Accord.Imaging.Filters.MaskedFilter.UnmanagedMaskImage">UnmanagedImage</see> or as <see cref="P:Accord.Imaging.Filters.MaskedFilter.Mask">byte array</see>.
            In the case if mask is specified as image, it must be 8 bpp grayscale image. In all case
            mask size must be the same as size of the image to process.</para>
            
            <para><note>Pixel formats accepted by this filter are specified by the <see cref="P:Accord.Imaging.Filters.MaskedFilter.BaseFilter"/>.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create the filter
            MaskedFilter maskedFilter = new MaskedFilter( new Sepia( ), maskImage );
            // apply the filter
            maskedFilter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Mask image:</b></para>
            <img src="..\images\imaging\mask.png" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\masked_image.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.MaskedFilter.BaseFilter">
             <summary>
             Base filter to apply to the source image.
             </summary>
            
             <remarks><para>The property specifies base filter which is applied to the specified source
             image (to all pixels which have corresponding none 0 value in mask image/array).</para>
             
             <para><note>The base filter must implement <see cref="T:Accord.Imaging.Filters.IFilterInformation"/> interface.</note></para>
             
             <para><note>The base filter must never change image's pixel format. For example, if source
             image's pixel format is 24 bpp color image, then it must stay the same after the base
             filter is applied.</note></para>
             
             <para><note>The base filter must never change size of the source image.</note></para>
             </remarks>
             
             <exception cref="T:System.NullReferenceException">Base filter can not be set to null.</exception>
             <exception cref="T:System.ArgumentException">The specified base filter must implement IFilterInformation interface.</exception>
             <exception cref="T:System.ArgumentException">The specified filter must never change pixel format.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.MaskedFilter.MaskImage">
            <summary>
            Mask image to apply.
            </summary>
            
            <remarks><para>The property specifies mask image to use. The image must be grayscale
            (8 bpp format) and have the same size as the source image to process.</para>
            
            <para>When the property is set, both <see cref="P:Accord.Imaging.Filters.MaskedFilter.UnmanagedMaskImage"/> and
            <see cref="P:Accord.Imaging.Filters.MaskedFilter.Mask"/> properties are set to <see langword="null"/>.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">The mask image must be 8 bpp grayscale image.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.MaskedFilter.UnmanagedMaskImage">
            <summary>
            Unmanaged mask image to apply.
            </summary>
            
            <remarks><para>The property specifies unmanaged mask image to use. The image must be grayscale
            (8 bpp format) and have the same size as the source image to process.</para>
            
            <para>When the property is set, both <see cref="P:Accord.Imaging.Filters.MaskedFilter.MaskImage"/> and
            <see cref="P:Accord.Imaging.Filters.MaskedFilter.Mask"/> properties are set to <see langword="null"/>.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">The mask image must be 8 bpp grayscale image.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.MaskedFilter.Mask">
            <summary>
            Mask to apply.
            </summary>
            
            <remarks><para>The property specifies mask array to use. Size of the array must
            be the same size as the size of the source image to process - its 0<sup>th</sup> dimension
            must be equal to image's height and its 1<sup>st</sup> dimension must be equal to width. For
            example, for 640x480 image, the mask array must be defined as:
            <code>
            byte[,] mask = new byte[480, 640];
            </code>
            </para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.MaskedFilter.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para>
            
            <para><note>The property returns format translation table from the
            <see cref="P:Accord.Imaging.Filters.MaskedFilter.BaseFilter"/>.</note></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.MaskedFilter.#ctor(Accord.Imaging.Filters.IFilter,System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.MaskedFilter"/> class.
            </summary>
            
            <param name="baseFiler"><see cref="P:Accord.Imaging.Filters.MaskedFilter.BaseFilter">Base filter</see> to apply to the specified source image.</param>
            <param name="maskImage"><see cref="P:Accord.Imaging.Filters.MaskedFilter.MaskImage">Mask image</see> to use.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.MaskedFilter.#ctor(Accord.Imaging.Filters.IFilter,Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.MaskedFilter"/> class.
            </summary>
            
            <param name="baseFiler"><see cref="P:Accord.Imaging.Filters.MaskedFilter.BaseFilter">Base filter</see> to apply to the specified source image.</param>
            <param name="unmanagedMaskImage"><see cref="P:Accord.Imaging.Filters.MaskedFilter.UnmanagedMaskImage">Unmanaged mask image</see> to use.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.MaskedFilter.#ctor(Accord.Imaging.Filters.IFilter,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.MaskedFilter"/> class.
            </summary>
            
            <param name="baseFiler"><see cref="P:Accord.Imaging.Filters.MaskedFilter.BaseFilter">Base filter</see> to apply to the specified source image.</param>
            <param name="mask"><see cref="P:Accord.Imaging.Filters.MaskedFilter.Mask"/> to use.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.MaskedFilter.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <exception cref="T:System.NullReferenceException">None of the possible mask properties were set. Need to provide mask before applying the filter.</exception>
             <exception cref="T:System.ArgumentException">Invalid size of provided mask. Its size must be the same as the size of the image to mask.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Mirror">
            <summary>
            Mirroring filter.
            </summary>
            
            <remarks><para>The filter mirrors image around X and/or Y axis (horizontal and vertical
            mirroring).</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Mirror filter = new Mirror( false, true );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\mirror.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Mirror.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.Mirror.MirrorX">
            <summary>
            Specifies if mirroring should be done for X axis (horizontal mirroring).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Mirror.MirrorY">
            <summary>
            Specifies if mirroring should be done for Y axis (vertical mirroring).
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Mirror.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Mirror"/> class.
            </summary>
            
            <param name="mirrorX">Specifies if mirroring should be done for X axis.</param>
            <param name="mirrorY">Specifies if mirroring should be done for Y axis</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Mirror.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.OilPainting">
            <summary>
            Oil painting filter.
            </summary>
            
            <remarks><para>Processing source image the filter changes each pixels' value
            to the value of pixel with the most frequent intensity within window of the
            <see cref="P:Accord.Imaging.Filters.OilPainting.BrushSize">specified size</see>. Going through the window the filters
            finds which intensity of pixels is the most frequent. Then it updates value
            of the pixel in the center of the window to the value with the most frequent
            intensity. The update procedure creates the effect of oil painting.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            OilPainting filter = new OilPainting( 15 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\oil_painting.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.OilPainting.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.OilPainting.BrushSize">
            <summary>
            Brush size, [3, 21].
            </summary>
            
            <remarks><para>Window size to search for most frequent pixels' intensity.</para>
            
            <para>Default value is set to <b>5</b>.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.OilPainting.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.OilPainting"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.OilPainting.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.OilPainting"/> class.
            </summary>
            
            <param name="brushSize">Brush size.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.OilPainting.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Pixellate">
            <summary>
            Pixellate filter.
            </summary>
            
            <remarks><para>The filter processes an image creating the effect of an image with larger
            pixels - pixellated image. The effect is achieved by filling image's rectangles of the
            specified size by the color, which is mean color value for the corresponding rectangle.
            The size of rectangles to process is set by <see cref="P:Accord.Imaging.Filters.Pixellate.PixelWidth"/> and <see cref="P:Accord.Imaging.Filters.Pixellate.PixelHeight"/>
            properties.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Pixellate filter = new Pixellate( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\pixellate.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Pixellate.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.Pixellate.PixelWidth">
            <summary>
            Pixel width, [2, 32].
            </summary>
            
            <remarks>Default value is set to <b>8</b>.</remarks>
            
            <seealso cref="P:Accord.Imaging.Filters.Pixellate.PixelSize"/>
            <seealso cref="P:Accord.Imaging.Filters.Pixellate.PixelHeight"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Pixellate.PixelHeight">
            <summary>
            Pixel height, [2, 32].
            </summary>
            
            <remarks>Default value is set to <b>8</b>.</remarks>
            
            <seealso cref="P:Accord.Imaging.Filters.Pixellate.PixelSize"/>
            <seealso cref="P:Accord.Imaging.Filters.Pixellate.PixelWidth"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Pixellate.PixelSize">
            <summary>
            Pixel size, [2, 32].
            </summary>
            
            <remarks>The property is used to set both <see cref="P:Accord.Imaging.Filters.Pixellate.PixelWidth"/> and
            <see cref="P:Accord.Imaging.Filters.Pixellate.PixelHeight"/> simultaneously.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Pixellate.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Pixellate"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Pixellate.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Pixellate"/> class.
            </summary>
            
            <param name="pixelSize">Pixel size.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Pixellate.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Pixellate"/> class.
            </summary>
            
            <param name="pixelWidth">Pixel width.</param>
            <param name="pixelHeight">Pixel height.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Pixellate.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.SimpleSkeletonization">
            <summary>
            Simple skeletonization filter.
            </summary>
            
            <remarks><para>The filter build simple objects' skeletons by thinning them until
            they have one pixel wide "bones" horizontally and vertically. The filter uses
            <see cref="P:Accord.Imaging.Filters.SimpleSkeletonization.Background"/> and <see cref="P:Accord.Imaging.Filters.SimpleSkeletonization.Foreground"/> colors to distinguish
            between object and background.</para>
            
            <para>The filter accepts 8 bpp grayscale images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            SimpleSkeletonization filter = new SimpleSkeletonization( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample14.png" width="150" height="150" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\simple_skeletonization.png" width="150" height="150" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SimpleSkeletonization.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SimpleSkeletonization.Background">
            <summary>
            Background pixel color.
            </summary>
            
            <remarks><para>The property sets background (none object) color to look for.</para>
            
            <para>Default value is set to <b>0</b> - black.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SimpleSkeletonization.Foreground">
            <summary>
            Foreground pixel color.
            </summary>
            
            <remarks><para>The property sets objects' (none background) color to look for.</para>
            
            <para>Default value is set to <b>255</b> - white.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SimpleSkeletonization.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SimpleSkeletonization"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.SimpleSkeletonization.#ctor(System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SimpleSkeletonization"/> class.
            </summary>
            
            <param name="bg">Background pixel color.</param>
            <param name="fg">Foreground pixel color.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SimpleSkeletonization.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.TexturedFilter">
            <summary>
            Textured filter - filter an image using texture.
            </summary>
            
            <remarks><para>The filter is similar to <see cref="T:Accord.Imaging.Filters.TexturedMerge"/> filter in its
            nature, but instead of working with source image and overly, it uses provided
            filters to create images to merge (see <see cref="P:Accord.Imaging.Filters.TexturedFilter.Filter1"/> and <see cref="P:Accord.Imaging.Filters.TexturedFilter.Filter2"/>
            properties). In addition, it uses a bit more complex formula for calculation
            of destination pixel's value, which gives greater amount of flexibility:<br />
            <b>dst = <see cref="P:Accord.Imaging.Filters.TexturedFilter.FilterLevel"/> * ( src1 * textureValue + src2 * ( 1.0 - textureValue ) ) + <see cref="P:Accord.Imaging.Filters.TexturedFilter.PreserveLevel"/> * src2</b>,
            where <b>src1</b> is value of pixel from the image produced by <see cref="P:Accord.Imaging.Filters.TexturedFilter.Filter1"/>,
            <b>src2</b> is value of pixel from the image produced by <see cref="P:Accord.Imaging.Filters.TexturedFilter.Filter2"/>,
            <b>dst</b> is value of pixel in a destination image and <b>textureValue</b> is corresponding value
            from provided texture (see <see cref="P:Accord.Imaging.Filters.TexturedFilter.TextureGenerator"/> or <see cref="P:Accord.Imaging.Filters.TexturedFilter.Texture"/>).</para>
            
            <para><note>It is possible to set <see cref="P:Accord.Imaging.Filters.TexturedFilter.Filter2"/> to <see langword="null"/>. In this case
            original source image will be used instead of result produced by the second filter.</note></para>
            
            <para>The filter 24 bpp color images for processing.</para>
            
            <para>Sample usage #1:</para>
            <code>
            // create filter
            TexturedFilter filter = new TexturedFilter( new CloudsTexture( ),
                new HueModifier( 50 ) );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para>Sample usage #2:</para>
            <code>
            // create filter
            TexturedFilter filter = new TexturedFilter( new CloudsTexture( ),
                new GrayscaleBT709( ), new Sepia( ) );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image #1:</b></para>
            <img src="..\images\imaging\textured_filter1.jpg" width="480" height="361" />
            <para><b>Result image #2:</b></para>
            <img src="..\images\imaging\textured_filter2.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TexturedFilter.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
            
             <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TexturedFilter.FilterLevel">
            <summary>
            Filter level value, [0, 1].
            </summary>
            
            <remarks><para>Filtering factor determines portion of the destionation image, which is formed
            as a result of merging source images using specified texture.</para>
            
            <para>Default value is set to <b>1.0</b>.</para>
            
            <para>See <see cref="T:Accord.Imaging.Filters.TexturedFilter"/> class description for more details.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TexturedFilter.PreserveLevel">
            <summary>
            Preserve level value
            </summary>
            
            <remarks><para>Preserving factor determines portion taken from the image produced
            by <see cref="P:Accord.Imaging.Filters.TexturedFilter.Filter2"/> (or from original source) without applying textured
            merge to it.</para>
            
            <para>Default value is set to <b>0.0</b>.</para>
            
            <para>See <see cref="T:Accord.Imaging.Filters.TexturedFilter"/> class description for more details.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TexturedFilter.Texture">
            <summary>
            Generated texture.
            </summary>
            
            <remarks><para>Two dimensional array of texture intensities.</para>
            
            <para><note>Size of the provided texture should be the same as size of images, which will
            be passed to the filter.</note></para>
            
            <para><note>The <see cref="P:Accord.Imaging.Filters.TexturedFilter.TextureGenerator"/> property has priority over this property - if
            generator is specified than the static generated texture is not used.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TexturedFilter.TextureGenerator">
            <summary>
            Texture generator.
            </summary>
            
            <remarks><para>Generator used to generate texture.</para>
            
            <para><note>The property has priority over the <see cref="P:Accord.Imaging.Filters.TexturedFilter.Texture"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TexturedFilter.Filter1">
            <summary>
            First filter.
            </summary>
            
            <remarks><para>Filter, which is used to produce first image for the merge. The filter
            needs to implement <see cref="T:Accord.Imaging.Filters.IFilterInformation"/> interface, so it could be possible
            to get information about the filter. The filter must be able to process color 24 bpp
            images and produce color 24 bpp or grayscale 8 bppp images as result.</para>
            </remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The specified filter does not support 24 bpp color images.</exception>
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The specified filter does not produce image of supported format.</exception>
            <exception cref="T:System.ArgumentException">The specified filter does not implement IFilterInformation interface.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TexturedFilter.Filter2">
            <summary>
            Second filter
            </summary>
            
            <remarks><para>Filter, which is used to produce second image for the merge. The filter
            needs to implement <see cref="T:Accord.Imaging.Filters.IFilterInformation"/> interface, so it could be possible
            to get information about the filter. The filter must be able to process color 24 bpp
            images and produce color 24 bpp or grayscale 8 bppp images as result.</para>
            
            <para><note>The filter may be set to <see langword="null"/>. In this case original source image
            is used as a second image for the merge.</note></para>
            </remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The specified filter does not support 24 bpp color images.</exception>
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The specified filter does not produce image of supported format.</exception>
            <exception cref="T:System.ArgumentException">The specified filter does not implement IFilterInformation interface.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TexturedFilter.#ctor(System.Single[0:,0:],Accord.Imaging.Filters.IFilter)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.TexturedFilter"/> class.
            </summary>
            
            <param name="texture">Generated texture.</param>
            <param name="filter1">First filter.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TexturedFilter.#ctor(System.Single[0:,0:],Accord.Imaging.Filters.IFilter,Accord.Imaging.Filters.IFilter)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.TexturedFilter"/> class.
            </summary>
            
            <param name="texture">Generated texture.</param>
            <param name="filter1">First filter.</param>
            <param name="filter2">Second filter.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TexturedFilter.#ctor(Accord.Imaging.Textures.ITextureGenerator,Accord.Imaging.Filters.IFilter)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.TexturedFilter"/> class.
            </summary>
            
            <param name="generator">Texture generator.</param>
            <param name="filter1">First filter.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TexturedFilter.#ctor(Accord.Imaging.Textures.ITextureGenerator,Accord.Imaging.Filters.IFilter,Accord.Imaging.Filters.IFilter)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.TexturedFilter"/> class.
            </summary>
            
            <param name="generator">Texture generator.</param>
            <param name="filter1">First filter.</param>
            <param name="filter2">Second filter.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TexturedFilter.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Texture size does not match image size.</exception>
            <exception cref="T:System.ApplicationException">Filters should not change image dimension.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.TexturedMerge">
            <summary>
            Merge two images using factors from texture.
            </summary>
            
            <remarks><para>The filter is similar to <see cref="T:Accord.Imaging.Filters.Morph"/> filter in its idea, but
            instead of using single value for balancing amount of source's and overlay's image
            values (see <see cref="P:Accord.Imaging.Filters.Morph.SourcePercent"/>), the filter uses texture, which determines
            the amount to take from source image and overlay image.</para>
            
            <para>The filter uses specified texture to adjust values using the next formula:<br/>
            <b>dst = src * textureValue + ovr * ( 1.0 - textureValue )</b>,<br/>
            where <b>src</b> is value of pixel in a source image, <b>ovr</b> is value of pixel in
            overlay image, <b>dst</b> is value of pixel in a destination image and
            <b>textureValue</b> is corresponding value from provided texture (see <see cref="P:Accord.Imaging.Filters.TexturedMerge.TextureGenerator"/> or
            <see cref="P:Accord.Imaging.Filters.TexturedMerge.Texture"/>).</para>
            
            <para>The filter accepts 8 bpp grayscale and 24 bpp color images for processing.</para>
            
            <para>Sample usage #1:</para>
            <code>
            // create filter
            TexturedMerge filter = new TexturedMerge( new TextileTexture( ) );
            // create an overlay image to merge with
            filter.OverlayImage = new Bitmap( image.Width, image.Height,
                    PixelFormat.Format24bppRgb );
            // fill the overlay image with solid color
            PointedColorFloodFill fillFilter = new PointedColorFloodFill( Color.DarkKhaki );
            fillFilter.ApplyInPlace( filter.OverlayImage );
            // apply the merge filter
            filter.ApplyInPlace( image );
            </code>
            
            <para>Sample usage #2:</para>
            <code>
            // create filter
            TexturedMerge filter = new TexturedMerge( new CloudsTexture( ) );
            // create 2 images with modified Hue
            HueModifier hm1 = new HueModifier( 50 );
            HueModifier hm2 = new HueModifier( 200 );
            filter.OverlayImage = hm2.Apply( image );
            hm1.ApplyInPlace( image );
            // apply the merge filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image #1:</b></para>
            <img src="..\images\imaging\textured_merge1.jpg" width="480" height="361" />
            <para><b>Result image #2:</b></para>
            <img src="..\images\imaging\textured_merge2.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TexturedMerge.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
            
             <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TexturedMerge.Texture">
            <summary>
            Generated texture.
            </summary>
            
            <remarks><para>Two dimensional array of texture intensities.</para>
            
            <para><note>In the case if image passed to the filter is smaller or
            larger than the specified texture, than image's region is processed, which equals to the
            minimum overlapping area.</note></para>
            
            <para><note>The <see cref="P:Accord.Imaging.Filters.TexturedMerge.TextureGenerator"/> property has priority over this property - if
            generator is specified than the static generated texture is not used.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TexturedMerge.TextureGenerator">
            <summary>
            Texture generator.
            </summary>
            
            <remarks><para>Generator used to generate texture.</para>
            
            <para><note>The property has priority over the <see cref="P:Accord.Imaging.Filters.TexturedMerge.Texture"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TexturedMerge.#ctor(System.Single[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.TexturedMerge"/> class.
            </summary>
            
            <param name="texture">Generated texture.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TexturedMerge.#ctor(Accord.Imaging.Textures.ITextureGenerator)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.TexturedMerge"/> class.
            </summary>
            
            <param name="generator">Texture generator.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TexturedMerge.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="overlay">Overlay image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Texturer">
            <summary>
            Texturer filter.
            </summary>
            
            <remarks><para>Adjust pixelsâ color values using factors from the given texture. In conjunction with different type
            of texture generators, the filter may produce different type of interesting effects.</para>
            
            <para>The filter uses specified texture to adjust values using the next formula:<br/>
            <b>dst = src * <see cref="P:Accord.Imaging.Filters.Texturer.PreserveLevel"/> + src * <see cref="P:Accord.Imaging.Filters.Texturer.FilterLevel"/> * textureValue</b>,<br/>
            where <b>src</b> is value of pixel in a source image, <b>dst</b> is value of pixel in a destination image and
            <b>textureValue</b> is corresponding value from provided texture (see <see cref="P:Accord.Imaging.Filters.Texturer.TextureGenerator"/> or
            <see cref="P:Accord.Imaging.Filters.Texturer.Texture"/>). Using <see cref="P:Accord.Imaging.Filters.Texturer.PreserveLevel"/> and <see cref="P:Accord.Imaging.Filters.Texturer.FilterLevel"/> values it is possible
            to control the portion of source data affected by texture.
            </para>
            
            <para>In most cases the <see cref="P:Accord.Imaging.Filters.Texturer.PreserveLevel"/> and <see cref="P:Accord.Imaging.Filters.Texturer.FilterLevel"/> properties are set in such
            way, that <see cref="P:Accord.Imaging.Filters.Texturer.PreserveLevel"/> + <see cref="P:Accord.Imaging.Filters.Texturer.FilterLevel"/> = <b>1</b>. But there is no limitations actually
            for those values, so their sum may be as greater, as lower than 1 in order create different type of
            effects.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Texturer filter = new Texturer( new TextileTexture( ), 0.3, 0.7 );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\texturer.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Texturer.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
            
             <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Texturer.FilterLevel">
            <summary>
            Filter level value.
            </summary>
            
            <remarks><para>Filtering factor determines image fraction to filter - to multiply 
            by values from the provided texture.</para>
            
            <para>Default value is set to <b>0.5</b>.</para>
            
            <para>See <see cref="T:Accord.Imaging.Filters.Texturer"/> class description for more details.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Texturer.PreserveLevel">
            <summary>
            Preserve level value.
            </summary>
            
            <remarks><para>Preserving factor determines image fraction to keep from filtering.</para>
            
            <para>Default value is set to <b>0.5</b>.</para>
            
            <para>See <see cref="T:Accord.Imaging.Filters.Texturer"/> class description for more details.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Texturer.Texture">
            <summary>
            Generated texture.
            </summary>
            
            <remarks><para>Two dimensional array of texture intensities.</para>
            
            <para><note>In the case if image passed to the filter is smaller or
            larger than the specified texture, than image's region is processed, which equals to the
            minimum overlapping area.</note></para>
            
            <para><note>The <see cref="P:Accord.Imaging.Filters.Texturer.TextureGenerator"/> property has priority over this property - if
            generator is specified than the static generated texture is not used.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Texturer.TextureGenerator">
            <summary>
            Texture generator.
            </summary>
            
            <remarks><para>Generator used to generate texture.</para>
            
            <para><note>The property has priority over the <see cref="P:Accord.Imaging.Filters.Texturer.Texture"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Texturer.#ctor(System.Single[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Texturer"/> class.
            </summary>
            
            <param name="texture">Generated texture.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Texturer.#ctor(System.Single[0:,0:],System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Texturer"/> class.
            </summary>
            
            <param name="texture">Generated texture.</param>
            <param name="filterLevel">Filter level value (see <see cref="P:Accord.Imaging.Filters.Texturer.FilterLevel"/> property).</param>
            <param name="preserveLevel">Preserve level value (see <see cref="P:Accord.Imaging.Filters.Texturer.PreserveLevel"/> property).</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Texturer.#ctor(Accord.Imaging.Textures.ITextureGenerator)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Texturer"/> class.
            </summary>
            
            <param name="generator">Texture generator.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Texturer.#ctor(Accord.Imaging.Textures.ITextureGenerator,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Texturer"/> class.
            </summary>
            
            <param name="generator">Texture generator.</param>
            <param name="filterLevel">Filter level value (see <see cref="P:Accord.Imaging.Filters.Texturer.FilterLevel"/> property).</param>
            <param name="preserveLevel">Preserve level value (see <see cref="P:Accord.Imaging.Filters.Texturer.PreserveLevel"/> property).</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Texturer.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.VerticalRunLengthSmoothing">
            <summary>
            Vertical run length smoothing algorithm.
            </summary>
            
            <remarks><para>The class implements vertical run length smoothing algorithm, which
            is described in: <b>K.Y. Wong, R.G. Casey and F.M. Wahl, "Document analysis system,"
            IBM J. Res. Devel., Vol. 26, NO. 6,111). 647-656, 1982.</b></para>
            
            <para>Unlike the original description of this algorithm, this implementation must be applied
            to inverted binary images containing document, i.e. white text on black background. So this
            implementation fills vertical black gaps between white pixels.</para>
            
            <para><note>This algorithm is usually used together with <see cref="T:Accord.Imaging.Filters.HorizontalRunLengthSmoothing"/>,
            <see cref="T:Accord.Imaging.Filters.Intersect"/> and then further analysis of white blobs.</note></para>
            
            <para>The filter accepts 8 bpp grayscale images, which are supposed to be binary inverted documents.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            VerticalRunLengthSmoothing vrls = new VerticalRunLengthSmoothing( 32 );
            // apply the filter
            vrls.ApplyInPlace( image );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="..\images\imaging\sample24.png" width="480" height="320" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\vrls.png" width="480" height="320" />
            </remarks>
            
            <see cref="T:Accord.Imaging.Filters.HorizontalRunLengthSmoothing"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.VerticalRunLengthSmoothing.MaxGapSize">
             <summary>
             Maximum gap size to fill (in pixels).
             </summary>
             
             <remarks><para>The property specifies maximum vertical gap between white pixels to fill.
             If number of black pixels between some white pixels is bigger than this value, then those
             black pixels are left as is; otherwise the gap is filled with white pixels.
             </para>
             
             <para>Default value is set to <b>10</b>. Minimum value is 1. Maximum value is 1000.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.VerticalRunLengthSmoothing.ProcessGapsWithImageBorders">
            <summary>
            Process gaps between objects and image borders or not.
            </summary>
            
            <remarks><para>The property sets if gaps between image borders and objects must be treated as
            gaps between objects and also filled.</para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.VerticalRunLengthSmoothing.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.VerticalRunLengthSmoothing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.VerticalRunLengthSmoothing"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.VerticalRunLengthSmoothing.#ctor(System.Int32)">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.VerticalRunLengthSmoothing"/> class.
             </summary>
             
             <param name="maxGapSize">Maximum gap size to fill (see <see cref="P:Accord.Imaging.Filters.VerticalRunLengthSmoothing.MaxGapSize"/>).</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.VerticalRunLengthSmoothing.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.WaterWave">
            <summary>
            Simple water wave effect filter.
            </summary>
            
            <remarks><para>The image processing filter implements simple water wave effect. Using
            properties of the class, it is possible to set number of vertical/horizontal waves,
            as well as their amplitude.</para>
            
            <para>Bilinear interpolation is used to create smooth effect.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            WaterWave filter = new WaterWave( );
            filter.HorizontalWavesCount     = 10;
            filter.HorizontalWavesAmplitude = 5;
            filter.VerticalWavesCount       = 3;
            filter.VerticalWavesAmplitude   = 15;
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\water_wave.jpg" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.WaterWave.HorizontalWavesCount">
            <summary>
            Number of horizontal waves, [1, 10000].
            </summary>
            
            <remarks><para>Default value is set to <b>5</b>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.WaterWave.VerticalWavesCount">
            <summary>
            Number of vertical waves, [1, 10000].
            </summary>
            
            <remarks><para>Default value is set to <b>5</b>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.WaterWave.HorizontalWavesAmplitude">
            <summary>
            Amplitude of horizontal waves measured in pixels, [0, 10000].
            </summary>
            
            <remarks><para>Default value is set to <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.WaterWave.VerticalWavesAmplitude">
            <summary>
            Amplitude of vertical waves measured in pixels, [0, 10000].
            </summary>
            
            <remarks><para>Default value is set to <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.WaterWave.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.WaterWave.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.WaterWave"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.WaterWave.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.AdaptiveSmoothing">
            <summary>
            Adaptive Smoothing - noise removal with edges preserving.
            </summary>
            
            <remarks><para>The filter is aimed to perform image smoothing, but keeping sharp edges.
            This makes it applicable to additive noise removal and smoothing objects' interiors, but
            not applicable for spikes (salt and pepper noise) removal.</para>
            
            <para>The next calculations are done for each pixel:
            <list type="bullet">
            <item>weights are calculate for 9 pixels - pixel itself and 8 neighbors:
            <code lang="none">
            w(x, y) = exp( -1 * (Gx^2 + Gy^2) / (2 * factor^2) )
            Gx(x, y) = (I(x + 1, y) - I(x - 1, y)) / 2
            Gy(x, y) = (I(x, y + 1) - I(x, y - 1)) / 2
            </code>,
            where <see cref="P:Accord.Imaging.Filters.AdaptiveSmoothing.Factor">factor</see> is a configurable value determining smoothing's quality.</item>
            <item>sum of 9 weights is calclated (weightTotal);</item>
            <item>sum of 9 weighted pixel values is calculatd (total);</item>
            <item>destination pixel is calculated as <b>total / weightTotal</b>.</item>
            </list></para>
            
            <para>Description of the filter was found in <b>"An Edge Detection Technique Using
            the Facet Model and Parameterized Relaxation Labeling" by Ioannis Matalas, Student Member,
            IEEE, Ralph Benjamin, and Richard Kitney</b>.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            AdaptiveSmoothing filter = new AdaptiveSmoothing( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample13.png" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\adaptive_smooth.png" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.AdaptiveSmoothing.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.AdaptiveSmoothing.Factor">
            <summary>
            Factor value.
            </summary>
            
            <remarks><para>Factor determining smoothing quality (see <see cref="T:Accord.Imaging.Filters.AdaptiveSmoothing"/>
            documentation).</para>
            
            <para>Default value is set to <b>3</b>.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.AdaptiveSmoothing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.AdaptiveSmoothing"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.AdaptiveSmoothing.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.AdaptiveSmoothing"/> class.
            </summary>
            
            <param name="factor">Factor value.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.AdaptiveSmoothing.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BilateralSmoothing">
             <summary>
             Bilateral filter implementation - edge preserving smoothing and noise reduction that uses chromatic and spatial factors.
             </summary>
             
             <remarks>
             <para>Bilateral filter conducts "selective" Gaussian smoothing of areas of same color (domains) which removes noise and contrast artifacts
             while preserving sharp edges.</para>
             
             <para>Two major parameters <see cref="P:Accord.Imaging.Filters.BilateralSmoothing.SpatialFactor"/> and <see cref="P:Accord.Imaging.Filters.BilateralSmoothing.ColorFactor"/> define the result of the filter. 
             By changing these parameters you may achieve either only noise reduction with little change to the
             image or get nice looking effect to the entire image.</para>
            
             <para>Although the filter can use parallel processing large <see cref="P:Accord.Imaging.Filters.BilateralSmoothing.KernelSize"/> values
             (greater than 25) on high resolution images may decrease speed of processing. Also on high
             resolution images small <see cref="P:Accord.Imaging.Filters.BilateralSmoothing.KernelSize"/> values (less than 9) may not provide noticeable
             results.</para>
             
             <para>More details on the algorithm can be found by following this
             <a href="http://saplin.blogspot.com/2012/01/bilateral-image-filter-edge-preserving.html">link</a>.</para>
             
             <para>The filter accepts 8 bpp grayscale images and 24/32 bpp color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             BilateralSmoothing filter = new BilateralSmoothing( );
             filter.KernelSize    = 7;
             filter.SpatialFactor = 10;
             filter.ColorFactor   = 60;
             filter.ColorPower    = 0.5;
             // apply the filter
             filter.ApplyInPlace( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample13.png" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\bilateral.jpg" width="480" height="361" />
             </remarks>
             
        </member>
        <member name="P:Accord.Imaging.Filters.BilateralSmoothing.LimitKernelSize">
            <summary>
            Specifies if exception must be thrown in the case a large
            <see cref="P:Accord.Imaging.Filters.BilateralSmoothing.KernelSize">kernel size</see> is used which may lead
            to significant performance issues.
            </summary>
            
            <remarks>
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BilateralSmoothing.EnableParallelProcessing">
            <summary>
            Enable or not parallel processing on multi-core CPUs.
            </summary>
            
            <remarks><para>If the property is set to <see langword="true"/>, then this image processing
            routine will run in parallel on the systems with multiple core/CPUs.</para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BilateralSmoothing.KernelSize">
            <summary>
            Size of a square for limiting surrounding pixels that take part in calculations, [3, 255].
            </summary>
            
            <remarks><para>The greater the value the more is the general power of the filter. Small values
            (less than 9) on high resolution images (3000 pixels wide) do not give significant results.
            Large values increase the number of calculations and degrade performance.</para>
            
            <para><note>The value of this property must be an odd integer in the [3, 255] range if
            <see cref="P:Accord.Imaging.Filters.BilateralSmoothing.LimitKernelSize"/> is set to <see langword="false"/> or in the [3, 25] range
            otherwise.</note></para>
            
            <para>Default value is set to <b>9</b>.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentOutOfRangeException">The specified value is out of range (see
            eception message for details).</exception>
            <exception cref="T:System.ArgumentException">The value of this must be an odd integer.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BilateralSmoothing.SpatialFactor">
            <summary>
            Determines smoothing power within a color domain (neighbor pixels of similar color), >= 1.
            </summary>
            
            <remarks>
            <para>Default value is set to <b>10</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BilateralSmoothing.SpatialPower">
            <summary>
            Exponent power, used in Spatial function calculation, >= 1.
            </summary>
            
            <remarks>
            <para>Default value is set to <b>2</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BilateralSmoothing.ColorFactor">
            <summary>
            Determines the variance of color for a color domain, >= 1.
            </summary>
            
            <remarks>
            <para>Default value is set to <b>50</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BilateralSmoothing.ColorPower">
            <summary>
            Exponent power, used in Color function calculation, >= 1.
            </summary>
            
            <remarks>
            <para>Default value is set to <b>2</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BilateralSmoothing.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
             documentation for additional information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BilateralSmoothing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BilateralSmoothing"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BilateralSmoothing.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ConservativeSmoothing">
            <summary>
            Conservative smoothing.
            </summary>
            
            <remarks><para>The filter implements conservative smoothing, which is a noise reduction
            technique that derives its name from the fact that it employs a simple, fast filtering
            algorithm that sacrifices noise suppression power in order to preserve the high spatial
            frequency detail (e.g. sharp edges) in an image. It is explicitly designed to remove noise
            spikes - <b>isolated</b> pixels of exceptionally low or high pixel intensity
            (<see cref="T:Accord.Imaging.Filters.SaltAndPepperNoise">salt and pepper noise</see>).</para>
            
            <para>If the filter finds a pixel which has minimum/maximum value compared to its surrounding
            pixel, then its value is replaced by minimum/maximum value of those surrounding pixel.
            For example, lets suppose the filter uses <see cref="P:Accord.Imaging.Filters.ConservativeSmoothing.KernelSize">kernel size</see> of 3x3,
            which means each pixel has 8 surrounding pixel. If pixel's value is smaller than any value
            of surrounding pixels, then the value of the pixel is replaced by minimum value of those surrounding
            pixels.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ConservativeSmoothing filter = new ConservativeSmoothing( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample13.png" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\conservative_smoothing.png" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ConservativeSmoothing.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.ConservativeSmoothing.KernelSize">
            <summary>
            Kernel size, [3, 25].
            </summary>
            
            <remarks><para>Determines the size of pixel's square used for smoothing.</para>
            
            <para>Default value is set to <b>3</b>.</para>
            
            <para><note>The value should be odd.</note></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ConservativeSmoothing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ConservativeSmoothing"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ConservativeSmoothing.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ConservativeSmoothing"/> class.
            </summary>
            
            <param name="size">Kernel size.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ConservativeSmoothing.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Median">
            <summary>
            Median filter.
            </summary>
            
            <remarks><para>The median filter is normally used to reduce noise in an image, somewhat like
            the <see cref="T:Accord.Imaging.Filters.Mean">mean filter</see>. However, it often does a better job than the mean
            filter of preserving useful detail in the image.</para>
            
            <para>Each pixel of the original source image is replaced with the median of neighboring pixel
            values. The median is calculated by first sorting all the pixel values from the surrounding
            neighborhood into numerical order and then replacing the pixel being considered with the
            middle pixel value.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Median filter = new Median( );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample13.png" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\median.png" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Median.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.Median.Size">
            <summary>
            Processing square size for the median filter, [3, 25].
            </summary>
            
            <remarks><para>Default value is set to <b>3</b>.</para>
            
            <para><note>The value should be odd.</note></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Median.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Median"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Median.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Median"/> class.
            </summary>
            
            <param name="size">Processing square size.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Median.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.BackwardQuadrilateralTransformation">
            <summary>
            Performs backward quadrilateral transformation into an area in destination image.
            </summary>
            
            <remarks><para>The class implements backward quadrilateral transformation algorithm,
            which allows to transform any rectangular image into any quadrilateral area
            in a given destination image. The idea of the algorithm is based on homogeneous
            transformation and its math is described by Paul Heckbert in his
            "<a href="http://graphics.cs.cmu.edu/courses/15-463/2008_fall/Papers/proj.pdf">Projective Mappings for Image Warping</a>" paper.
            </para>
            
            <para>The image processing routines implements similar math to <see cref="T:Accord.Imaging.Filters.QuadrilateralTransformation"/>,
            but performs it in backward direction.</para>
            
            <para>The image processing filter accepts 8 grayscale images and 24/32 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // define quadrilateral's corners
            List&lt;IntPoint&gt; corners = new List&lt;IntPoint&gt;( );
            corners.Add( new IntPoint(  99,  99 ) );
            corners.Add( new IntPoint( 156,  79 ) );
            corners.Add( new IntPoint( 184, 126 ) );
            corners.Add( new IntPoint( 122, 150 ) );
            // create filter
            BackwardQuadrilateralTransformation filter =
                new BackwardQuadrilateralTransformation( sourceImage, corners );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Source image:</b></para>
            <img src="..\images\imaging\icon.png" width="128" height="128" />
            <para><b>Destination image:</b></para>
            <img src="..\images\imaging\sample18.jpg" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\backward_quadrilateral.jpg" width="320" height="240" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.QuadrilateralTransformation"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
             documentation for additional information.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.SourceImage">
             <summary>
             Source image to be transformed into specified quadrilateral.
             </summary>
             
             <remarks><para>The property sets the source image, which will be transformed
             to the specified quadrilateral and put into destination image the filter is applied to.</para>
             
             <para><note>The source image must have the same pixel format as a destination image the filter
             is applied to. Otherwise exception will be generated when filter is applied.</note></para>
             
             <para><note>Setting this property will clear the <see cref="P:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.SourceUnmanagedImage"/> property -
             only one source image is allowed: managed or unmanaged.</note></para>
             </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.SourceUnmanagedImage">
             <summary>
             Source unmanaged image to be transformed into specified quadrilateral.
             </summary>
             
             <remarks><para>The property sets the source image, which will be transformed
             to the specified quadrilateral and put into destination image the filter is applied to.</para>
             
             <para><note>The source image must have the same pixel format as a destination image the filter
             is applied to. Otherwise exception will be generated when filter is applied.</note></para>
             
             <para><note>Setting this property will clear the <see cref="P:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.SourceImage"/> property -
             only one source image is allowed: managed or unmanaged.</note></para>
             </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.DestinationQuadrilateral">
             <summary>
             Quadrilateral in destination image to transform into.
             </summary>
             
             <remarks><para>The property specifies 4 corners of a quadrilateral area
             in destination image where the source image will be transformed into.
             </para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.UseInterpolation">
            <summary>
            Specifies if bilinear interpolation should be used or not.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/> - interpolation
            is used.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BackwardQuadrilateralTransformation"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BackwardQuadrilateralTransformation"/> class.
            </summary>
            
            <param name="sourceImage">Source image to be transformed into specified quadrilateral
            (see <see cref="P:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.SourceImage"/>).</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BackwardQuadrilateralTransformation"/> class.
            </summary>
            
            <param name="sourceUnmanagedImage">Source unmanaged image to be transformed into specified quadrilateral
            (see <see cref="P:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.SourceUnmanagedImage"/>).</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.#ctor(System.Drawing.Bitmap,System.Collections.Generic.List{Accord.IntPoint})">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BackwardQuadrilateralTransformation"/> class.
            </summary>
            
            <param name="sourceImage">Source image to be transformed into specified quadrilateral
            (see <see cref="P:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.SourceImage"/>).</param>
            <param name="destinationQuadrilateral">Quadrilateral in destination image to transform into.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.#ctor(Accord.Imaging.UnmanagedImage,System.Collections.Generic.List{Accord.IntPoint})">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.BackwardQuadrilateralTransformation"/> class.
            </summary>
            
            <param name="sourceUnmanagedImage">Source unmanaged image to be transformed into specified quadrilateral
            (see <see cref="P:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.SourceUnmanagedImage"/>).</param>
            <param name="destinationQuadrilateral">Quadrilateral in destination image to transform into.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.BackwardQuadrilateralTransformation.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Image data to process by the filter.</param>
            
             <exception cref="T:System.NullReferenceException">Destination quadrilateral was not set.</exception>
             
        </member>
        <member name="T:Accord.Imaging.Filters.Crop">
            <summary>
            Crop an image.
            </summary>
            
            <remarks>
            <para>The filter crops an image providing a new image, which contains only the specified
            rectangle of the original image.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Crop filter = new Crop( new Rectangle( 75, 75, 320, 240 ) );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\crop.jpg" width="320" height="240" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Crop.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.Crop.Rectangle">
            <summary>
            Rectangle to crop.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Crop.#ctor(System.Drawing.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Crop"/> class.
            </summary>
            
            <param name="rect">Rectangle to crop.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Crop.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Crop.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.QuadrilateralTransformation">
            <summary>
            Performs quadrilateral transformation of an area in a given source image.
            </summary>
            
            <remarks><para>The class implements quadrilateral transformation algorithm,
            which allows to transform any quadrilateral from a given source image
            to a rectangular image. The idea of the algorithm is based on homogeneous
            transformation and its math is described by Paul Heckbert in his
            "<a href="http://graphics.cs.cmu.edu/courses/15-463/2008_fall/Papers/proj.pdf">Projective Mappings for Image Warping</a>" paper.
            </para>
            
            <para>The image processing filter accepts 8 grayscale images and 24/32 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // define quadrilateral's corners
            List&lt;IntPoint&gt; corners = new List&lt;IntPoint&gt;( );
            corners.Add( new IntPoint(  99,  99 ) );
            corners.Add( new IntPoint( 156,  79 ) );
            corners.Add( new IntPoint( 184, 126 ) );
            corners.Add( new IntPoint( 122, 150 ) );
            // create filter
            QuadrilateralTransformation filter =
                new QuadrilateralTransformation( corners, 200, 200 );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample18.jpg" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\quadrilateral_ex_bilinear.png" width="200" height="200" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.BackwardQuadrilateralTransformation"/>
            <seealso cref="T:Accord.Imaging.Filters.SimpleQuadrilateralTransformation"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformation.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="F:Accord.Imaging.Filters.QuadrilateralTransformation.newWidth">
            <summary>
            New image width.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.QuadrilateralTransformation.newHeight">
            <summary>
            New image height.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformation.AutomaticSizeCalculaton">
            <summary>
            Automatic calculation of destination image or not.
            </summary>
            
            <remarks><para>The property specifies how to calculate size of destination (transformed)
            image. If the property is set to <see langword="false"/>, then <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformation.NewWidth"/>
            and <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformation.NewHeight"/> properties have effect and destination image's size is
            specified by user. If the property is set to <see langword="true"/>, then setting the above
            mentioned properties does not have any effect, but destionation image's size is
            automatically calculated from <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformation.SourceQuadrilateral"/> property - width and height
            come from length of longest edges.
            </para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformation.SourceQuadrilateral">
            <summary>
            Quadrilateral's corners in source image.
            </summary>
            
            <remarks><para>The property specifies four corners of the quadrilateral area
            in the source image to be transformed.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformation.NewWidth">
            <summary>
            Width of the new transformed image.
            </summary>
            
            <remarks><para>The property defines width of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformation.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's width
            is calculated automatically based on <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformation.SourceQuadrilateral"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformation.NewHeight">
            <summary>
            Height of the new transformed image.
            </summary>
            
            <remarks><para>The property defines height of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformation.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's height
            is calculated automatically based on <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformation.SourceQuadrilateral"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformation.UseInterpolation">
            <summary>
            Specifies if bilinear interpolation should be used or not.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/> - interpolation
            is used.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.QuadrilateralTransformation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.QuadrilateralTransformation"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.QuadrilateralTransformation.#ctor(System.Collections.Generic.List{Accord.IntPoint},System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.QuadrilateralTransformation"/> class.
            </summary>
            
            <param name="sourceQuadrilateral">Corners of the source quadrilateral area.</param>
            <param name="newWidth">Width of the new transformed image.</param>
            <param name="newHeight">Height of the new transformed image.</param>
            
            <remarks><para>This constructor sets <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformation.AutomaticSizeCalculaton"/> to
            <see langword="false"/>, which means that destination image will have width and
            height as specified by user.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.QuadrilateralTransformation.#ctor(System.Collections.Generic.List{Accord.IntPoint})">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.QuadrilateralTransformation"/> class.
             </summary>
             
             <param name="sourceQuadrilateral">Corners of the source quadrilateral area.</param>
             
             <remarks><para>This constructor sets <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformation.AutomaticSizeCalculaton"/> to
             <see langword="true"/>, which means that destination image will have width and
             height automatically calculated based on <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformation.SourceQuadrilateral"/> property.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.QuadrilateralTransformation.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
            <exception cref="T:System.NullReferenceException">Source quadrilateral was not set.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.QuadrilateralTransformation.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.QuadrilateralTransformationBilinear">
            <summary>
            Performs quadrilateral transformation using bilinear algorithm for interpolation.
            </summary>
            
            <remarks><para>The class is deprecated and <see cref="T:Accord.Imaging.Filters.SimpleQuadrilateralTransformation"/> should be used instead.</para>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.SimpleQuadrilateralTransformation"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.AutomaticSizeCalculaton">
            <summary>
            Automatic calculation of destination image or not.
            </summary>
            
            <remarks><para>The property specifies how to calculate size of destination (transformed)
            image. If the property is set to <see langword="false"/>, then <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.NewWidth"/>
            and <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.NewHeight"/> properties have effect and destination image's size is
            specified by user. If the property is set to <see langword="true"/>, then setting the above
            mentioned properties does not have any effect, but destionation image's size is
            automatically calculated from <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.SourceCorners"/> property - width and height
            come from length of longest edges.
            </para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.SourceCorners">
            <summary>
            Quadrilateral's corners in source image.
            </summary>
            
            <remarks><para>The property specifies four corners of the quadrilateral area
            in the source image to be transformed.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.NewWidth">
            <summary>
            Width of the new transformed image.
            </summary>
            
            <remarks><para>The property defines width of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's width
            is calculated automatically based on <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.SourceCorners"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.NewHeight">
            <summary>
            Height of the new transformed image.
            </summary>
            
            <remarks><para>The property defines height of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's height
            is calculated automatically based on <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.SourceCorners"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.#ctor(System.Collections.Generic.List{Accord.IntPoint},System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.QuadrilateralTransformationBilinear"/> class.
            </summary>
            
            <param name="sourceCorners">Corners of the source quadrilateral area.</param>
            <param name="newWidth">Width of the new transformed image.</param>
            <param name="newHeight">Height of the new transformed image.</param>
            
            <remarks><para>This constructor sets <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.AutomaticSizeCalculaton"/> to
            <see langword="false"/>, which means that destination image will have width and
            height as specified by user.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.#ctor(System.Collections.Generic.List{Accord.IntPoint})">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.QuadrilateralTransformationBilinear"/> class.
             </summary>
             
             <param name="sourceCorners">Corners of the source quadrilateral area.</param>
             
             <remarks><para>This constructor sets <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.AutomaticSizeCalculaton"/> to
             <see langword="true"/>, which means that destination image will have width and
             height automatically calculated based on <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.SourceCorners"/> property.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.QuadrilateralTransformationBilinear.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
            <exception cref="T:System.ArgumentException">The specified quadrilateral's corners are outside of the given image.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor">
             <summary>
             Performs quadrilateral transformation using nearest neighbor algorithm for interpolation.
             </summary>
             
             <remarks><para>The class is deprecated and <see cref="T:Accord.Imaging.Filters.SimpleQuadrilateralTransformation"/> should be used instead.</para>
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.SimpleQuadrilateralTransformation"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.AutomaticSizeCalculaton">
            <summary>
            Automatic calculation of destination image or not.
            </summary>
            
            <remarks><para>The property specifies how to calculate size of destination (transformed)
            image. If the property is set to <see langword="false"/>, then <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.NewWidth"/>
            and <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.NewHeight"/> properties have effect and destination image's size is
            specified by user. If the property is set to <see langword="true"/>, then setting the above
            mentioned properties does not have any effect, but destionation image's size is
            automatically calculated from <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.SourceCorners"/> property - width and height
            come from length of longest edges.
            </para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.SourceCorners">
            <summary>
            Quadrilateral's corners in source image.
            </summary>
            
            <remarks><para>The property specifies four corners of the quadrilateral area
            in the source image to be transformed.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.NewWidth">
            <summary>
            Width of the new transformed image.
            </summary>
            
            <remarks><para>The property defines width of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's width
            is calculated automatically based on <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.SourceCorners"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.NewHeight">
            <summary>
            Height of the new transformed image.
            </summary>
            
            <remarks><para>The property defines height of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's height
            is calculated automatically based on <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.SourceCorners"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.#ctor(System.Collections.Generic.List{Accord.IntPoint},System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor"/> class.
            </summary>
            
            <param name="sourceCorners">Corners of the source quadrilateral area.</param>
            <param name="newWidth">Width of the new transformed image.</param>
            <param name="newHeight">Height of the new transformed image.</param>
            
            <remarks><para>This constructor sets <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.AutomaticSizeCalculaton"/> to
            <see langword="false"/>, which means that destination image will have width and
            height as specified by user.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.#ctor(System.Collections.Generic.List{Accord.IntPoint})">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor"/> class.
             </summary>
             
             <param name="sourceCorners">Corners of the source quadrilateral area.</param>
             
             <remarks><para>This constructor sets <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.AutomaticSizeCalculaton"/> to
             <see langword="true"/>, which means that destination image will have width and
             height automatically calculated based on <see cref="P:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.SourceCorners"/> property.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.QuadrilateralTransformationNearestNeighbor.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
            <exception cref="T:System.ArgumentException">The specified quadrilateral's corners are outside of the given image.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ResizeBicubic">
             <summary>
             Resize image using bicubic interpolation algorithm.
             </summary>
             
             <remarks><para>The class implements image resizing filter using bicubic
             interpolation algorithm. It uses bicubic kernel W(x) as described on
             <a href="http://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm">Wikipedia</a>
             (coefficient <b>a</b> is set to <b>-0.5</b>).</para>
             
             <para>The filter accepts 8 grayscale images and 24 bpp
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             ResizeBicubic filter = new ResizeBicubic( 400, 300 );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample9.png" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\resize_bicubic.png" width="400" height="300" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.ResizeNearestNeighbor"/>
             <seealso cref="T:Accord.Imaging.Filters.ResizeBilinear"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ResizeBicubic.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.ResizeBicubic.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ResizeBicubic"/> class.
            </summary>
            
            <param name="newWidth">Width of new image.</param>
            <param name="newHeight">Height of new image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ResizeBicubic.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ResizeBilinear">
             <summary>
             Resize image using bilinear interpolation algorithm.
             </summary>
             
             <remarks><para>The class implements image resizing filter using bilinear
             interpolation algorithm.</para>
             
             <para>The filter accepts 8 grayscale images and 24/32 bpp
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create filter
             ResizeBilinear filter = new ResizeBilinear( 400, 300 );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample9.png" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\resize_bilinear.png" width="400" height="300" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.ResizeNearestNeighbor"/>
             <seealso cref="T:Accord.Imaging.Filters.ResizeBicubic"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ResizeBilinear.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.ResizeBilinear.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ResizeBilinear"/> class.
            </summary>
            
            <param name="newWidth">Width of the new image.</param>
            <param name="newHeight">Height of the new image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ResizeBilinear.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ResizeNearestNeighbor">
            <summary>
            Resize image using nearest neighbor algorithm.
            </summary>
            
            <remarks><para>The class implements image resizing filter using nearest
            neighbor algorithm, which does not assume any interpolation.</para>
            
            <para>The filter accepts 8 and 16 bpp grayscale images and 24, 32, 48 and 64 bpp
            color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            ResizeNearestNeighbor filter = new ResizeNearestNeighbor( 400, 300 );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample9.png" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\resize_nearest.png" width="400" height="300" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.ResizeBilinear"/>
            <seealso cref="T:Accord.Imaging.Filters.ResizeBicubic"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ResizeNearestNeighbor.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.ResizeNearestNeighbor.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.ResizeNearestNeighbor"/> class.
            </summary>
            
            <param name="newWidth">Width of the new image.</param>
            <param name="newHeight">Height of the new image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ResizeNearestNeighbor.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.RotateBicubic">
             <summary>
             Rotate image using bicubic interpolation.
             </summary>
             
             <remarks><para>The class implements image rotation filter using bicubic
             interpolation algorithm. It uses bicubic kernel W(x) as described on
             <a href="http://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm">Wikipedia</a>
             (coefficient <b>a</b> is set to <b>-0.5</b>).</para>
             
             <para><note>Rotation is performed in counterclockwise direction.</note></para>
             
             <para>The filter accepts 8 bpp grayscale images and 24 bpp
             color images for processing.</para>
            
             <para>Sample usage:</para>
             <code>
             // create filter - rotate for 30 degrees keeping original image size
             RotateBicubic filter = new RotateBicubic( 30, true );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample9.png" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\rotate_bicubic.png" width="320" height="240" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.RotateBilinear"/>
             <seealso cref="T:Accord.Imaging.Filters.RotateNearestNeighbor"/>
             
        </member>
        <member name="P:Accord.Imaging.Filters.RotateBicubic.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.RotateBicubic.#ctor(System.Double)">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.RotateBicubic"/> class.
             </summary>
             
             <param name="angle">Rotation angle.</param>
             
             <remarks><para>This constructor sets <see cref="P:Accord.Imaging.Filters.BaseRotateFilter.KeepSize"/> property
             to <see langword="false"/>.</para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RotateBicubic.#ctor(System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.RotateBicubic"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            <param name="keepSize">Keep image size or not.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RotateBicubic.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="sourceData">Source image data.</param>
             <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.RotateBilinear">
             <summary>
             Rotate image using bilinear interpolation.
             </summary>
             
             <para><note>Rotation is performed in counterclockwise direction.</note></para>
             
             <remarks><para>The class implements image rotation filter using bilinear
             interpolation algorithm.</para>
             
             <para>The filter accepts 8 bpp grayscale images and 24 bpp
             color images for processing.</para>
            
             <para>Sample usage:</para>
             <code>
             // create filter - rotate for 30 degrees keeping original image size
             RotateBilinear filter = new RotateBilinear( 30, true );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample9.png" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\rotate_bilinear.png" width="320" height="240" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.RotateNearestNeighbor"/>
             <seealso cref="T:Accord.Imaging.Filters.RotateBicubic"/>
             
        </member>
        <member name="P:Accord.Imaging.Filters.RotateBilinear.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.RotateBilinear.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.RotateBilinear"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            
            <remarks><para>This constructor sets <see cref="P:Accord.Imaging.Filters.BaseRotateFilter.KeepSize"/> property
            to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RotateBilinear.#ctor(System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.RotateBilinear"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            <param name="keepSize">Keep image size or not.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RotateBilinear.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="sourceData">Source image data.</param>
             <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Shrink">
            <summary>
            Shrink an image by removing specified color from its boundaries.
            </summary>
            
            <remarks><para>Removes pixels with specified color from image boundaries making
            the image smaller in size.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            Shrink filter = new Shrink( Color.Black );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample2.jpg" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\shrink.jpg" width="295" height="226" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Shrink.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.Shrink.ColorToRemove">
            <summary>
            Color to remove from boundaries.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Shrink.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Shrink"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Shrink.#ctor(System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Shrink"/> class.
            </summary>
            
            <param name="colorToRemove">Color to remove from boundaries.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Shrink.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Shrink.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.SimpleQuadrilateralTransformation">
             <summary>
             Performs quadrilateral transformation of an area in the source image.
             </summary>
             
             <remarks><para>The class implements simple algorithm described by
             <a href="http://www.codeguru.com/forum/showpost.php?p=1186454&amp;postcount=2">Olivier Thill</a>
             for transforming quadrilateral area from a source image into rectangular image.
             The idea of the algorithm is based on finding for each line of destination
             rectangular image a corresponding line connecting "left" and "right" sides of
             quadrilateral in a source image. Then the line is linearly transformed into the
             line in destination image.</para>
             
             <para><note>Due to simplicity of the algorithm it does not do any correction for perspective.
             </note></para>
             
             <para><note>To make sure the algorithm works correctly, it is preferred if the
             "left-top" corner of the quadrilateral (screen coordinates system) is
             specified first in the list of quadrilateral's corners. At least
             user need to make sure that the "left" side (side connecting first and the last
             corner) and the "right" side (side connecting second and third corners) are
             not horizontal.</note></para>
             
             <para>Use <see cref="T:Accord.Imaging.Filters.QuadrilateralTransformation"/> to avoid the above mentioned limitations,
             which is a more advanced quadrilateral transformation algorithms (although a bit more
             computationally expensive).</para>
             
             <para>The image processing filter accepts 8 grayscale images and 24/32 bpp
             color images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // define quadrilateral's corners
             List&lt;IntPoint&gt; corners = new List&lt;IntPoint&gt;( );
             corners.Add( new IntPoint(  99,  99 ) );
             corners.Add( new IntPoint( 156,  79 ) );
             corners.Add( new IntPoint( 184, 126 ) );
             corners.Add( new IntPoint( 122, 150 ) );
             // create filter
             SimpleQuadrilateralTransformation filter =
                 new SimpleQuadrilateralTransformation( corners, 200, 200 );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample18.jpg" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\quadrilateral_bilinear.png" width="200" height="200" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.QuadrilateralTransformation"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="F:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.newWidth">
            <summary>
            New image width.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.newHeight">
            <summary>
            New image height.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.AutomaticSizeCalculaton">
            <summary>
            Automatic calculation of destination image or not.
            </summary>
            
            <remarks><para>The property specifies how to calculate size of destination (transformed)
            image. If the property is set to <see langword="false"/>, then <see cref="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.NewWidth"/>
            and <see cref="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.NewHeight"/> properties have effect and destination image's size is
            specified by user. If the property is set to <see langword="true"/>, then setting the above
            mentioned properties does not have any effect, but destionation image's size is
            automatically calculated from <see cref="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.SourceQuadrilateral"/> property - width and height
            come from length of longest edges.
            </para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.SourceQuadrilateral">
            <summary>
            Quadrilateral's corners in source image.
            </summary>
            
            <remarks><para>The property specifies four corners of the quadrilateral area
            in the source image to be transformed.</para>
            
            <para>See documentation to the <see cref="T:Accord.Imaging.Filters.SimpleQuadrilateralTransformation"/>
            class itself for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.NewWidth">
            <summary>
            Width of the new transformed image.
            </summary>
            
            <remarks><para>The property defines width of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's width
            is calculated automatically based on <see cref="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.SourceQuadrilateral"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.NewHeight">
            <summary>
            Height of the new transformed image.
            </summary>
            
            <remarks><para>The property defines height of the destination image, which gets
            transformed quadrilateral image.</para>
            
            <para><note>Setting the property does not have any effect, if <see cref="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.AutomaticSizeCalculaton"/>
            property is set to <see langword="true"/>. In this case destination image's height
            is calculated automatically based on <see cref="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.SourceQuadrilateral"/> property.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.UseInterpolation">
            <summary>
            Specifies if bilinear interpolation should be used or not.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/> - interpolation
            is used.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SimpleQuadrilateralTransformation"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.#ctor(System.Collections.Generic.List{Accord.IntPoint},System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SimpleQuadrilateralTransformation"/> class.
            </summary>
            
            <param name="sourceQuadrilateral">Corners of the source quadrilateral area.</param>
            <param name="newWidth">Width of the new transformed image.</param>
            <param name="newHeight">Height of the new transformed image.</param>
            
            <remarks><para>This constructor sets <see cref="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.AutomaticSizeCalculaton"/> to
            <see langword="false"/>, which means that destination image will have width and
            height as specified by user.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.#ctor(System.Collections.Generic.List{Accord.IntPoint})">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SimpleQuadrilateralTransformation"/> class.
             </summary>
             
             <param name="sourceQuadrilateral">Corners of the source quadrilateral area.</param>
             
             <remarks><para>This constructor sets <see cref="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.AutomaticSizeCalculaton"/> to
             <see langword="true"/>, which means that destination image will have width and
             height automatically calculated based on <see cref="P:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.SourceQuadrilateral"/> property.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
            <exception cref="T:System.NullReferenceException">Source quadrilateral was not set.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SimpleQuadrilateralTransformation.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.TransformFromPolar">
            <summary>
            Transform polar image into rectangle.
            </summary>
            
            <remarks>The image processing routine is opposite transformation to the one done by <see cref="T:Accord.Imaging.Filters.TransformToPolar"/>
            routine, i.e. transformation from polar image into rectangle. The produced effect is similar to GIMP's
            "Polar Coordinates" distortion filter (or its equivalent in Photoshop).
            
            <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            TransformFromPolar filter = new TransformFromPolar( );
            filter.OffsetAngle = 0;
            filter.CirlceDepth = 1;
            filter.UseOriginalImageSize = false;
            filter.NewSize = new Size( 360, 120 );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample22.png" width="240" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\from_polar.png" width="360" height="120" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.TransformToPolar"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformFromPolar.CirlceDepth">
            <summary>
            Circularity coefficient of the mapping, [0, 1].
            </summary>
            
            <remarks><para>The property specifies circularity coefficient of the mapping to be done.
            If the coefficient is set to 1, then destination image will be produced by mapping
            ideal circle from the source image, which is placed in source image's centre and its
            radius equals to the minimum distance from centre to the imageâs edge. If the coefficient
            is set to 0, then the mapping will use entire area of the source image (circle will
            be extended into direction of edges). Changing the property from 0 to 1 user may balance
            circularity of the produced output.</para>
            
            <para>Default value is set to <b>1</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformFromPolar.OffsetAngle">
            <summary>
            Offset angle used to shift mapping, [-360, 360] degrees.
            </summary>
            
            <remarks><para>The property specifies offset angle, which can be used to shift
            mapping in clockwise direction. For example, if user sets this property to 30, then
            start of polar mapping is shifted by 30 degrees in clockwise direction.</para>
            
            <para>Default value is set to <b>0</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformFromPolar.MapBackwards">
             <summary>
             Specifies direction of mapping.
             </summary>
            
             <remarks><para>The property specifies direction of mapping source image. If the
             property is set to <see langword="false"/>, the image is mapped in clockwise direction;
             otherwise in counter clockwise direction.</para>
             
             <para>Default value is set to <see langword="false"/>.</para>
             </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformFromPolar.MapFromTop">
            <summary>
            Specifies if centre of the source image should to top or bottom of the result image.
            </summary>
            
            <remarks><para>The property specifies position of the source image's centre in the destination image.
            If the property is set to <see langword="true"/>, then it goes to the top of the result image;
            otherwise it goes to the bottom.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformFromPolar.NewSize">
            <summary>
            Size of destination image.
            </summary>
            
            <remarks><para>The property specifies size of result image produced by this image
            processing routine in the case if <see cref="P:Accord.Imaging.Filters.TransformFromPolar.UseOriginalImageSize"/> property
            is set to <see langword="false"/>.</para>
            
            <para><note>Both width and height must be in the [1, 10000] range.</note></para>
            
            <para>Default value is set to <b>200 x 200</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformFromPolar.UseOriginalImageSize">
            <summary>
            Use source image size for destination or not.
            </summary>
            
            <remarks><para>The property specifies if the image processing routine should create destination
            image of the same size as original image or of the size specified by <see cref="P:Accord.Imaging.Filters.TransformFromPolar.NewSize"/>
            property.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformFromPolar.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TransformFromPolar.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.TransformFromPolar"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TransformFromPolar.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TransformFromPolar.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.TransformToPolar">
            <summary>
            Transform rectangle image into circle (to polar coordinates).
            </summary>
            
            <remarks><para>The image processing routine does transformation of the source image into
            circle (polar transformation). The produced effect is similar to GIMP's "Polar Coordinates"
            distortion filter (or its equivalent in Photoshop).
            </para>
            
            <para>The filter accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            TransformToPolar filter = new TransformToPolar( );
            filter.OffsetAngle = 0;
            filter.CirlceDepth = 1;
            filter.UseOriginalImageSize = false;
            filter.NewSize = new Size( 200, 200 );
            // apply the filter
            Bitmap newImage = filter.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample21.png" width="320" height="160" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\polar.png" width="200" height="200" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.TransformFromPolar"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformToPolar.CirlceDepth">
            <summary>
            Circularity coefficient of the mapping, [0, 1].
            </summary>
            
            <remarks><para>The property specifies circularity coefficient of the mapping to be done.
            If the coefficient is set to 1, then the mapping will produce ideal circle. If the coefficient
            is set to 0, then the mapping will occupy entire area of the destination image (circle will
            be extended into direction of edges). Changing the property from 0 to 1 user may balance
            circularity of the produced output.
            </para>
            
            <para>Default value is set to <b>1</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformToPolar.OffsetAngle">
            <summary>
            Offset angle used to shift mapping, [-360, 360] degrees.
            </summary>
            
            <remarks><para>The property specifies offset angle, which can be used to shift
            mapping in counter clockwise direction. For example, if user sets this property to 30, then
            start of polar mapping is shifted by 30 degrees in counter clockwise direction.</para>
            
            <para>Default value is set to <b>0</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformToPolar.MapBackwards">
             <summary>
             Specifies direction of mapping.
             </summary>
            
             <remarks><para>The property specifies direction of mapping source image's X axis. If the
             property is set to <see langword="false"/>, the image is mapped in clockwise direction;
             otherwise in counter clockwise direction.</para>
             
             <para>Default value is set to <see langword="false"/>.</para>
             </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformToPolar.MapFromTop">
            <summary>
            Specifies if top of the source image should go to center or edge of the result image.
            </summary>
            
            <remarks><para>The property specifies position of the source image's top line in the destination
            image. If the property is set to <see langword="true"/>, then it goes to the center of the result image;
            otherwise it goes to the edge.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformToPolar.FillColor">
            <summary>
            Fill color to use for unprocessed areas.
            </summary>
            
            <remarks><para>The property specifies fill color, which is used to fill unprocessed areas.
            In the case if <see cref="P:Accord.Imaging.Filters.TransformToPolar.CirlceDepth"/> is greater than 0, then there will be some areas on
            the image's edge, which are not filled by the produced "circular" image, but are filled by
            the specified color.
            </para>
            
            <para>Default value is set to <see cref="P:System.Drawing.Color.White"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformToPolar.NewSize">
            <summary>
            Size of destination image.
            </summary>
            
            <remarks><para>The property specifies size of result image produced by this image
            processing routine in the case if <see cref="P:Accord.Imaging.Filters.TransformToPolar.UseOriginalImageSize"/> property
            is set to <see langword="false"/>.</para>
            
            <para><note>Both width and height must be in the [1, 10000] range.</note></para>
            
            <para>Default value is set to <b>200 x 200</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformToPolar.UseOriginalImageSize">
            <summary>
            Use source image size for destination or not.
            </summary>
            
            <remarks><para>The property specifies if the image processing routine should create destination
            image of the same size as original image or of the size specified by <see cref="P:Accord.Imaging.Filters.TransformToPolar.NewSize"/>
            property.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.TransformToPolar.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
            <remarks><para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/>
            documentation for additional information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TransformToPolar.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.TransformToPolar"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TransformToPolar.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
            Calculates new image size.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            
            <returns>New image size - size of the destination image.</returns>
            
        </member>
        <member name="M:Accord.Imaging.Filters.TransformToPolar.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.YCbCrExtractChannel">
            <summary>
            Extract YCbCr channel from image.
            </summary>
            
            <remarks><para>The filter extracts specified YCbCr channel of color image and returns
            it in the form of grayscale image.</para>
            
            <para>The filter accepts 24 and 32 bpp color images and produces
            8 bpp grayscale images.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            YCbCrExtractChannel filter = new YCbCrExtractChannel( YCbCr.CrIndex );
            // apply the filter
            Bitmap crChannel = filter.Apply( image );
            </code>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.YCbCrReplaceChannel"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrExtractChannel.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrExtractChannel.Channel">
            <summary>
            YCbCr channel to extract.
            </summary>
            
            <remarks><para>Default value is set to <see cref="F:Accord.Imaging.YCbCr.YIndex"/> (Y channel).</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid channel was specified.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.YCbCrExtractChannel.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.YCbCrExtractChannel"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.YCbCrExtractChannel.#ctor(System.Int16)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.YCbCrExtractChannel"/> class.
            </summary>
            
            <param name="channel">YCbCr channel to extract.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.YCbCrExtractChannel.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.YCbCrFiltering">
            <summary>
            Color filtering in YCbCr color space.
            </summary>
            
            <remarks><para>The filter operates in <b>YCbCr</b> color space and filters
            pixels, which color is inside/outside of the specified YCbCr range - 
            it keeps pixels with colors inside/outside of the specified range and fills the
            rest with <see cref="P:Accord.Imaging.Filters.YCbCrFiltering.FillColor">specified color</see>.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            YCbCrFiltering filter = new YCbCrFiltering( );
            // set color ranges to keep
            filter.Cb = new Range( -0.2f, 0.0f );
            filter.Cr = new Range( 0.26f, 0.5f );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\ycbcr_filtering.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.ColorFiltering"/>
            <seealso cref="T:Accord.Imaging.Filters.HSLFiltering"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrFiltering.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrFiltering.Y">
            <summary>
            Range of Y component, [0, 1].
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrFiltering.Cb">
            <summary>
            Range of Cb component, [-0.5, 0.5].
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrFiltering.Cr">
            <summary>
            Range of Cr component, [-0.5, 0.5].
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrFiltering.FillColor">
            <summary>
            Fill color used to fill filtered pixels.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrFiltering.FillOutsideRange">
            <summary>
            Determines, if pixels should be filled inside or outside specified
            color range.
            </summary>
            
            <remarks><para>Default value is set to <see langword="true"/>, which means
            the filter removes colors outside of the specified range.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrFiltering.UpdateY">
            <summary>
            Determines, if Y value of filtered pixels should be updated.
            </summary>
            
            <remarks><para>The property specifies if Y channel of filtered pixels should be
            updated with value from <see cref="P:Accord.Imaging.Filters.YCbCrFiltering.FillColor">fill color</see> or not.</para>
            
            <para>Default value is set to <see langword="true"/>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrFiltering.UpdateCb">
            <summary>
            Determines, if Cb value of filtered pixels should be updated.
            </summary>
            
            <remarks><para>The property specifies if Cb channel of filtered pixels should be
            updated with value from <see cref="P:Accord.Imaging.Filters.YCbCrFiltering.FillColor">fill color</see> or not.</para>
            
            <para>Default value is set to <see langword="true"/>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrFiltering.UpdateCr">
            <summary>
            Determines, if Cr value of filtered pixels should be updated.
            </summary>
            
            <remarks><para>The property specifies if Cr channel of filtered pixels should be
            updated with value from <see cref="P:Accord.Imaging.Filters.YCbCrFiltering.FillColor">fill color</see> or not.</para>
            
            <para>Default value is set to <see langword="true"/>.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.YCbCrFiltering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.YCbCrFiltering"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.YCbCrFiltering.#ctor(Accord.Range,Accord.Range,Accord.Range)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.YCbCrFiltering"/> class.
            </summary>
            
            <param name="yRange">Range of Y component.</param>
            <param name="cbRange">Range of Cb component.</param>
            <param name="crRange">Range of Cr component.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.YCbCrFiltering.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.YCbCrLinear">
            <summary>
            Linear correction of YCbCr channels.
            </summary>
            
            <remarks><para>The filter operates in <b>YCbCr</b> color space and provides
            with the facility of linear correction of its channels - mapping specified channels'
            input ranges to specified output ranges.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            YCbCrLinear filter = new YCbCrLinear( );
            // configure the filter
            filter.InCb = new Range( -0.276f, 0.163f );
            filter.InCr = new Range( -0.202f, 0.500f );
            // apply the filter
            filter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\ycbcr_linear.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.HSLLinear"/>
            <seealso cref="T:Accord.Imaging.Filters.YCbCrLinear"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrLinear.InY">
             <summary>
             Y component's input range.
             </summary>
             
             <remarks>Y component is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrLinear.InCb">
             <summary>
             Cb component's input range.
             </summary>
             
             <remarks>Cb component is measured in the range of [-0.5, 0.5].</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrLinear.InCr">
             <summary>
             Cr component's input range.
             </summary>
             
             <remarks>Cr component is measured in the range of [-0.5, 0.5].</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrLinear.OutY">
             <summary>
             Y component's output range.
             </summary>
             
             <remarks>Y component is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrLinear.OutCb">
             <summary>
             Cb component's output range.
             </summary>
             
             <remarks>Cb component is measured in the range of [-0.5, 0.5].</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrLinear.OutCr">
             <summary>
             Cr component's output range.
             </summary>
             
             <remarks>Cr component is measured in the range of [-0.5, 0.5].</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrLinear.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.YCbCrLinear.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.YCbCrLinear"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.YCbCrLinear.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.YCbCrReplaceChannel">
            <summary>
            Replace channel of YCbCr color space.
            </summary>
            
            <remarks><para>Replaces specified YCbCr channel of color image with
            specified grayscale imge.</para>
            
            <para>The filter is quite useful in conjunction with <see cref="T:Accord.Imaging.Filters.YCbCrExtractChannel"/> filter
            (however may be used alone in some cases). Using the <see cref="T:Accord.Imaging.Filters.YCbCrExtractChannel"/> filter
            it is possible to extract one of YCbCr channel, perform some image processing with it and then
            put it back into the original color image.</para>
            
            <para>The filter accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create YCbCrExtractChannel filter for channel extracting
            YCbCrExtractChannel extractFilter = new YCbCrExtractChannel(
                                                YCbCr.CbIndex );
            // extract Cb channel
            Bitmap cbChannel = extractFilter.Apply( image );
            // invert the channel
            Invert invertFilter = new Invert( );
            invertFilter.ApplyInPlace( cbChannel );
            // put the channel back into the source image
            YCbCrReplaceChannel replaceFilter = new YCbCrReplaceChannel(
                                                YCbCr.CbIndex, cbChannel );
            replaceFilter.ApplyInPlace( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\ycbcr_replace_channel.jpg" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Filters.YCbCrExtractChannel"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrReplaceChannel.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrReplaceChannel.Channel">
            <summary>
            YCbCr channel to replace.
            </summary>
            
            <remarks><para>Default value is set to <see cref="F:Accord.Imaging.YCbCr.YIndex"/> (Y channel).</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid channel was specified.</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrReplaceChannel.ChannelImage">
            <summary>
            Grayscale image to use for channel replacement.
            </summary>
            
            <remarks>
            <para><note>Setting this property will clear the <see cref="P:Accord.Imaging.Filters.YCbCrReplaceChannel.UnmanagedChannelImage"/> property -
            only one channel image is allowed: managed or unmanaged.</note></para>
            </remarks>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Channel image should be 8bpp indexed image (grayscale).</exception>
            
        </member>
        <member name="P:Accord.Imaging.Filters.YCbCrReplaceChannel.UnmanagedChannelImage">
            <summary>
            Unmanaged grayscale image to use for channel replacement.
            </summary>
            
            <remarks>
            <para><note>Setting this property will clear the <see cref="P:Accord.Imaging.Filters.YCbCrReplaceChannel.ChannelImage"/> property -
            only one channel image is allowed: managed or unmanaged.</note></para>
            </remarks>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Channel image should be 8bpp indexed image (grayscale).</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.YCbCrReplaceChannel.#ctor(System.Int16)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.YCbCrReplaceChannel"/> class.
            </summary>
            
            <param name="channel">YCbCr channel to replace.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.YCbCrReplaceChannel.#ctor(System.Int16,System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.YCbCrReplaceChannel"/> class.
            </summary>
            
            <param name="channel">YCbCr channel to replace.</param>
            <param name="channelImage">Channel image to use for replacement.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.YCbCrReplaceChannel.#ctor(System.Int16,Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.YCbCrReplaceChannel"/> class.
            </summary>
            
            <param name="channel">YCbCr channel to replace.</param>
            <param name="channelImage">Unmanaged channel image to use for replacement.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.YCbCrReplaceChannel.ProcessFilter(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
             <param name="rect">Image rectangle for processing by the filter.</param>
             
             <exception cref="T:System.NullReferenceException">Channel image was not specified.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Channel image size does not match source
             image size.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Filters.DifferenceOfGaussians">
             <summary>
               Difference of Gaussians filter.
             </summary>
             
             <remarks>
             <para>
               In imaging science, the difference of Gaussians is a feature 
               enhancement algorithm that involves the subtraction of one blurred 
               version of an original image from another, less blurred version of 
               the original. </para>
               
             <para>
               In the simple case of grayscale images, the blurred images are 
               obtained by convolving the original grayscale images with Gaussian
               kernels having differing standard deviations. Blurring an image using
               a Gaussian kernel suppresses only high-frequency spatial information.
               Subtracting one image from the other preserves spatial information that
               lies between the range of frequencies that are preserved in the two blurred
               images. Thus, the difference of Gaussians is a band-pass filter that 
               discards all but a handful of spatial frequencies that are present in the
               original grayscale image.</para>
               
             <para>
              This filter implementation has been contributed by Diego Catalano.</para>
               
             <para>
               References:
               <list type="bullet">
                 <item><description>
                    Wikipedia contributors. "Difference of Gaussians." Wikipedia, The Free 
                    Encyclopedia. Wikipedia, The Free Encyclopedia, 1 Jun. 2013. Web. 10 Feb.
                    2014.</description></item>
               </list></para>   
             </remarks>
            
             <example>
             <code>
               Bitmap image = ... // Lena's famous picture
             
               // Create a new Difference of Gaussians
               var DoG = new DifferenceOfGaussians();
             
               // Apply the filter
               Bitmap result = DoG.Apply(image);
               
               // Show on the screen
               ImageBox.Show(result);
             </code>
             
             <para>
               The resulting image is shown below. </para>
               
             <img src="..\images\differenceOfGaussians.png" /> 
            
             </example>
             
        </member>
        <member name="P:Accord.Imaging.Filters.DifferenceOfGaussians.First">
            <summary>
              Gets or sets the first Gaussian filter.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.DifferenceOfGaussians.Second">
            <summary>
              Gets or sets the second Gaussian filter.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.DifferenceOfGaussians.Subtract">
            <summary>
              Gets or sets the subtract filter used to compute
              the difference of the two Gaussian blurs.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.DifferenceOfGaussians.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.DifferenceOfGaussians.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.DifferenceOfGaussians"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.DifferenceOfGaussians.#ctor(System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.DifferenceOfGaussians"/> class.
            </summary>
            
            <param name="windowSize1">The first window size. Default is 3</param>
            <param name="windowSize2">The second window size. Default is 4.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.DifferenceOfGaussians.#ctor(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.DifferenceOfGaussians"/> class.
            </summary>
            
            <param name="windowSize1">The window size for the first Gaussian. Default is 3</param>
            <param name="windowSize2">The window size for the second Gaussian. Default is 4.</param>
            
            <param name="sigma1">The sigma for the first Gaussian. Default is 0.4.</param>
            <param name="sigma2">The sigma for the second Gaussian. Default is 0.4</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.DifferenceOfGaussians.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.DifferenceOfGaussians"/> class.
            </summary>
            
            <param name="windowSize1">The window size for the first Gaussian. Default is 3</param>
            <param name="windowSize2">The window size for the second Gaussian. Default is 4.</param>
            
            <param name="sigma">The sigma for both Gaussian filters. Default is 0.4.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.DifferenceOfGaussians.ProcessFilter(Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.FastVariance">
            <summary>
              Fast Variance filter.
            </summary>
            
            <remarks>
              The Fast Variance filter replaces each pixel in an image by its
              neighborhood online variance. This filter differs from the
              <see cref="T:Accord.Imaging.Filters.Variance" />filter because it uses only a single pass
              over the image.
            </remarks>
            
            <example>
            <code>
            Bitmap image = ... // Lena's picture
            
            // Create a new Variance filter:
            var variance = new FastVariance();
            
            // Compute the filter
            Bitmap result = variance.Apply(image);
            
            // Show on the screen
            ImageBox.Show(result);
            </code>
            
            <para>
              The resulting image is shown below:</para>
            
              <img src="..\images\variance.png" />
            
            </example>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FastVariance.Radius">
            <summary>
              Gets or sets the radius of the neighborhood
              used to compute a pixel's local variance.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FastVariance.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Variance"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FastVariance.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Variance"/> class.
            </summary>
            
            <param name="radius">The radius neighborhood used to compute a pixel's local variance.</param>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FastVariance.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FastVariance.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.HighBoost">
            <summary>
              High boost filter.
            </summary>
            
            <remarks>
            <para>
              The High-boost filter can be used to emphasize high frequency
              components (i.e. points of contrast) without removing the low
              frequency ones.</para>
              
            <para>
             This filter implementation has been contributed by Diego Catalano.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HighBoost.Size">
            <summary>
            Kernel size, [3, 21].
            </summary>
            
            <remarks><para>Size of Gaussian kernel.</para>
            
            <para>Default value is set to <b>5</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.HighBoost.Boost">
            <summary>
              Gets or sets the boost value. Default is 9.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HighBoost.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HighBoost"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HighBoost.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HighBoost"/> class.
            </summary>
            
            <param name="boost">The boost value. Default is 8.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.HighBoost.#ctor(System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.HighBoost"/> class.
            </summary>
            
            <param name="boost">The boost value. Default is 8.</param>
            <param name="size">The kernel size. Default is 3.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.ExtractBiggestBlob">
            <summary>
            Extract the biggest blob from image.
            </summary>
            
            <remarks><para>The filter locates the biggest blob in the source image and extracts it.
            The filter also can use the source image for the biggest blob's location only, but extract it from
            another image, which is set using <see cref="P:Accord.Imaging.Filters.ExtractBiggestBlob.OriginalImage"/> property. The original image 
            usually is the source of the processed image.</para>
            
            <para>The filter accepts 8 bpp grayscale images and 24/32 color images for processing as source image passed to
            <see cref="M:Accord.Imaging.Filters.ExtractBiggestBlob.Apply(System.Drawing.Bitmap)"/> method and also for the <see cref="P:Accord.Imaging.Filters.ExtractBiggestBlob.OriginalImage"/>.</para>
            
            <para>Sample usage:</para>
            <code>
            // create filter
            var filter = new ExtractBiggestBlob();
            
            // apply the filter
            Bitmap biggestBlobsImage = filter.Apply(image);
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample2.jpg" width="320" height="240" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\biggest_blob.jpg" width="141" height="226" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ExtractBiggestBlob.BlobPosition">
            <summary>
            Position of the extracted blob.
            </summary>
            
            <remarks><para>After applying the filter this property keeps position of the extracted
            blob in the source image.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ExtractBiggestBlob.FormatTranslations">
             <summary>
             Format translations dictionary.
             </summary>
             
             <remarks><para>The dictionary defines, which pixel formats are supported for
             source images and which pixel format will be used for resulting image.
             </para>
             
             <para>See <see cref="P:Accord.Imaging.Filters.IFilterInformation.FormatTranslations"/> for more information.</para>
             </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.ExtractBiggestBlob.OriginalImage">
            <summary>
            Original image, which is the source of the processed image where the biggest blob is searched for.
            </summary>
            
            <remarks><para>The property may be set to <see langword="null"/>. In this case the biggest blob
            is extracted from the image, which is passed to <see cref="M:Accord.Imaging.Filters.ExtractBiggestBlob.Apply(System.Drawing.Bitmap)"/> image.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ExtractBiggestBlob.Apply(System.Drawing.Bitmap)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="image">Source image to get biggest blob from.</param>
             
             <returns>Returns image of the biggest blob.</returns>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the original image.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Source and original images must have the same size.</exception>
             <exception cref="T:System.ArgumentException">The source image does not contain any blobs.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ExtractBiggestBlob.Apply(System.Drawing.Imaging.BitmapData)">
             <summary>
             Apply filter to an image.
             </summary>
             
             <param name="imageData">Source image to get biggest blob from.</param>
             
             <returns>Returns image of the biggest blob.</returns>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the original image.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Source and original images must have the same size.</exception>
             <exception cref="T:System.ArgumentException">The source image does not contain any blobs.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ExtractBiggestBlob.Apply(Accord.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image (not implemented).
            </summary>
            
            <param name="image">Image in unmanaged memory.</param>
            
            <returns>Returns filter's result obtained by applying the filter to
            the source image.</returns>
            
        </member>
        <member name="M:Accord.Imaging.Filters.ExtractBiggestBlob.Apply(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Apply filter to an image (not implemented).
            </summary>
            
            <param name="sourceImage">Source image to be processed.</param>
            <param name="destinationImage">Destination image to store filter's result.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.RGChromacity">
            <summary>
              RG Chromaticity.
            </summary>
            
            <remarks>
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Wikipedia contributors. "rg chromaticity." Wikipedia, The Free Encyclopedia. Wikipedia,
                  The Free Encyclopedia. Available at http://en.wikipedia.org/wiki/Rg_chromaticity </description></item>
              </list>
            </para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.RGChromacity.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RGChromacity.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.RGChromacity"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RGChromacity.ProcessFilter(Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.SauvolaThreshold">
            <summary>
              Sauvola Threshold.
            </summary>
            
            <remarks>
              <para>
              The Sauvola filter is a variation of the <see cref="T:Accord.Imaging.Filters.NiblackThreshold"/>
              thresholding filter.</para>
              
            <para>
             This filter implementation has been contributed by Diego Catalano.</para>
             
            <para>
              References:
              <list type="bullet">
                <item><description>
                    Sauvola, Jaakko, and Matti PietikÃ¤inen. "Adaptive document image binarization."
                    Pattern Recognition 33.2 (2000): 225-236.</description></item>
              </list></para>   
            </remarks>
            
            <example>
            <code>
            Bitmap image = ... // Lena's picture
            
            // Create a new Sauvola threshold:
            var sauvola = new SauvolaThreshold();
            
            // Compute the filter
            Bitmap result = sauvola.Apply(image);
            
            // Show on the screen
            ImageBox.Show(result);
            </code>
            
            <para>
              The resulting image is shown below:</para>
            
              <img src="..\images\sauvola.png" />
            
            </example>
            
            <seealso cref="T:Accord.Imaging.Filters.NiblackThreshold"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SauvolaThreshold.Radius">
            <summary>
              Gets or sets the filter convolution
              radius. Default is 15.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SauvolaThreshold.K">
            <summary>
              Gets or sets the user-defined 
              parameter k. Default is 0.5.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SauvolaThreshold.R">
            <summary>
              Gets or sets the dynamic range of the 
              standard deviation, R. Default is 128.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.SauvolaThreshold.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SauvolaThreshold.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.SauvolaThreshold"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.SauvolaThreshold.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.LineMarker">
            <summary>
              Filter to mark (highlight) lines in a image.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.LineMarker.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.LineMarker.MarkerColor">
            <summary>
              Color used to mark corners.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LineMarker.Line">
            <summary>
              Gets or sets the set of points to mark.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Filters.LineMarker.Width">
            <summary>
              Gets or sets the width of the points to be drawn.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.LineMarker.#ctor(Accord.Math.Geometry.Line)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.LineMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.LineMarker.#ctor(Accord.Math.Geometry.Line,System.Drawing.Color)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.LineMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.LineMarker.#ctor(Accord.Math.Geometry.Line,System.Drawing.Color,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.LineMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.LineMarker.#ctor(System.Drawing.Color)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.LineMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.LineMarker.#ctor(System.Drawing.Color,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.LineMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.LineMarker.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
               Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.NiblackThreshold">
            <summary>
              Niblack Threshold.
            </summary>
            
            <remarks>
              <para>
              The Niblack filter is a local thresholding algorithm that separates
              white and black pixels given the local mean and standard deviation
              for the current window.</para>
              
            <para>
             This filter implementation has been contributed by Diego Catalano.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                   W. Niblack, An Introduction to Digital Image Processing, pp. 115-116.
                   Prentice Hall, 1986.</description></item>
              </list></para>   
            </remarks>
            
            <example>
            <code>
            Bitmap image = ... // Lena's picture
            
            // Create a new Niblack threshold:
            var niblack = new NiblackThreshold();
            
            // Compute the filter
            Bitmap result = niblack.Apply(image);
            
            // Show on the screen
            ImageBox.Show(result);
            </code>
            
            <para>
              The resulting image is shown below:</para>
            
              <img src="..\images\niblack.png" />
            
            </example>
            
            <seealso cref="T:Accord.Imaging.Filters.SauvolaThreshold"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.NiblackThreshold.Radius">
            <summary>
              Gets or sets the filter convolution
              radius. Default is 15.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.NiblackThreshold.K">
            <summary>
              Gets or sets the user-defined 
              parameter k. Default is 0.2.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.NiblackThreshold.C">
            <summary>
              Gets or sets the mean offset C. This value should
              be between 0 and 255. The default value is 0.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.NiblackThreshold.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.NiblackThreshold.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.NiblackThreshold"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.NiblackThreshold.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.RotateNearestNeighbor">
             <summary>
             Rotate image using nearest neighbor algorithm.
             </summary>
             
             <remarks><para>The class implements image rotation filter using nearest
             neighbor algorithm, which does not assume any interpolation.</para>
             
             <para><note>Rotation is performed in counterclockwise direction.</note></para>
             
             <para>The filter accepts 8/16 bpp grayscale images and 24/48 bpp color image
             for processing.</para>
            
             <para>Sample usage:</para>
             <code>
             // create filter - rotate for 30 degrees keeping original image size
             RotateNearestNeighbor filter = new RotateNearestNeighbor( 30, true );
             // apply the filter
             Bitmap newImage = filter.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample9.png" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\rotate_nearest.png" width="320" height="240" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.Filters.RotateBilinear"/>
             <seealso cref="T:Accord.Imaging.Filters.RotateBicubic"/>
             
        </member>
        <member name="P:Accord.Imaging.Filters.RotateNearestNeighbor.FormatTranslations">
            <summary>
            Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RotateNearestNeighbor.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.RotateNearestNeighbor"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            
            <remarks><para>This constructor sets <see cref="P:Accord.Imaging.Filters.BaseRotateFilter.KeepSize"/> property to
            <see langword="false"/>.
            </para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RotateNearestNeighbor.#ctor(System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.RotateNearestNeighbor"/> class.
            </summary>
            
            <param name="angle">Rotation angle.</param>
            <param name="keepSize">Keep image size or not.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RotateNearestNeighbor.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.WhitePatch">
            <summary>
              White Patch filter for color normalization.
            </summary>
            
            <example>
            <code>
              Bitmap image = ... // Lena's famous picture
            
              // Create the White Patch filter
              var whitePatch = new WhitePatch();
            
              // Apply the filter
              Bitmap result = whitePatch.Apply(image);
              
              // Show on the screen
              ImageBox.Show(result);
            </code>
            
            <para>
              The resulting image is shown below. </para>
              
            <img src="..\images\white-patch.png" /> 
            </example>
            
        </member>
        <member name="P:Accord.Imaging.Filters.WhitePatch.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.WhitePatch.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.WhitePatch"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.WhitePatch.ProcessFilter(Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.GrayWorld">
            <summary>
              Gray World filter for color normalization.
            </summary>
            
            <remarks>
            <para>
              The grey world normalization makes the assumption that changes in the 
              lighting spectrum can be modeled by three constant factors applied to
              the red, green and blue channels of color[2]. More specifically, a change
              in illuminated color can be modeled as a scaling Î±, Î² and Î³ in the R, 
              G and B color channels and as such the grey world algorithm is invariant
              to illumination color variations.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Wikipedia Contributors, "Color normalization". Available at
                  http://en.wikipedia.org/wiki/Color_normalization </description></item>
                <item><description>
                  Jose M. Buenaposada; Luis Baumela. ï»¿Variations of Grey World for
                  face trackingï»¿ (Report). </description></item>
              </list>
            </para>
            </remarks>
            
            <example>
            <code>
              Bitmap image = ... // Lena's famous picture
            
              // Create a new Gray World filter
              var grayWorld = new GrayWorld();
            
              // Apply the filter
              Bitmap result = grayWorld.Apply(image);
              
              // Show on the screen
              ImageBox.Show(result);
            </code>
            
            <para>
              The resulting image is shown below. </para>
              
            <img src="..\images\gray-world.png" /> 
            </example>
            
        </member>
        <member name="P:Accord.Imaging.Filters.GrayWorld.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GrayWorld.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GrayWorld"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GrayWorld.ProcessFilter(Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Kuwahara">
            <summary>
              Kuwahara filter.
            </summary>
            
            <example>
            <code>
              Bitmap image = ... // Lena's famous picture
            
              // Create a new Kuwahara filter
              Kuwahara kuwahara = new Kuwahara();
            
              // Apply the Kuwahara filter
              Bitmap result = kuwahara.Apply(image);
              
              // Show on the screen
              ImageBox.Show(result);
            </code>
            </example>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Kuwahara.Size">
            <summary>
              Gets the size of the kernel used in the Kuwahara filter. This
              should be odd and greater than or equal to five. Default is 5.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Kuwahara.BlockSize">
            <summary>
              Gets the size of each of the four inner blocks used in the
              Kuwahara filter. This is always half the <see cref="P:Accord.Imaging.Filters.Kuwahara.Size">
              kernel size</see> minus one.
            </summary>
            
            <value>
              The size of the each inner block, or <c>k / 2 - 1</c> 
              where <c>k</c> is the kernel size.
            </value>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Kuwahara.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Kuwahara.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Kuwahara"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Kuwahara.ProcessFilter(Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.WolfJolionThreshold">
            <summary>
              Wolf Jolion Threshold.
            </summary>
            
            <remarks>
              <para>
              The Wolf-Jolion threshold filter is a variation 
              of the <see cref="T:Accord.Imaging.Filters.SauvolaThreshold"/> filter.</para>
              
            <para>
             This filter implementation has been contributed by Diego Catalano.</para>
             
            <para>
              References:
              <list type="bullet">
                <item><description>
                <a href="http://liris.cnrs.fr/christian.wolf/papers/icpr2002v.pdf">
                    C. Wolf, J.M. Jolion, F. Chassaing. "Text Localization, Enhancement and 
                    Binarization in Multimedia Documents." Proceedings of the 16th International 
                    Conference on Pattern Recognition, 2002. 
                    Available in http://liris.cnrs.fr/christian.wolf/papers/icpr2002v.pdf </a></description></item>
              </list></para>   
            </remarks>
            
            <example>
            <code>
            Bitmap image = ... // Lena's picture
            
            // Create a new Wolf-Joulion threshold:
            var wolfJoulion = new WolfJoulionThreshold();
            
            // Compute the filter
            Bitmap result = wolfJoulion.Apply(image);
            
            // Show on the screen
            ImageBox.Show(result);
            </code>
            </example>
            
            <seealso cref="T:Accord.Imaging.Filters.NiblackThreshold"/>
            <seealso cref="T:Accord.Imaging.Filters.SauvolaThreshold"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.WolfJolionThreshold.Radius">
            <summary>
              Gets or sets the filter convolution
              radius. Default is 15.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.WolfJolionThreshold.K">
            <summary>
              Gets or sets the user-defined 
              parameter k. Default is 0.5.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.WolfJolionThreshold.R">
            <summary>
              Gets or sets the dynamic range of the 
              standard deviation, R. Default is 128.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.WolfJolionThreshold.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.WolfJolionThreshold.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.WolfJolionThreshold"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.WolfJolionThreshold.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.CompassConvolution">
            <summary>
              Compass convolution filter.
            </summary>
            
            <seealso cref="T:Accord.Imaging.Filters.RobinsonEdgeDetector"/>
            <seealso cref="T:Accord.Imaging.Filters.KirschEdgeDetector"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CompassConvolution.#ctor(System.Int32[0:,0:][])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.CompassConvolution"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CompassConvolution.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CompassConvolution.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Exponential">
            <summary>
              Exponential filter.
            </summary>
            
            <remarks>
              Simple exp image filter. Applies the <see cref="M:System.Math.Exp(System.Double)"/>
              function for each pixel in the image, clipping values as needed.
              The resultant image can be converted back using the <see cref="T:Accord.Imaging.Filters.Logarithm"/>
              filter.
            </remarks>
            
            <example>
            <code>
              Bitmap input = ... 
            
              // Apply log
              Logarithm log = new Logarithm();
              Bitmap output = log.Apply(input);
            
              // Revert log
              Exponential exp = new Exponential();
              Bitmap reconstruction = exp.Apply(output);
            
              // Show results on screen
              ImageBox.Show("input", input);
              ImageBox.Show("output", output);
              ImageBox.Show("reconstruction", reconstruction);
            </code>
            </example>
            
            <seealso cref="T:Accord.Imaging.Filters.Logarithm"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Exponential.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Exponential.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Exponential"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Exponential.ProcessFilter(Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Logarithm">
            <summary>
              Log filter.
            </summary>
            
            <remarks>
              Simple log image filter. Applies the <see cref="M:System.Math.Log(System.Double)"/>
              function for each pixel in the image, clipping values as needed.
              The resultant image can be converted back using the <see cref="T:Accord.Imaging.Filters.Exponential"/>
              filter.
            </remarks>
            
            <example>
            <code>
              Bitmap input = ... 
            
              // Apply log
              Logarithm log = new Logarithm();
              Bitmap output = log.Apply(input);
            
              // Revert log
              Exponential exp = new Exponential();
              Bitmap reconstruction = exp.Apply(output);
            
              // Show results on screen
              ImageBox.Show("input", input);
              ImageBox.Show("output", output);
              ImageBox.Show("reconstruction", reconstruction);
            </code>
            </example>
            
            <seealso cref="T:Accord.Imaging.Filters.Exponential"/>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Logarithm.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Logarithm.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Logarithm"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Logarithm.ProcessFilter(Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.RobinsonEdgeDetector">
            <summary>
              Robinson's Edge Detector
            </summary>
            
            <remarks>
              <para>
              Robinson's edge detector is a variation of <see cref="T:Accord.Imaging.Filters.KirschEdgeDetector">
              Kirsch's detector</see> using different convolution masks. Both are examples
              of <see cref="T:Accord.Imaging.Filters.CompassConvolution">compass convolution filters</see>.</para>
            </remarks>
            
            <example>
            <code>
            Bitmap image = ... // Lena's picture
            
            // Create a new Robinson's edge detector:
            var robinson = new RobinsonEdgeDetector();
            
            // Compute the image edges
            Bitmap edges = robinson.Apply(image);
            
            // Show on screen
            ImageBox.Show(edges);
            </code>
            
            <para>
              The resulting image is shown below:</para>
            
              <img src="..\images\robinson.png" />
            
            </example>
            
            <seealso cref="T:Accord.Imaging.Filters.KirschEdgeDetector"/>
            <seealso cref="T:Accord.Imaging.Filters.CompassConvolution"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RobinsonEdgeDetector.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.RobinsonEdgeDetector"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.RobinsonEdgeDetector.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RobinsonEdgeDetector.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="F:Accord.Imaging.Filters.RobinsonEdgeDetector.North">
            <summary>
              Gets the North direction Robinson kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.RobinsonEdgeDetector.Northwest">
            <summary>
              Gets the Northwest direction Robinson kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.RobinsonEdgeDetector.West">
            <summary>
              Gets the West direction Robinson kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.RobinsonEdgeDetector.Southwest">
            <summary>
              Gets the Southwest direction Robinson kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.RobinsonEdgeDetector.South">
            <summary>
              Gets the South direction Robinson kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.RobinsonEdgeDetector.Southeast">
            <summary>
              Gets the Southeast direction Robinson kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.RobinsonEdgeDetector.East">
            <summary>
              Gets the East direction Robinson kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.RobinsonEdgeDetector.Northeast">
            <summary>
              Gets the Northeast direction Robinson kernel mask.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.Filters.GaborFilter">
            <summary>
              Gabor filter.
            </summary>
            
            <remarks>
            <para>
              In image processing, a Gabor filter, named after Dennis Gabor, is a linear 
              filter used for edge detection. Frequency and orientation representations 
              of Gabor filters are similar to those of the human visual system, and they
              have been found to be particularly appropriate for texture representation 
              and discrimination. In the spatial domain, a 2D Gabor filter is a Gaussian
              kernel function modulated by a sinusoidal plane wave. The Gabor filters are
              self-similar: all filters can be generated from one mother wavelet by dilation
              and rotation. </para>
            </remarks>
            
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Wikipedia Contributors, "Gabor filter". Available at
                  http://en.wikipedia.org/wiki/Gabor_filter </description></item>
              </list>
            </para>
            
            <example>
            <para>
              The following example applies a Gabor filter to detect lines
              at a 45 degrees from the following image: </para>
              
            <img src="..\images\lines.png" /> 
            
            <code>
              Bitmap input = ...;
              
              // Create a new Gabor filter
              GaborFilter filter = new GaborFilter();
              
              // Apply the filter
              Bitmap output = filter.Apply(input);
              
              // Show the output
              ImageBox.Show(output);
            </code>
            
            <para>
              The resulting image is shown below. </para>
              
            <img src="..\images\lines-gabor.png" /> 
            </example>
            
        </member>
        <member name="P:Accord.Imaging.Filters.GaborFilter.Size">
            <summary>
              Gets or sets the size of the filter. Default is 3.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.GaborFilter.Sigma">
            <summary>
              Gets or sets the Gaussian variance for the filter. Default is 2.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.GaborFilter.Theta">
            <summary>
              Gets or sets the orientation for the filter, in radians. Default is 0.6.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.GaborFilter.Lambda">
            <summary>
              Gets or sets the wavelength for the filter. Default is 4.0.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.GaborFilter.Gamma">
            <summary>
              Gets or sets the aspect ratio for the filter. Default is 0.3.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.GaborFilter.Psi">
            <summary>
              Gets or sets the phase offset for the filter. Default is 1.0.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GaborFilter.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.GaborFilter"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.GaborFilter.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.GaborFilter.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.KirschEdgeDetector">
            <summary>
              Kirsch's Edge Detector
            </summary>
            
            <remarks>
              <para>
              The Kirsch operator or Kirsch <see cref="T:Accord.Imaging.Filters.CompassConvolution">compass kernel</see>
              is a non-linear edge detector that finds the maximum edge strength in a few 
              predetermined directions. It is named after the computer scientist Russell 
              A. Kirsch.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Wikipedia contributors. "Kirsch operator." Wikipedia, The Free Encyclopedia. Wikipedia,
                  The Free Encyclopedia. Available at http://en.wikipedia.org/wiki/Kirsch_operator </description></item>
              </list>
            </para>
            </remarks>
            
            <example>
            <code>
            Bitmap image = ... // Lena's picture
            
            // Create a new Kirsch's edge detector:
            var kirsch = new KirschEdgeDetector();
            
            // Compute the image edges
            Bitmap edges = kirsch.Apply(image);
            
            // Show on screen
            ImageBox.Show(edges);
            </code>
            
            <para>
              The resulting image is shown below:</para>
            
              <img src="..\images\kirsch.png" />
            
            </example>
            
            <seealso cref="T:Accord.Imaging.Filters.RobinsonEdgeDetector"/>
            <seealso cref="T:Accord.Imaging.Filters.CompassConvolution"/>
            
        </member>
        <member name="M:Accord.Imaging.Filters.KirschEdgeDetector.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.KirschEdgeDetector"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.KirschEdgeDetector.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.KirschEdgeDetector.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="F:Accord.Imaging.Filters.KirschEdgeDetector.North">
            <summary>
              Gets the North direction Kirsch kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.KirschEdgeDetector.Northwest">
            <summary>
              Gets the Northwest direction Kirsch kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.KirschEdgeDetector.West">
            <summary>
              Gets the West direction Kirsch kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.KirschEdgeDetector.Southwest">
            <summary>
              Gets the Southwest direction Kirsch kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.KirschEdgeDetector.South">
            <summary>
              Gets the South direction Kirsch kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.KirschEdgeDetector.Southeast">
            <summary>
              Gets the Southeast direction Kirsch kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.KirschEdgeDetector.East">
            <summary>
              Gets the East direction Kirsch kernel mask.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.Filters.KirschEdgeDetector.Northeast">
            <summary>
              Gets the Northeast direction Kirsch kernel mask.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Variance">
            <summary>
              Variance filter.
            </summary>
            
            <remarks>
              The Variance filter replaces each pixel in an image by its
              neighborhood variance. The end result can be regarded as an
              border enhancement, making the Variance filter suitable to
              be used as an edge detection mechanism.
            </remarks>
            
            <example>
            <code>
            Bitmap image = ... // Lena's picture
            
            // Create a new Variance filter:
            var variance = new Variance();
            
            // Compute the filter
            Bitmap result = variance.Apply(image);
            
            // Show on the screen
            ImageBox.Show(result);
            </code>
            
            <para>
              The resulting image is shown below:</para>
            
              <img src="..\images\variance.png" />
            
            </example>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Variance.Radius">
            <summary>
              Gets or sets the radius of the neighborhood
              used to compute a pixel's local variance.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Variance.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Variance"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Variance.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.Variance"/> class.
            </summary>
            
            <param name="radius">The radius neighborhood used to compute a pixel's local variance.</param>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Variance.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Variance.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="sourceData">Source image data.</param>
            <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.CombineChannel">
            <summary>
              Combine channel filter.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.CombineChannel.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
            <remarks>
              <para>The dictionary defines, which pixel formats are supported for
              source images and which pixel format will be used for resulting image.</para>
            
              <para>See <see cref="P:AForge.Imaging.Filters.IFilterInformation.FormatTranslations"/>
              for more information.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CombineChannel.#ctor(Accord.Imaging.UnmanagedImage[])">
            <summary>
              Constructs a new CombineChannel filter.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.CombineChannel.ProcessFilter(Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the filter on the specified image.
            </summary>
            
            <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Rectification">
            <summary>
              Rectification filter for projective transformation.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Rectification.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Rectification.Homography">
            <summary>
              Gets or sets the Homography matrix used to map a image passed to
              the filter to the overlay image specified at filter creation.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Rectification.FillColor">
            <summary>
              Gets or sets the filling color used to fill blank spaces.
            </summary>
            
            <remarks>
              The filling color will only be visible after the image is converted
              to 24bpp. The alpha channel will be used internally by the filter.
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Rectification.#ctor(System.Double[0:,0:])">
            <summary>
              Constructs a new Blend filter.
            </summary>
            
            <param name="homography">The homography matrix mapping a second image to the overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Rectification.#ctor(Accord.Imaging.MatrixH)">
            <summary>
              Constructs a new Blend filter.
            </summary>
            
            <param name="homography">The homography matrix mapping a second image to the overlay image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Rectification.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
              Computes the new image size.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Rectification.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the image filter.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.Filters.FeaturesMarker">
            <summary>
              Filter to mark (highlight) feature points in a image.
            </summary>
            
            <remarks>
            <para>The filter highlights feature points on the image using a given set of points.</para>
            
            <para>The filter accepts 8 bpp grayscale and 24 color images for processing.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FeaturesMarker.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FeaturesMarker.Scale">
            <summary>
              Gets or sets the initial size for a feature point in the map. Default is 5.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.FeaturesMarker.Points">
            <summary>
              Gets or sets the set of points to mark.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FeaturesMarker.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FeaturesMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FeaturesMarker.#ctor(System.Collections.Generic.IEnumerable{Accord.Imaging.SpeededUpRobustFeaturePoint})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FeaturesMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FeaturesMarker.#ctor(System.Collections.Generic.IEnumerable{Accord.Imaging.FastRetinaKeypoint})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FeaturesMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FeaturesMarker.#ctor(System.Collections.Generic.IEnumerable{Accord.Imaging.SpeededUpRobustFeaturePoint},System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FeaturesMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FeaturesMarker.#ctor(System.Collections.Generic.IEnumerable{Accord.Imaging.FastRetinaKeypoint},System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.FeaturesMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.FeaturesMarker.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
               Process the filter on the specified image.
             </summary>
             
             <param name="sourceData">Source image data.</param>
             <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.Blend">
            <summary>
              Linear Gradient Blending filter.
            </summary>
            
            <remarks>
            <para>
              The blending filter is able to blend two images using a homography matrix.
              A linear alpha gradient is used to smooth out differences between the two
              images, effectively blending them in two images. The gradient is computed
              considering the distance between the centers of the two images.</para>
            <para>
            
              The first image should be passed at the moment of creation of the Blending
              filter as the overlay image. A second image may be projected on top of the
              overlay image by calling the Apply method and passing the second image as
              argument.</para>  
              
            <para>
              Currently the filter always produces 32bpp images, disregarding the format
              of source images. The alpha layer is used as an intermediate mask in the
              blending process.</para>  
            </remarks>
            
            <example>
            <code>
            // Let's start with two pictures that have been
            // taken from slightly different points of view:
            //
            Bitmap img1 = Resources.dc_left;
            Bitmap img2 = Resources.dc_right;
            
            // Those pictures are shown below:
            ImageBox.Show(img1, PictureBoxSizeMode.Zoom, 640, 480);
            ImageBox.Show(img2, PictureBoxSizeMode.Zoom, 640, 480);
            </code>
            
            <img src="..\images\panorama-1.png" /> 
            <img src="..\images\panorama-2.png" /> 
            
            <code>
            // Step 1: Detect feature points using Surf Corners Detector
            var surf = new SpeededUpRobustFeaturesDetector();
            
            var points1 = surf.ProcessImage(img1);
            var points2 = surf.ProcessImage(img2);
            
            // Step 2: Match feature points using a k-NN
            var matcher = new KNearestNeighborMatching(5);
            var matches = matcher.Match(points1, points2);
            
            // Step 3: Create the matrix using a robust estimator
            var ransac = new RansacHomographyEstimator(0.001, 0.99);
            MatrixH homographyMatrix = ransac.Estimate(matches);
            
            // Step 4: Project and blend using the homography
            Blend blend = new Blend(homographyMatrix, img1);
            
            
            // Compute the blending algorithm
            Bitmap result = blend.Apply(img2);
            
            // Show on screen
            ImageBox.Show(result, PictureBoxSizeMode.Zoom, 640, 480);
            </code>
            
            <para>
              The resulting image is shown below. </para>
              
            <img src="..\images\panorama-3.png" /> 
            </example>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Blend.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Blend.Homography">
            <summary>
              Gets or sets the Homography matrix used to map a image passed to
              the filter to the overlay image specified at filter creation.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Blend.FillColor">
            <summary>
              Gets or sets the filling color used to fill blank spaces.
            </summary>
            
            <remarks>
              The filling color will only be visible after the image is converted
              to 24bpp. The alpha channel will be used internally by the filter.
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Blend.Gradient">
            <summary>
              Gets or sets a value indicating whether to blend using a linear
              gradient or just superimpose the two images with equal weights.
            </summary>
            
            <value><c>true</c> to create a gradient; otherwise, <c>false</c>. Default is true.</value>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Blend.AlphaOnly">
            <summary>
              Gets or sets a value indicating whether only the alpha channel
              should be blended. This can be used together with a transparency
              mask to selectively blend only portions of the image.
            </summary>
            
            <value><c>true</c> to blend only the alpha channel; otherwise, <c>false</c>. Default is false.</value>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Blend.#ctor(System.Double[0:,0:],System.Drawing.Bitmap)">
            <summary>
              Constructs a new Blend filter.
            </summary>
            
            <param name="homography">The homography matrix mapping a second image to the overlay image.</param>
            <param name="overlayImage">The overlay image (also called the anchor).</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Blend.#ctor(System.Drawing.Bitmap)">
            <summary>
              Constructs a new Blend filter.
            </summary>
            
            <param name="overlayImage">The overlay image (also called the anchor).</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Blend.#ctor(Accord.Imaging.MatrixH,System.Drawing.Bitmap)">
            <summary>
              Constructs a new Blend filter.
            </summary>
            
            <param name="homography">The homography matrix mapping a second image to the overlay image.</param>
            <param name="overlayImage">The overlay image (also called the anchor).</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Blend.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
              Computes the new image size.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Blend.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Process the image filter.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.Blend.distance(System.Single,System.Single,System.Single,System.Single)">
            <summary>
              Computes a distance metric used to compute the blending mask
            </summary>
        </member>
        <member name="T:Accord.Imaging.Filters.Concatenate">
            <summary>
              Concatenation filter.
            </summary>
            
            <remarks>
              Concatenates two images side by side in a single image.
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Filters.Concatenate.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Concatenate.#ctor(System.Drawing.Bitmap)">
            <summary>
              Creates a new concatenation filter.
            </summary>
            <param name="overlayImage">The first image to concatenate.</param>
        </member>
        <member name="M:Accord.Imaging.Filters.Concatenate.CalculateNewImageSize(Accord.Imaging.UnmanagedImage)">
            <summary>
              Calculates new image size.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Filters.Concatenate.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
               Process the filter on the specified image.
             </summary>
             
             <param name="sourceData">Source image data.</param>
             <param name="destinationData">Destination image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.RectanglesMarker">
            <summary>
              Filter to mark (highlight) rectangles in a image.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.RectanglesMarker.MarkerColor">
            <summary>
              Color used to mark pairs.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.RectanglesMarker.FillColor">
            <summary>
              Gets or sets the color used to fill
              rectangles. Default is Transparent.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.RectanglesMarker.SingleRectangle">
            <summary>
              The set of rectangles.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.RectanglesMarker.Rectangles">
            <summary>
              The set of rectangles.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.RectanglesMarker.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RectanglesMarker.#ctor(System.Drawing.Color)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.RectanglesMarker"/> class.
            </summary>
            
            <param name="markerColor">The color to use to drawn the rectangles.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RectanglesMarker.#ctor(System.Drawing.Rectangle[])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.RectanglesMarker"/> class.
            </summary>
            
            <param name="rectangles">Set of rectangles to be drawn.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RectanglesMarker.#ctor(System.Collections.Generic.IEnumerable{System.Drawing.Rectangle})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.RectanglesMarker"/> class.
            </summary>
            
            <param name="rectangles">Set of rectangles to be drawn.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RectanglesMarker.#ctor(System.Collections.Generic.IEnumerable{System.Drawing.Rectangle},System.Drawing.Color)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.RectanglesMarker"/> class.
            </summary>
            
            <param name="rectangles">Set of rectangles to be drawn.</param>
            <param name="markerColor">The color to use to drawn the rectangles.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.RectanglesMarker.ProcessFilter(Accord.Imaging.UnmanagedImage)">
            <summary>
              Applies the filter to the image.
            </summary>
        </member>
        <member name="T:Accord.Imaging.Filters.PairsMarker">
            <summary>
              Filter to mark (highlight) pairs of points in a image.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.PairsMarker.MarkerColor">
            <summary>
              Color used to mark pairs.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.PairsMarker.Points1">
            <summary>
              The first set of points.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.PairsMarker.Points2">
            <summary>
              The corresponding points to the first set of points.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.PairsMarker.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PairsMarker.#ctor(Accord.IntPoint[],Accord.IntPoint[])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.PairsMarker"/> class.
            </summary>
            
            <param name="points1">Set of starting points.</param>
            <param name="points2">Set of corresponding points.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PairsMarker.#ctor(Accord.IntPoint[],Accord.IntPoint[],System.Drawing.Color)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.PairsMarker"/> class.
            </summary>
            
            <param name="points1">Set of starting points.</param>
            <param name="points2">Set of corresponding points.</param>
            <param name="markerColor">The color of the lines to be marked.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PairsMarker.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
               Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.PointsMarker">
            <summary>
              Filter to mark (highlight) points in a image.
            </summary>
            
            <remarks>
            <para>The filter highlights points on the image using a given set of points.</para>
            
            <para>The filter accepts 8 bpp grayscale, 24 and 32 bpp color images for processing.</para>
            </remarks>
            
            <example>
            <para>Sample usage:
            <code>
            // Create a blob contour's instance
            BlobCounter bc = new BlobCounter(image);
            
            // Extract blobs
            Blob[] blobs = bc.GetObjectsInformation();
            bc.ExtractBlobsImage(bmp, blobs[0], true);
            
            // Extract blob's edge points
            List&lt;IntPoint&gt; contour = bc.GetBlobsEdgePoints(blobs[0]);
            
            // Create a green, 2 pixel width points marker's instance
            PointsMarker marker = new PointsMarker(contour, Color.Green, 2);
            
            // Apply the filter in a given color image
            marker.ApplyInPlace(colorBlob);
            </code>
            </para>
            </example>
        </member>
        <member name="P:Accord.Imaging.Filters.PointsMarker.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.PointsMarker.MarkerColor">
            <summary>
              Color used to mark corners.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.PointsMarker.Points">
            <summary>
              Gets or sets the set of points to mark.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.PointsMarker.Width">
            <summary>
              Gets or sets the width of the points to be drawn.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointsMarker.#ctor(System.Collections.Generic.IList{Accord.Imaging.IFeaturePoint})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.PointsMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointsMarker.#ctor(System.Collections.Generic.IList{Accord.Imaging.IFeaturePoint},System.Drawing.Color)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.PointsMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointsMarker.#ctor(System.Collections.Generic.IList{Accord.Imaging.IFeaturePoint},System.Drawing.Color,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.PointsMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointsMarker.#ctor(System.Collections.Generic.IEnumerable{Accord.IntPoint})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.PointsMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointsMarker.#ctor(System.Collections.Generic.IEnumerable{Accord.IntPoint},System.Drawing.Color)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.PointsMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointsMarker.#ctor(System.Collections.Generic.IEnumerable{Accord.IntPoint},System.Drawing.Color,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.PointsMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointsMarker.#ctor(System.Drawing.Color)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.PointsMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointsMarker.#ctor(System.Drawing.Color,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Filters.PointsMarker"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.PointsMarker.ProcessFilter(Accord.Imaging.UnmanagedImage)">
             <summary>
               Process the filter on the specified image.
             </summary>
             
             <param name="image">Source image data.</param>
            
        </member>
        <member name="T:Accord.Imaging.Filters.WaveletTransform">
            <summary>
              Wavelet transform filter.
            </summary>
            
            <example>
            <code>
            Bitmap image = ... // Lena's famous picture
            
            // Create a new Haar Wavelet transform filter
            var wavelet = new WaveletTransform(new Haar(1));
            
            // Apply the Wavelet transformation
            Bitmap result = wavelet.Apply(image);
            
            // Show on the screen
            ImageBox.Show(result);
            </code>
            
            <para>
              The resulting image is shown below. </para>
              
            <img src="..\images\wavelet-1.png" /> 
            
            <code>
            // Extract only one of the resulting images
            var crop = new Crop(new Rectangle(0, 0, 
                image.Width / 2, image.Height / 2));
            
            Bitmap quarter = crop.Apply(result);
            
            // Show on the screen
            ImageBox.Show(quarter);
            </code>
            
            <para>
              The resulting image is shown below. </para>
              
            <img src="..\images\wavelet-2.png" /> 
            </example>
            
        </member>
        <member name="M:Accord.Imaging.Filters.WaveletTransform.#ctor(Accord.Math.Wavelets.IWavelet)">
            <summary>
              Constructs a new Wavelet Transform filter.
            </summary>
            
            <param name="wavelet">A wavelet function.</param>
            
        </member>
        <member name="M:Accord.Imaging.Filters.WaveletTransform.#ctor(Accord.Math.Wavelets.IWavelet,System.Boolean)">
            <summary>
              Constructs a new Wavelet Transform filter.
            </summary>
            
            <param name="wavelet">A wavelet function.</param>
            <param name="backward">True to perform backward transform, false otherwise.</param>
            
        </member>
        <member name="P:Accord.Imaging.Filters.WaveletTransform.FormatTranslations">
            <summary>
              Format translations dictionary.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.WaveletTransform.Wavelet">
            <summary>
              Gets or sets the Wavelet function
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Filters.WaveletTransform.Backward">
            <summary>
              Gets or sets whether the filter should be applied forward or backwards.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Filters.WaveletTransform.ProcessFilter(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Applies the filter to the image.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.Formats.PNMImageInfo">
            <summary>
            Information about PNM image's frame.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Formats.PNMImageInfo.Version">
            <summary>
            PNM file version (format), [1, 6].
            </summary>
        </member>
        <member name="P:Accord.Imaging.Formats.PNMImageInfo.MaxDataValue">
            <summary>
            Maximum pixel's value in source PNM image.
            </summary>
            
            <remarks><para>The value is used to scale image's data converting them
            from original data range to the range of
            <see cref="P:Accord.Imaging.Formats.ImageInfo.BitsPerPixel">supported bits per pixel</see> format.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Formats.PNMImageInfo.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Formats.PNMImageInfo"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Formats.PNMImageInfo.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Formats.PNMImageInfo"/> class.
            </summary>
            
            <param name="width">Image's width.</param>
            <param name="height">Image's height.</param>
            <param name="bitsPerPixel">Number of bits per image's pixel.</param>
            <param name="frameIndex">Frame's index.</param>
            <param name="totalFrames">Total frames in the image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Formats.PNMImageInfo.Clone">
            <summary>
            Creates a new object that is a copy of the current instance. 
            </summary>
            
            <returns>A new object that is a copy of this instance.</returns>
            
        </member>
        <member name="T:Accord.Imaging.Formats.FITSImageInfo">
            <summary>
            Information about FITS image's frame.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Formats.FITSImageInfo.OriginalBitsPerPixl">
            <summary>
            Original bits per pixel.
            </summary>
            
            <remarks><para>The property specifies original number of bits per image's pixel. For
            FITS images the value may be equal to 8, 16, 32, -32 (32 bit image with float data
            type for pixel encoding), -64 (64 bit image with double data type for pixel encoding).
            </para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Formats.FITSImageInfo.MinDataValue">
            <summary>
            Minimum data value found during parsing FITS image.
            </summary>
            
            <remarks><para>Minimum and maximum data values are used to scale image's data converting
            them from <see cref="P:Accord.Imaging.Formats.FITSImageInfo.OriginalBitsPerPixl">original bits per pixel</see> format to
            <see cref="P:Accord.Imaging.Formats.ImageInfo.BitsPerPixel">supported bits per pixel</see> format.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Formats.FITSImageInfo.MaxDataValue">
            <summary>
            Maximum data value found during parsing FITS image.
            </summary>
            
            <remarks><para>Minimum and maximum data values are used to scale image's data converting
            them from <see cref="P:Accord.Imaging.Formats.FITSImageInfo.OriginalBitsPerPixl">original bits per pixel</see> format to
            <see cref="P:Accord.Imaging.Formats.ImageInfo.BitsPerPixel">supported bits per pixel</see> format.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Formats.FITSImageInfo.Telescope">
            <summary>
            Telescope used for object's observation.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Formats.FITSImageInfo.Object">
            <summary>
            Object acquired during observation.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Formats.FITSImageInfo.Observer">
            <summary>
            Observer doing object's acquiring.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Formats.FITSImageInfo.Instrument">
            <summary>
            Instrument used for observation.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Formats.FITSImageInfo.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Formats.FITSImageInfo"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Formats.FITSImageInfo.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Formats.FITSImageInfo"/> class.
            </summary>
            
            <param name="width">Image's width.</param>
            <param name="height">Image's height.</param>
            <param name="bitsPerPixel">Number of bits per image's pixel.</param>
            <param name="frameIndex">Frame's index.</param>
            <param name="totalFrames">Total frames in the image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Formats.FITSImageInfo.Clone">
            <summary>
            Creates a new object that is a copy of the current instance. 
            </summary>
            
            <returns>A new object that is a copy of this instance.</returns>
            
        </member>
        <member name="T:Accord.Imaging.Formats.FITSCodec">
             <summary>
             FITS image format decoder.
             </summary>
            
             <remarks><para>The FITS (an acronym derived from "Flexible Image Transport System") format
             is an astronomical image and table format created and supported by NASA. FITS is the most
             commonly used in astronomy and is designed specifically for scientific data. Different astronomical
             organizations keep their images acquired using telescopes and other equipment in FITS format.</para>
             
             <para><note>The class extracts image frames only from the main data section of FITS file.
             2D (single frame) and 3D (series of frames) data structures are supported.</note></para>
             
             <para><note>During image reading/parsing, its data are scaled using minimum and maximum values of
             the source image data. FITS tags are not used for this purpose - data are scaled from the
             [min, max] range found to the range of supported image format ([0, 255] for 8 bpp grayscale
             or [0, 65535] for 16 bpp grayscale image).</note></para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Formats.FITSCodec.DecodeSingleFrame(System.IO.Stream)">
            <summary>
            Decode first frame of FITS image.
            </summary>
            
            <param name="stream">Source stream, which contains encoded image.</param>
            
            <returns>Returns decoded image frame.</returns>
            
            <exception cref="T:System.FormatException">Not a FITS image format.</exception>
            <exception cref="T:System.NotSupportedException">Format of the FITS image is not supported.</exception>
            <exception cref="T:System.ArgumentException">The stream contains invalid (broken) FITS image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Formats.FITSCodec.Open(System.IO.Stream)">
            <summary>
            Open specified stream.
            </summary>
            
            <param name="stream">Stream to open.</param>
            
            <returns>Returns number of images found in the specified stream.</returns>
            
            <exception cref="T:System.FormatException">Not a FITS image format.</exception>
            <exception cref="T:System.NotSupportedException">Format of the FITS image is not supported.</exception>
            <exception cref="T:System.ArgumentException">The stream contains invalid (broken) FITS image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Formats.FITSCodec.DecodeFrame(System.Int32,Accord.Imaging.Formats.ImageInfo@)">
            <summary>
            Decode specified frame.
            </summary>
            
            <param name="frameIndex">Image frame to decode.</param>
            <param name="imageInfo">Receives information about decoded frame.</param>
            
            <returns>Returns decoded frame.</returns>
            
            <exception cref="T:System.NullReferenceException">No image stream was opened previously.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Stream does not contain frame with specified index.</exception>
            <exception cref="T:System.ArgumentException">The stream contains invalid (broken) FITS image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Formats.FITSCodec.Close">
            <summary>
            Close decoding of previously opened stream.
            </summary>
            
            <remarks><para>The method does not close stream itself, but just closes
            decoding cleaning all associated data with it.</para></remarks>
            
        </member>
        <member name="T:Accord.Imaging.Formats.IImageDecoder">
            <summary>
              Common interface for image decoders. Image decoders can read images stored
              in different formats (e.g. PNG, JPG, <see cref="T:Accord.Imaging.Formats.PNMCodec">PNM</see>, 
              <see cref="T:Accord.Imaging.Formats.FITSCodec">FITS</see> and transform them into <see cref="T:System.Drawing.Bitmap"/>.
            </summary>
            
            <remarks>
              <para>
              The interface also defines methods to work with image formats designed to store 
              multiple frames and image formats which provide different type of image description 
              (like acquisition parameters, etc).</para>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.Formats.PNMCodec"/>
            <seealso cref="T:Accord.Imaging.Formats.FITSCodec"/>
            
        </member>
        <member name="M:Accord.Imaging.Formats.IImageDecoder.DecodeSingleFrame(System.IO.Stream)">
            <summary>
            Decode first frame of image from the specified stream.
            </summary>
            
            <param name="stream">Source stream, which contains encoded image.</param>
            
            <returns>Returns decoded image frame.</returns>
            
            <remarks>
            <para>For one-frame image formats the method is supposed to decode single
            available frame. For multi-frame image formats the first frame should be
            decoded.</para>
            
            <para>Implementations of this method may throw
            <see cref="T:System.FormatException"/> exception to report about unrecognized image
            format, <see cref="T:System.ArgumentException"/> exception to report about incorrectly
            formatted image or <see cref="T:System.NotSupportedException"/> exception to report if
            certain formats are not supported.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Formats.IImageDecoder.Open(System.IO.Stream)">
            <summary>
            Open specified stream.
            </summary>
            
            <param name="stream">Stream to open.</param>
            
            <returns>Returns number of images found in the specified stream.</returns>
            
            <remarks><para>Implementation of this method is supposed to read image's header,
            checking for correct image format and reading its atributes.</para>
            
            <para>Implementations of this method may throw
            <see cref="T:System.FormatException"/> exception to report about unrecognized image
            format, <see cref="T:System.ArgumentException"/> exception to report about incorrectly
            formatted image or <see cref="T:System.NotSupportedException"/> exception to report if
            certain formats are not supported.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Formats.IImageDecoder.DecodeFrame(System.Int32,Accord.Imaging.Formats.ImageInfo@)">
            <summary>
            Decode specified frame.
            </summary>
            
            <param name="frameIndex">Image frame to decode.</param>
            <param name="imageInfo">Receives information about decoded frame.</param>
            
            <returns>Returns decoded frame.</returns>
            
            <remarks>Implementations of this method may throw
            <see cref="T:System.NullReferenceException"/> exception in the case if no image
            stream was opened previously, <see cref="T:System.ArgumentOutOfRangeException"/> in the
            case if stream does not contain frame with specified index or  <see cref="T:System.ArgumentException"/>
            exception to report about incorrectly formatted image.
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Formats.IImageDecoder.Close">
            <summary>
            Close decoding of previously opened stream.
            </summary>
            
            <remarks><para>Implementations of this method don't close stream itself, but just close
            decoding cleaning all associated data with it.</para></remarks>
            
        </member>
        <member name="T:Accord.Imaging.Formats.ImageInfo">
            <summary>
            Information about image's frame.
            </summary>
            
            <remarks><para>This is a base class, which keeps basic information about image, like its width,
            height, etc. Classes, which inherit from this, may define more properties describing certain
            image formats.</para></remarks>
            
        </member>
        <member name="F:Accord.Imaging.Formats.ImageInfo.width">
            <summary>
            Image's width.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Formats.ImageInfo.height">
            <summary>
            Image's height.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Formats.ImageInfo.bitsPerPixel">
            <summary>
            Number of bits per image's pixel.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Formats.ImageInfo.frameIndex">
            <summary>
            Frame's index.
            </summary>
        </member>
        <member name="F:Accord.Imaging.Formats.ImageInfo.totalFrames">
            <summary>
             Total frames in the image.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Formats.ImageInfo.Width">
            <summary>
            Image's width.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Formats.ImageInfo.Height">
            <summary>
            Image's height.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Formats.ImageInfo.BitsPerPixel">
            <summary>
            Number of bits per image's pixel.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Formats.ImageInfo.FrameIndex">
            <summary>
            Frame's index.
            </summary>
            
            <remarks><para>Some image formats support storing multiple frames in one image file.
            The property specifies index of a particular frame.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Formats.ImageInfo.TotalFrames">
            <summary>
            Total frames in the image.
            </summary>
            
            <remarks><para>Some image formats support storing multiple frames in one image file.
            The property specifies total number of frames in image file.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Formats.ImageInfo.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Formats.ImageInfo"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Formats.ImageInfo.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Formats.ImageInfo"/> class.
            </summary>
            
            <param name="width">Image's width.</param>
            <param name="height">Image's height.</param>
            <param name="bitsPerPixel">Number of bits per image's pixel.</param>
            <param name="frameIndex">Frame's index.</param>
            <param name="totalFrames">Total frames in the image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Formats.ImageInfo.Clone">
            <summary>
            Creates a new object that is a copy of the current instance. 
            </summary>
            
            <returns>A new object that is a copy of this instance.</returns>
            
        </member>
        <member name="T:Accord.Imaging.Formats.ImageDecoder">
            <summary>
            Image decoder to decode different custom image file formats.
            </summary>
            
            <remarks><para>The class represent a help class, which simplifies decoding of image
            files finding appropriate image decoder automatically (using list of registered
            image decoders). Instead of using required image decoder directly, users may use this
            class, which will find required decoder by file's extension.</para>
            
            <para>
              By default the class will query all referenced assemblies for types that are marked
              with the <see cref="T:Accord.FormatDecoderAttribute"/>. If the user would like to implement
              a new decoder, all that is necessary is to mark a new class with the <see cref="T:Accord.FormatDecoderAttribute"/>
              and make it implement the <see cref="T:Accord.Imaging.Formats.IImageDecoder"/> interface.</para>
            
            <para><note>If the class can not find the appropriate decoder, it will delegate
              the file decoding to .NET's internal image decoders.</note></para>
            </remarks>
            
            <example>
            <code source="Unit Tests\Accord.Tests.Imaging\Formats\PNMCodecTest.cs" region="doc_load" />
            </example>
            
            <seealso cref="T:Accord.Imaging.Formats.PNMCodec"/>
            <seealso cref="T:Accord.Imaging.Formats.FITSCodec"/>
            
        </member>
        <member name="M:Accord.Imaging.Formats.ImageDecoder.RegisterDecoder(System.String,Accord.Imaging.Formats.IImageDecoder)">
            <summary>
              Obsolete. Please mark your decoder class with the <see cref="T:Accord.FormatDecoderAttribute"/> instead.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Formats.ImageDecoder.DecodeFromFile(System.String)">
            <summary>
            Decode first frame for the specified file.
            </summary>
            
            <param name="fileName">File name to read image from.</param>
            
            <returns>Return decoded image. In the case if file format support multiple
            frames, the method return the first frame.</returns>
            
            <remarks><para>The method uses table of registered image decoders to find the one,
            which should be used for the specified file. If there is not appropriate decoder
            found, the method uses default .NET's image decoding routine (see
            <see cref="M:System.Drawing.Image.FromFile(System.String)"/>).</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Formats.ImageDecoder.DecodeFromFile(System.String,Accord.Imaging.Formats.ImageInfo@)">
            <summary>
            Decode first frame for the specified file.
            </summary>
            
            <param name="fileName">File name to read image from.</param>
            <param name="imageInfo">Information about the decoded image.</param>
            
            <returns>Return decoded image. In the case if file format support multiple
            frames, the method return the first frame.</returns>
            
            <remarks><para>The method uses table of registered image decoders to find the one,
            which should be used for the specified file. If there is not appropriate decoder
            found, the method uses default .NET's image decoding routine (see
            <see cref="M:System.Drawing.Image.FromFile(System.String)"/>).</para></remarks>
            
        </member>
        <member name="T:Accord.Imaging.Formats.PNMCodec">
            <summary>
            PNM image format decoder.
            </summary>
            
            <remarks><para>The PNM (an acronym derived from "Portable Any Map") format is an
            abstraction of the PBM, PGM and PPM formats. I.e. the name "PNM" refers collectively
            to PBM (binary images), PGM (grayscale images) and PPM (color image) image formats.</para>
            
            <para>Image in PNM format can be found in different scientific databases and laboratories,
            for example <i>Yale Face Database</i> and <i>AT&amp;T Face Database</i>.</para>
            
            <para><note>Only PNM images of P2 (ascii encoded PGM), P3 (ascii encoded ppm), P5 
              (binary encoded PGM) and P6 (binary encoded PPM) formats are supported at this point.</note></para>
            
            <para><note>The maximum supported pixel value is 255 at this point.</note></para>
            
            <para><note>The class supports only one-frame PNM images. As it is specified in format
            specification, the multi-frame PNM images has appeared starting from 2000.</note></para>
            </remarks>
            
            <example>
            <code source="Unit Tests\Accord.Tests.Imaging\Formats\PNMCodecTest.cs" region="doc_load" />
            </example>
            
        </member>
        <member name="M:Accord.Imaging.Formats.PNMCodec.DecodeSingleFrame(System.IO.Stream)">
            <summary>
            Decode first frame of PNM image.
            </summary>
            
            <param name="stream">Source stream, which contains encoded image.</param>
            
            <returns>Returns decoded image frame.</returns>
            
            <exception cref="T:System.FormatException">Not a PNM image format.</exception>
            <exception cref="T:System.NotSupportedException">Format of the PNM image is not supported.</exception>
            <exception cref="T:System.ArgumentException">The stream contains invalid (broken) PNM image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Formats.PNMCodec.Open(System.IO.Stream)">
             <summary>
             Open specified stream.
             </summary>
             
             <param name="stream">Stream to open.</param>
             
             <returns>Returns number of images found in the specified stream.</returns>
             
             <exception cref="T:System.FormatException">Not a PNM image format.</exception>
             <exception cref="T:System.NotSupportedException">Format of the PNM image is not supported.</exception>
             <exception cref="T:System.ArgumentException">The stream contains invalid (broken) PNM image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Formats.PNMCodec.DecodeFrame(System.Int32,Accord.Imaging.Formats.ImageInfo@)">
            <summary>
            Decode specified frame.
            </summary>
            
            <param name="frameIndex">Image frame to decode.</param>
            <param name="imageInfo">Receives information about decoded frame.</param>
            
            <returns>Returns decoded frame.</returns>
            
            <exception cref="T:System.NullReferenceException">No image stream was opened previously.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Stream does not contain frame with specified index.</exception>
            <exception cref="T:System.ArgumentException">The stream contains invalid (broken) PNM image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Formats.PNMCodec.Close">
            <summary>
            Close decoding of previously opened stream.
            </summary>
            
            <remarks><para>The method does not close stream itself, but just closes
            decoding cleaning all associated data with it.</para></remarks>
            
        </member>
        <member name="T:Accord.Imaging.Formats.Tools">
            <summary>
            Set of tools used internally in AForge.Imaging.Formats library.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Formats.Tools.CreateGrayscaleImage(System.Int32,System.Int32)">
            <summary>
            Create and initialize new grayscale image.
            </summary>
            
            <param name="width">Image width.</param>
            <param name="height">Image height.</param>
            
            <returns>Returns new created grayscale image.</returns>
            
            <remarks><para>Accord.Imaging.Image.CreateGrayscaleImage() function
            could be used instead, which does the some. But it was not used to get
            rid of dependency on AForge.Imaing library.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Formats.Tools.ReadStream(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read specified amount of bytes from the specified stream.
            </summary>
            
            <param name="stream">Source sream to read data from.</param>
            <param name="buffer">Buffer to read data into.</param>
            <param name="offset">Offset in buffer to put data into.</param>
            <param name="count">Number of bytes to read.</param>
            
            <returns>Returns total number of bytes read. It may be smaller than requested amount only
            in the case if end of stream was reached.</returns>
            
            <remarks><para>This tool function guarantees that requested number of bytes
            was read from the source stream (.NET streams don't guarantee this and may return less bytes
            than it was requested). Only in the case if end of stream was reached, the function
            may return with less bytes read.</para>
            </remarks>
            
        </member>
        <member name="T:Accord.Imaging.HSL">
            <summary>
              HSL components.
            </summary>
            
            <remarks>
              The class encapsulates <b>HSL</b> color components and can be used to implement
              logic for reading, writing and converting to and from HSL color representations.
            </remarks>
            
            <example>
            <para>
              The following examples show how to convert to and from various pixel representations:</para>
            <code source="Unit Tests\Accord.Tests.Imaging\Colors\ColorsTest.cs" region="doc_rgb" />
            <code source="Unit Tests\Accord.Tests.Imaging\Colors\ColorsTest.cs" region="doc_hsl" />
            <code source="Unit Tests\Accord.Tests.Imaging\Colors\ColorsTest.cs" region="doc_ycbcr" />
            </example>
            
            <seealso cref="T:Accord.Imaging.RGB"/>
            <seealso cref="T:Accord.Imaging.YCbCr"/>
            
        </member>
        <member name="F:Accord.Imaging.HSL.Hue">
            <summary>
            Hue component.
            </summary>
            
            <remarks>Hue is measured in the range of [0, 359].</remarks>
            
        </member>
        <member name="F:Accord.Imaging.HSL.Saturation">
            <summary>
            Saturation component.
            </summary>
            
            <remarks>Saturation is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="F:Accord.Imaging.HSL.Luminance">
            <summary>
            Luminance value.
            </summary>
            
            <remarks>Luminance is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="M:Accord.Imaging.HSL.#ctor(System.Int32,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.HSL"/> class.
            </summary>
            
            <param name="hue">Hue component.</param>
            <param name="saturation">Saturation component.</param>
            <param name="luminance">Luminance component.</param>
            
        </member>
        <member name="M:Accord.Imaging.HSL.FromRGB(Accord.Imaging.RGB,Accord.Imaging.HSL@)">
            <summary>
            Convert from RGB to HSL color space.
            </summary>
            
            <param name="rgb">Source color in <b>RGB</b> color space.</param>
            <param name="hsl">Destination color in <b>HSL</b> color space.</param>
            
            <remarks><para>See <a href="http://en.wikipedia.org/wiki/HSI_color_space#Conversion_from_RGB_to_HSL_or_HSV">HSL and HSV Wiki</a>
            for information about the algorithm to convert from RGB to HSL.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.HSL.FromRGB(Accord.Imaging.RGB)">
            <summary>
            Convert from RGB to HSL color space.
            </summary>
            
            <param name="rgb">Source color in <b>RGB</b> color space.</param>
            
            <returns>Returns <see cref="T:Accord.Imaging.HSL"/> instance, which represents converted color value.</returns>
            
        </member>
        <member name="M:Accord.Imaging.HSL.ToRGB(Accord.Imaging.HSL,Accord.Imaging.RGB@)">
            <summary>
            Convert from HSL to RGB color space.
            </summary>
            
            <param name="hsl">Source color in <b>HSL</b> color space.</param>
            <param name="rgb">Destination color in <b>RGB</b> color space.</param>
            
        </member>
        <member name="M:Accord.Imaging.HSL.ToRGB">
            <summary>
            Convert the color to <b>RGB</b> color space.
            </summary>
            
            <returns>Returns <see cref="T:Accord.Imaging.RGB"/> instance, which represents converted color value.</returns>
            
        </member>
        <member name="M:Accord.Imaging.HSL.op_Explicit(Accord.Imaging.HSL)~Accord.Imaging.RGB">
            <summary>
            Performs an explicit conversion from <see cref="T:Accord.Imaging.HSL"/> to <see cref="T:Accord.Imaging.RGB"/>.
            </summary>
            <param name="hsl">The HSL color.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Accord.Imaging.HSL.op_Explicit(Accord.Imaging.HSL)~Accord.Imaging.YCbCr">
            <summary>
            Performs an explicit conversion from <see cref="T:Accord.Imaging.HSL"/> to <see cref="T:Accord.Imaging.YCbCr"/>.
            </summary>
            <param name="hsl">The HSL color.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="T:Accord.Imaging.RGB">
            <summary>
              RGB components.
            </summary>
            
            <remarks>
            <para>
              The class encapsulates <b>RGB</b> color components and can be used to implement
              logic for reading, writing and converting to and from RGB color representations.</para>
            <para>
              <note>The <see cref="T:System.Drawing.Imaging.PixelFormat">PixelFormat.Format24bppRgb</see>
              actually refers to a BGR pixel format.</note></para>
            </remarks>
            
            <example>
            <para>
              The following examples show how to convert to and from various pixel representations:</para>
            <code source="Unit Tests\Accord.Tests.Imaging\Colors\ColorsTest.cs" region="doc_rgb" />
            <code source="Unit Tests\Accord.Tests.Imaging\Colors\ColorsTest.cs" region="doc_hsl" />
            <code source="Unit Tests\Accord.Tests.Imaging\Colors\ColorsTest.cs" region="doc_ycbcr" />
            </example>
            
            <seealso cref="T:Accord.Imaging.HSL"/>
            <seealso cref="T:Accord.Imaging.YCbCr"/>
            
        </member>
        <member name="F:Accord.Imaging.RGB.R">
            <summary>
            Index of red component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.G">
            <summary>
            Index of green component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.B">
            <summary>
            Index of blue component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.A">
            <summary>
            Index of alpha component for ARGB images.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.Red">
            <summary>
            Red component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.Green">
            <summary>
            Green component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.Blue">
            <summary>
            Blue component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.Alpha">
            <summary>
            Alpha component.
            </summary>
        </member>
        <member name="P:Accord.Imaging.RGB.Color">
            <summary>
            <see cref="T:System.Drawing.Color">Color</see> value of the class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.RGB.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RGB"/> class.
            </summary>
            
            <param name="red">Red component.</param>
            <param name="green">Green component.</param>
            <param name="blue">Blue component.</param>
            
        </member>
        <member name="M:Accord.Imaging.RGB.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RGB"/> class.
            </summary>
            
            <param name="red">Red component.</param>
            <param name="green">Green component.</param>
            <param name="blue">Blue component.</param>
            <param name="alpha">Alpha component.</param>
            
        </member>
        <member name="M:Accord.Imaging.RGB.#ctor(System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RGB"/> class.
            </summary>
            
            <param name="color">Initialize from specified <see cref="T:System.Drawing.Color">color.</see></param>
            
        </member>
        <member name="M:Accord.Imaging.RGB.op_Explicit(Accord.Imaging.RGB)~Accord.Imaging.HSL">
            <summary>
            Performs an explicit conversion from <see cref="T:Accord.Imaging.RGB"/> to <see cref="T:Accord.Imaging.HSL"/>.
            </summary>
            <param name="rgb">The RGB color.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Accord.Imaging.RGB.op_Explicit(Accord.Imaging.RGB)~Accord.Imaging.YCbCr">
            <summary>
            Performs an explicit conversion from <see cref="T:Accord.Imaging.RGB"/> to <see cref="T:Accord.Imaging.YCbCr"/>.
            </summary>
            <param name="rgb">The RGB color.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="T:Accord.Imaging.YCbCr">
            <summary>
              YCbCr components.
            </summary>
            
            <remarks>
              The class encapsulates <b>YCbCr</b> color components and can be used to implement
              logic for reading, writing and converting to and from YCbCr color representations.
            </remarks>
            
            <example>
            <para>
              The following examples show how to convert to and from various pixel representations:</para>
            <code source="Unit Tests\Accord.Tests.Imaging\Colors\ColorsTest.cs" region="doc_rgb" />
            <code source="Unit Tests\Accord.Tests.Imaging\Colors\ColorsTest.cs" region="doc_hsl" />
            <code source="Unit Tests\Accord.Tests.Imaging\Colors\ColorsTest.cs" region="doc_ycbcr" />
            </example>
            
            <seealso cref="T:Accord.Imaging.HSL"/>
            <seealso cref="T:Accord.Imaging.RGB"/>
            
        </member>
        <member name="F:Accord.Imaging.YCbCr.YIndex">
            <summary>
            Index of <b>Y</b> component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.YCbCr.CbIndex">
            <summary>
            Index of <b>Cb</b> component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.YCbCr.CrIndex">
            <summary>
            Index of <b>Cr</b> component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.YCbCr.Y">
            <summary>
            <b>Y</b> component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.YCbCr.Cb">
            <summary>
            <b>Cb</b> component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.YCbCr.Cr">
            <summary>
            <b>Cr</b> component.
            </summary>
        </member>
        <member name="M:Accord.Imaging.YCbCr.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.YCbCr"/> class.
            </summary>
            
            <param name="y"><b>Y</b> component.</param>
            <param name="cb"><b>Cb</b> component.</param>
            <param name="cr"><b>Cr</b> component.</param>
            
        </member>
        <member name="M:Accord.Imaging.YCbCr.FromRGB(Accord.Imaging.RGB,Accord.Imaging.YCbCr@)">
            <summary>
            Convert from RGB to YCbCr color space (Rec 601-1 specification). 
            </summary>
            
            <param name="rgb">Source color in <b>RGB</b> color space.</param>
            <param name="ycbcr">Destination color in <b>YCbCr</b> color space.</param>
            
        </member>
        <member name="M:Accord.Imaging.YCbCr.FromRGB(Accord.Imaging.RGB)">
            <summary>
            Convert from RGB to YCbCr color space (Rec 601-1 specification).
            </summary>
            
            <param name="rgb">Source color in <b>RGB</b> color space.</param>
            
            <returns>Returns <see cref="T:Accord.Imaging.YCbCr"/> instance, which represents converted color value.</returns>
            
        </member>
        <member name="M:Accord.Imaging.YCbCr.ToRGB(Accord.Imaging.YCbCr,Accord.Imaging.RGB@)">
            <summary>
            Convert from YCbCr to RGB color space.
            </summary>
            
            <param name="ycbcr">Source color in <b>YCbCr</b> color space.</param>
            <param name="rgb">Destination color in <b>RGB</b> color space.</param>
            
        </member>
        <member name="M:Accord.Imaging.YCbCr.ToRGB">
            <summary>
            Convert the color to <b>RGB</b> color space.
            </summary>
            
            <returns>Returns <see cref="T:Accord.Imaging.RGB"/> instance, which represents converted color value.</returns>
            
        </member>
        <member name="M:Accord.Imaging.YCbCr.op_Explicit(Accord.Imaging.YCbCr)~Accord.Imaging.RGB">
            <summary>
            Performs an explicit conversion from <see cref="T:Accord.Imaging.YCbCr"/> to <see cref="T:Accord.Imaging.RGB"/>.
            </summary>
            <param name="yCbCr">The YCbCr color.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Accord.Imaging.YCbCr.op_Explicit(Accord.Imaging.YCbCr)~Accord.Imaging.HSL">
            <summary>
            Performs an explicit conversion from <see cref="T:Accord.Imaging.YCbCr"/> to <see cref="T:Accord.Imaging.HSL"/>.
            </summary>
            <param name="yCbCr">The YCbCr color.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="T:Accord.Imaging.Blob">
            <summary>
            Image's blob.
            </summary>
            
            <remarks><para>The class represents a blob - part of another images. The
            class encapsulates the blob itself and information about its position
            in parent image.</para>
            
            <para><note>The class is not responsible for blob's image disposing, so it should be
            done manually when it is required.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.Image">
             <summary>
             Blob's image.
             </summary>
            
             <remarks><para>The property keeps blob's image. In the case if it equals to <b>null</b>,
             the image may be extracted using <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,Accord.Imaging.Blob,System.Boolean)"/>
             or <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(Accord.Imaging.UnmanagedImage,Accord.Imaging.Blob,System.Boolean)"/> method.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.OriginalSize">
            <summary>
            Blob's image size.
            </summary>
            
            <remarks><para>The property specifies size of the <see cref="P:Accord.Imaging.Blob.Image">blob's image</see>.
            If the property is set to <see langword="true"/>, the blob's image size equals to the
            size of original image. If the property is set to <see langword="false"/>, the blob's
            image size equals to size of actual blob.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.Rectangle">
            <summary>
            Blob's rectangle in the original image.
            </summary>
            
            <remarks><para>The property specifies position of the blob in the original image
            and its size.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.ID">
            <summary>
            Blob's ID in the original image.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Blob.Area">
            <summary>
            Blob's area.
            </summary>
            
            <remarks><para>The property equals to blob's area measured in number of pixels
            contained by the blob.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.Fullness">
            <summary>
            Blob's fullness, [0, 1].
            </summary>
            
            <remarks><para>The property equals to blob's fullness, which is calculated
            as <b>Area / ( Width * Height )</b>. If it equals to <b>1</b>, then
            it means that entire blob's rectangle is filled by blob's pixel (no
            blank areas), which is true only for rectangles. If it equals to <b>0.5</b>,
            for example, then it means that only half of the bounding rectangle is filled
            by blob's pixels.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.CenterOfGravity">
            <summary>
            Blob's center of gravity point.
            </summary>
            
            <remarks><para>The property keeps center of gravity point, which is calculated as
            mean value of X and Y coordinates of blob's points.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.ColorMean">
            <summary>
            Blob's mean color.
            </summary>
            
            <remarks><para>The property keeps mean color of pixels comprising the blob.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.ColorStdDev">
            <summary>
            Blob color's standard deviation.
            </summary>
            
            <remarks><para>The property keeps standard deviation of pixels' colors comprising the blob.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Blob.#ctor(System.Int32,System.Drawing.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Blob"/> class.
            </summary>
            
            <param name="id">Blob's ID in the original image.</param>
            <param name="rect">Blob's rectangle in the original image.</param>
            
            <remarks><para>This constructor leaves <see cref="P:Accord.Imaging.Blob.Image"/> property not initialized. The blob's
            image may be extracted later using <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,Accord.Imaging.Blob,System.Boolean)"/>
            or <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(Accord.Imaging.UnmanagedImage,Accord.Imaging.Blob,System.Boolean)"/> method.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Blob.#ctor(Accord.Imaging.Blob)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Blob"/> class.
            </summary>
            
            <param name="source">Source blob to copy.</param>
            
            <remarks><para>This copy constructor leaves <see cref="P:Accord.Imaging.Blob.Image"/> property not initialized. The blob's
            image may be extracted later using <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,Accord.Imaging.Blob,System.Boolean)"/>
            or <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(Accord.Imaging.UnmanagedImage,Accord.Imaging.Blob,System.Boolean)"/> method.</para></remarks>
            
        </member>
        <member name="T:Accord.Imaging.BlobCounter">
            <summary>
            Blob counter - counts objects in image, which are separated by black background.
            </summary>
            
            <remarks><para>The class counts and extracts stand alone objects in
            images using connected components labeling algorithm.</para>
            
            <para><note>The algorithm treats all pixels with values less or equal to <see cref="P:Accord.Imaging.BlobCounter.BackgroundThreshold"/>
            as background, but pixels with higher values are treated as objects' pixels.</note></para>
            
            <para>For blobs' searching the class supports 8 bpp indexed grayscale images and
            24/32 bpp color images that are at least two pixels wide. Images that are one
            pixel wide can be processed if they are rotated first, or they can be processed
            with <see cref="T:Accord.Imaging.RecursiveBlobCounter"/>.
            See documentation about <see cref="T:Accord.Imaging.BlobCounterBase"/> for information about which
            pixel formats are supported for extraction of blobs.</para>
            
            <para>Sample usage:</para>
            
            <code>
            // create an instance of blob counter algorithm
            BlobCounter bc = new BlobCounter();
            
            // process binary image
            bc.ProcessImage(image);
            
            // process blobs
            foreach (Rectangle rect in bc.GetObjectsRectangles())
            {
                // ...
            }
            </code>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounter.BackgroundThreshold">
             <summary>
             Background threshold's value.
             </summary>
             
             <remarks><para>The property sets threshold value for distinguishing between background
             pixel and objects' pixels. All pixel with values less or equal to this property are
             treated as background, but pixels with higher values are treated as objects' pixels.</para>
             
             <para><note>In the case of colour images a pixel is treated as objects' pixel if <b>any</b> of its
             RGB values are higher than corresponding values of this threshold.</note></para>
             
             <para><note>For processing grayscale image, set the property with all RGB components eqaul.</note></para>
            
             <para>Default value is set to <b>(0, 0, 0)</b> - black colour.</para></remarks>
             
        </member>
        <member name="M:Accord.Imaging.BlobCounter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounter"/> class.
            </summary>
            
            <remarks>Creates new instance of the <see cref="T:Accord.Imaging.BlobCounter"/> class with
            an empty objects map. Before using methods, which provide information about blobs
            or extract them, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>,
            <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/> or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/>
            method should be called to collect objects map.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounter.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounter"/> class.
            </summary>
            
            <param name="image">Image to look for objects in.</param>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounter.#ctor(System.Drawing.Imaging.BitmapData)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounter"/> class.
            </summary>
            
            <param name="imageData">Image data to look for objects in.</param>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounter.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounter"/> class.
            </summary>
            
            <param name="image">Unmanaged image to look for objects in.</param>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounter.BuildObjectsMap(Accord.Imaging.UnmanagedImage)">
            <summary>
            Actual objects map building.
            </summary>
            
            <param name="image">Unmanaged image to process.</param>
            
            <remarks>The method supports 8 bpp indexed grayscale images and 24/32 bpp color images.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Cannot process images that are one pixel wide. Rotate the image
            or use <see cref="T:Accord.Imaging.RecursiveBlobCounter"/>.</exception>
            
        </member>
        <member name="T:Accord.Imaging.ObjectsOrder">
            <summary>
            Possible object orders.
            </summary>
            
            <remarks>The enumeration defines possible sorting orders of objects, found by blob
            counting classes.</remarks>
            
        </member>
        <member name="F:Accord.Imaging.ObjectsOrder.None">
            <summary>
            Unsorted order (as it is collected by algorithm).
            </summary>
        </member>
        <member name="F:Accord.Imaging.ObjectsOrder.Size">
            <summary>
            Objects are sorted by size in descending order (bigger objects go first).
            Size is calculated as <b>Width * Height</b>.
            </summary>
        </member>
        <member name="F:Accord.Imaging.ObjectsOrder.Area">
            <summary>
            Objects are sorted by area in descending order (bigger objects go first).
            </summary>
        </member>
        <member name="F:Accord.Imaging.ObjectsOrder.YX">
            <summary>
            Objects are sorted by Y coordinate, then by X coordinate in ascending order
            (smaller coordinates go first).
            </summary>
        </member>
        <member name="F:Accord.Imaging.ObjectsOrder.XY">
            <summary>
            Objects are sorted by X coordinate, then by Y coordinate in ascending order
            (smaller coordinates go first).
            </summary>
        </member>
        <member name="T:Accord.Imaging.BlobCounterBase">
            <summary>
            Base class for different blob counting algorithms.
            </summary>
            
            <remarks><para>The class is abstract and serves as a base for different blob counting algorithms.
            Classes, which inherit from this base class, require to implement <see cref="M:Accord.Imaging.BlobCounterBase.BuildObjectsMap(Accord.Imaging.UnmanagedImage)"/>
            method, which does actual building of object's label's map.</para>
            
            <para>For blobs' searcing usually all inherited classes accept binary images, which are actually
            grayscale thresholded images. But the exact supported format should be checked in particular class,
            inheriting from the base class. For blobs' extraction the class supports grayscale (8 bpp indexed)
            and color images (24 and 32 bpp).</para>
            
            <para>Sample usage:</para>
            <code>
            // create an instance of a blob counter algorithm
            BlobCounterBase bc = new BlobCounter();
            
            // set filtering options
            bc.FilterBlobs = true;
            bc.MinWidth  = 5;
            bc.MinHeight = 5;
            
            // process binary image
            bc.ProcessImage(image);
            
            // process blobs
            foreach (Blob blob in bc.GetObjects(image, false))
            {
                // ...
                // blob.Rectangle - blob's rectangle
                // blob.Image - blob's image
            }
            </code>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.ImageWidth">
            <summary>
            Gets the width of the image.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.ImageHeight">
            <summary>
            Gets the height of the image.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.ObjectsCount">
            <summary>
            Objects count.
            </summary>
            
            <remarks><para>Number of objects (blobs) found by <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/> method.
            </para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.ObjectLabels">
            <summary>
            Objects' labels.
            </summary>
            
            <remarks>The array of <b>width</b> * <b>height</b> size, which holds
            labels for all objects. Background is represented with <b>0</b> value,
            but objects are represented with labels starting from <b>1</b>.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.ObjectsOrder">
            <summary>
            Objects sort order.
            </summary>
            
            <remarks><para>The property specifies objects' sort order, which are provided
            by <see cref="M:Accord.Imaging.BlobCounterBase.GetObjectsRectangles"/>, <see cref="M:Accord.Imaging.BlobCounterBase.GetObjectsInformation"/>, etc.
            </para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.FilterBlobs">
            <summary>
            Specifies if blobs should be filtered.
            </summary>
            
            <remarks><para>If the property is equal to <b>false</b>, then there is no any additional
            post processing after image was processed. If the property is set to <b>true</b>, then
            blobs filtering is done right after image processing routine. If <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter"/>
            is set, then custom blobs' filtering is done, which is implemented by user. Otherwise
            blobs are filtered according to dimensions specified in <see cref="P:Accord.Imaging.BlobCounterBase.MinWidth"/>,
            <see cref="P:Accord.Imaging.BlobCounterBase.MinHeight"/>, <see cref="P:Accord.Imaging.BlobCounterBase.MaxWidth"/> and <see cref="P:Accord.Imaging.BlobCounterBase.MaxHeight"/> properties.</para>
            
            <para>Default value is set to <see langword="false"/>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.CoupledSizeFiltering">
            <summary>
            Specifies if size filtering should be coupled or not.
            </summary>
            
            <remarks><para>In uncoupled filtering mode, objects are filtered out in the case if
            their width is smaller than <see cref="P:Accord.Imaging.BlobCounterBase.MinWidth"/> <b>or</b> height is smaller than 
            <see cref="P:Accord.Imaging.BlobCounterBase.MinHeight"/>. But in coupled filtering mode, objects are filtered out in
            the case if their width is smaller than <see cref="P:Accord.Imaging.BlobCounterBase.MinWidth"/> <b>and</b> height is
            smaller than <see cref="P:Accord.Imaging.BlobCounterBase.MinHeight"/>. In both modes the idea with filtering by objects'
            maximum size is the same as filtering by objects' minimum size.</para>
            
            <para>Default value is set to <see langword="false"/>, what means uncoupled filtering by size.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.MinWidth">
            <summary>
            Minimum allowed width of blob.
            </summary>
            
            <remarks><para>The property specifies minimum object's width acceptable by blob counting
            routine and has power only when <see cref="P:Accord.Imaging.BlobCounterBase.FilterBlobs"/> property is set to
            <see langword="true"/> and <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter">custom blobs' filter</see> is
            set to <see langword="null"/>.</para>
            
            <para>See documentation to <see cref="P:Accord.Imaging.BlobCounterBase.CoupledSizeFiltering"/> for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.MinHeight">
            <summary>
            Minimum allowed height of blob.
            </summary>
            
            <remarks><para>The property specifies minimum object's height acceptable by blob counting
            routine and has power only when <see cref="P:Accord.Imaging.BlobCounterBase.FilterBlobs"/> property is set to
            <see langword="true"/> and <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter">custom blobs' filter</see> is
            set to <see langword="null"/>.</para>
            
            <para>See documentation to <see cref="P:Accord.Imaging.BlobCounterBase.CoupledSizeFiltering"/> for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.MaxWidth">
            <summary>
            Maximum allowed width of blob.
            </summary>
            
            <remarks><para>The property specifies maximum object's width acceptable by blob counting
            routine and has power only when <see cref="P:Accord.Imaging.BlobCounterBase.FilterBlobs"/> property is set to
            <see langword="true"/> and <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter">custom blobs' filter</see> is
            set to <see langword="null"/>.</para>
            
            <para>See documentation to <see cref="P:Accord.Imaging.BlobCounterBase.CoupledSizeFiltering"/> for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.MaxHeight">
            <summary>
            Maximum allowed height of blob.
            </summary>
            
            <remarks><para>The property specifies maximum object's height acceptable by blob counting
            routine and has power only when <see cref="P:Accord.Imaging.BlobCounterBase.FilterBlobs"/> property is set to
            <see langword="true"/> and <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter">custom blobs' filter</see> is
            set to <see langword="null"/>.</para>
            
            <para>See documentation to <see cref="P:Accord.Imaging.BlobCounterBase.CoupledSizeFiltering"/> for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.BlobsFilter">
            <summary>
            Custom blobs' filter to use.
            </summary>
            
            <remarks><para>The property specifies custom blobs' filtering routine to use. It has
            effect only in the case if <see cref="P:Accord.Imaging.BlobCounterBase.FilterBlobs"/> property is set to <see langword="true"/>.</para>
            
            <para><note>When custom blobs' filtering routine is set, it has priority over default filtering done
            with <see cref="P:Accord.Imaging.BlobCounterBase.MinWidth"/>, <see cref="P:Accord.Imaging.BlobCounterBase.MinHeight"/>, <see cref="P:Accord.Imaging.BlobCounterBase.MaxWidth"/> and <see cref="P:Accord.Imaging.BlobCounterBase.MaxHeight"/>.</note></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class.
            </summary>
            
            <remarks>Creates new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class with
            an empty objects map. Before using methods, which provide information about blobs
            or extract them, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>,
            <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/> or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/>
            method should be called to collect objects map.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class.
            </summary>
            
            <param name="image">Binary image to look for objects in.</param>
            
            <remarks>Creates new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class with
            initialized objects map built by calling <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/> method.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.#ctor(System.Drawing.Imaging.BitmapData)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class.
            </summary>
            
            <param name="imageData">Binary image data to look for objects in.</param>
            
            <remarks>Creates new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class with
            initialized objects map built by calling <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/> method.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class.
            </summary>
            
            <param name="image">Unmanaged binary image to look for objects in.</param>
            
            <remarks>Creates new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class with
            initialized objects map built by calling <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/> method.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)">
            <summary>
            Build objects map.
            </summary>
            
            <param name="image">Source binary image.</param>
            
            <remarks><para>Processes the image and builds objects map, which is used later to extracts blobs.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Build objects map.
            </summary>
            
            <param name="imageData">Source binary image data.</param>
            
            <remarks><para>Processes the image and builds objects map, which is used later to extracts blobs.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)">
            <summary>
            Build object map from raw image data.
            </summary>
            
            <param name="image">Source unmanaged binary image data.</param>
            
            <remarks><para>Processes the image and builds objects map, which is used later to extracts blobs.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Thrown by some inherited classes if some image property other
            than the pixel format is not supported. See that class's documentation or the exception message for details.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetObjectsRectangles">
            <summary>
            Get objects' rectangles.
            </summary>
            
            <returns>Returns array of objects' rectangles.</returns>
            
            <remarks>The method returns array of objects rectangles. Before calling the
            method, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
            or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/> method should be called, which will
            build objects map.</remarks>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so objects' rectangles
            can not be collected.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetObjectsInformation">
            <summary>
            Get objects' information.
            </summary>
            
            <returns>Returns array of partially initialized blobs (without <see cref="P:Accord.Imaging.Blob.Image"/> property initialized).</returns>
            
            <remarks><para>By the amount of provided information, the method is between <see cref="M:Accord.Imaging.BlobCounterBase.GetObjectsRectangles"/> and
            <see cref="M:Accord.Imaging.BlobCounterBase.GetObjects(Accord.Imaging.UnmanagedImage,System.Boolean)"/> methods. The method provides array of blobs without initialized their image.
            Blob's image may be extracted later using <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,Accord.Imaging.Blob,System.Boolean)"/>
            or <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(Accord.Imaging.UnmanagedImage,Accord.Imaging.Blob,System.Boolean)"/> method.
            </para></remarks>
            
            <example>
            <code>
            // create blob counter and process image
            BlobCounter bc = new BlobCounter(sourceImage);
            
            // specify sort order
            bc.ObjectsOrder = ObjectsOrder.Size;
            
            // get objects' information (blobs without image)
            Blob[] blobs = bc.GetObjectInformation();
            
            // process blobs
            foreach (Blob blob in blobs)
            {
                // check blob's properties
                if (blob.Rectangle.Width > 50)
                {
                    // the blob looks interesting, let's extract it
                    bc.ExtractBlobsImage(sourceImage, blob);
                }
            }
            </code>
            </example>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so objects' information
            can not be collected.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetObjects(System.Drawing.Bitmap,System.Boolean)">
             <summary>
             Get blobs.
             </summary>
             
             <param name="image">Source image to extract objects from.</param>
             
             <returns>Returns array of blobs.</returns>
             <param name="extractInOriginalSize">Specifies size of blobs' image to extract.
             If set to <see langword="true"/> each blobs' image will have the same size as
             the specified image. If set to <see langword="false"/> each blobs' image will
             have the size of its blob.</param>
            
             <remarks><para>The method returns array of blobs. Before calling the
             method, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
             or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/> method should be called, which will build
             objects map.</para>
             
             <para>The method supports 24/32 bpp color and 8 bpp indexed grayscale images.</para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the provided image.</exception>
             <exception cref="T:System.ApplicationException">No image was processed before, so objects
             can not be collected.</exception>
             
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetObjects(Accord.Imaging.UnmanagedImage,System.Boolean)">
             <summary>
             Get blobs.
             </summary>
             
             <param name="image">Source unmanaged image to extract objects from.</param>
             <param name="extractInOriginalSize">Specifies size of blobs' image to extract.
             If set to <see langword="true"/> each blobs' image will have the same size as
             the specified image. If set to <see langword="false"/> each blobs' image will
             have the size of its blob.</param>
             
             <returns>Returns array of blobs.</returns>
             
             <remarks><para>The method returns array of blobs. Before calling the
             method, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
             or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/> method should be called, which will build
             objects map.</para>
             
             <para>The method supports 24/32 bpp color and 8 bpp indexed grayscale images.</para>
             </remarks>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the provided image.</exception>
             <exception cref="T:System.ApplicationException">No image was processed before, so objects
             can not be collected.</exception>
             
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,Accord.Imaging.Blob,System.Boolean)">
             <summary>
             Extract blob's image.
             </summary>
             
             <param name="image">Source image to extract blob's image from.</param>
             <param name="blob">Blob which is required to be extracted.</param>
             <param name="extractInOriginalSize">Specifies size of blobs' image to extract.
             If set to <see langword="true"/> each blobs' image will have the same size as
             the specified image. If set to <see langword="false"/> each blobs' image will
             have the size of its blob.</param>
            
             <remarks><para>The method is used to extract image of partially initialized blob, which
             was provided by <see cref="M:Accord.Imaging.BlobCounterBase.GetObjectsInformation"/> method. Before calling the
             method, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
             or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/> method should be called, which will build
             objects map.</para>
             
             <para>The method supports 24/32 bpp color and 8 bpp indexed grayscale images.</para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the provided image.</exception>
             <exception cref="T:System.ApplicationException">No image was processed before, so blob
             can not be extracted.</exception>
             
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(Accord.Imaging.UnmanagedImage,Accord.Imaging.Blob,System.Boolean)">
             <summary>
             Extract blob's image.
             </summary>
             
             <param name="image">Source unmanaged image to extract blob's image from.</param>
             <param name="blob">Blob which is required to be extracted.</param>
             <param name="extractInOriginalSize">Specifies size of blobs' image to extract.
             If set to <see langword="true"/> each blobs' image will have the same size as
             the specified image. If set to <see langword="false"/> each blobs' image will
             have the size of its blob.</param>
            
             <remarks><para>The method is used to extract image of partially initialized blob, which
             was provided by <see cref="M:Accord.Imaging.BlobCounterBase.GetObjectsInformation"/> method. Before calling the
             method, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
             or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/> method should be called, which will build
             objects map.</para>
             
             <para>The method supports 24/32 bpp color and 8 bpp indexed grayscale images.</para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the provided image.</exception>
             <exception cref="T:System.ApplicationException">No image was processed before, so blob
             can not be extracted.</exception>
             
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetBlobsLeftAndRightEdges(Accord.Imaging.Blob,System.Collections.Generic.List{Accord.IntPoint}@,System.Collections.Generic.List{Accord.IntPoint}@)">
            <summary>
            Get list of points on the left and right edges of the blob.
            </summary>
            
            <param name="blob">Blob to collect edge points for.</param>
            <param name="leftEdge">List of points on the left edge of the blob.</param>
            <param name="rightEdge">List of points on the right edge of the blob.</param>
            
            <remarks><para>The method scans each line of the blob and finds the most left and the
            most right points for it adding them to appropriate lists. The method may be very
            useful in conjunction with different routines from <see cref="N:Accord.Math.Geometry"/>,
            which allow finding convex hull or quadrilateral's corners.</para>
            
            <para><note>Both lists of points are sorted by Y coordinate - points with smaller Y
            value go first.</note></para>
            </remarks>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so blob
            can not be extracted.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetBlobsTopAndBottomEdges(Accord.Imaging.Blob,System.Collections.Generic.List{Accord.IntPoint}@,System.Collections.Generic.List{Accord.IntPoint}@)">
            <summary>
            Get list of points on the top and bottom edges of the blob.
            </summary>
            
            <param name="blob">Blob to collect edge points for.</param>
            <param name="topEdge">List of points on the top edge of the blob.</param>
            <param name="bottomEdge">List of points on the bottom edge of the blob.</param>
            
            <remarks><para>The method scans each column of the blob and finds the most top and the
            most bottom points for it adding them to appropriate lists. The method may be very
            useful in conjunction with different routines from <see cref="N:Accord.Math.Geometry"/>,
            which allow finding convex hull or quadrilateral's corners.</para>
            
            <para><note>Both lists of points are sorted by X coordinate - points with smaller X
            value go first.</note></para>
            </remarks>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so blob
            can not be extracted.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetBlobsEdgePoints(Accord.Imaging.Blob)">
            <summary>
            Get list of object's edge points.
            </summary>
            
            <param name="blob">Blob to collect edge points for.</param>
            
            <returns>Returns unsorted list of blob's edge points.</returns>
            
            <remarks><para>The method scans each row and column of the blob and finds the
            most top/bottom/left/right points. The method returns similar result as if results of
            both <see cref="M:Accord.Imaging.BlobCounterBase.GetBlobsLeftAndRightEdges(Accord.Imaging.Blob,System.Collections.Generic.List{Accord.IntPoint}@,System.Collections.Generic.List{Accord.IntPoint}@)"/> and <see cref="M:Accord.Imaging.BlobCounterBase.GetBlobsTopAndBottomEdges(Accord.Imaging.Blob,System.Collections.Generic.List{Accord.IntPoint}@,System.Collections.Generic.List{Accord.IntPoint}@)"/>
            methods were combined, but each edge point occurs only once in the list.</para>
            
            <para><note>Edge points in the returned list are not ordered. This makes the list unusable
            for visualization with methods, which draw polygon or poly-line. But the returned list
            can be used with such algorithms, like convex hull search, shape analyzer, etc.</note></para>
            </remarks>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so blob
            can not be extracted.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.BuildObjectsMap(Accord.Imaging.UnmanagedImage)">
            <summary>
            Actual objects map building.
            </summary>
            
            <param name="image">Unmanaged image to process.</param>
            
            <remarks><note>By the time this method is called bitmap's pixel format is not
            yet checked, so this should be done by the class inheriting from the base class.
            <see cref="P:Accord.Imaging.BlobCounterBase.ImageWidth"/> and <see cref="P:Accord.Imaging.BlobCounterBase.ImageHeight"/> members are initialized
            before the method is called, so these members may be used safely.</note></remarks>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="T:Accord.Imaging.BlockMatch">
            <summary>
            Block match class keeps information about found block match. The class is
            used with block matching algorithms implementing <see cref="T:Accord.Imaging.IBlockMatching"/>
            interface.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.BlockMatch.SourcePoint">
            <summary>
            Reference point in source image.
            </summary>
        </member>
        <member name="P:Accord.Imaging.BlockMatch.MatchPoint">
            <summary>
            Match point in search image (point of a found match).
            </summary>
        </member>
        <member name="P:Accord.Imaging.BlockMatch.Similarity">
            <summary>
            Similarity between blocks in source and search images, [0..1].
            </summary>
        </member>
        <member name="M:Accord.Imaging.BlockMatch.#ctor(Accord.IntPoint,Accord.IntPoint,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlockMatch"/> class.
            </summary>
            
            <param name="sourcePoint">Reference point in source image.</param>
            <param name="matchPoint">Match point in search image (point of a found match).</param>
            <param name="similarity">Similarity between blocks in source and search images, [0..1].</param>
            
        </member>
        <member name="T:Accord.Imaging.ColorReduction.BurkesColorDithering">
            <summary>
            Color dithering using Burkes error diffusion.
            </summary>
            
            <remarks><para>The image processing routine represents color dithering algorithm, which is based on
            error diffusion dithering with Burkes coefficients. Error is diffused
            on 7 neighbor pixels with next coefficients:</para>
            <code lang="none">
                    | * | 8 | 4 |
            | 2 | 4 | 8 | 4 | 2 |
            
            / 32
            </code>
            
            <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
            produces 4 bpp or 8 bpp indexed image, which depends on size of the specified
            <see cref="P:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">color table</see> - 4 bpp result for
            color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
            
            <para>Sample usage:</para>
            <code>
            // create color image quantization routine
            ColorImageQuantizer ciq = new ColorImageQuantizer( new MedianCutQuantizer( ) );
            // create 8 colors table
            Color[] colorTable = ciq.CalculatePalette( image, 8 );
            // create dithering routine
            BurkesColorDithering dithering = new BurkesColorDithering( );
            dithering.ColorTable = colorTable;
            // apply the dithering routine
            Bitmap newImage = dithering.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\color_burkes.png" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.ColorReduction.FloydSteinbergColorDithering"/>
            <seealso cref="T:Accord.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering"/>
            <seealso cref="T:Accord.Imaging.ColorReduction.SierraColorDithering"/>
            <seealso cref="T:Accord.Imaging.ColorReduction.StuckiColorDithering"/>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.BurkesColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ColorReduction.BurkesColorDithering"/> class.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.ColorReduction.ColorErrorDiffusionToAdjacentNeighbors">
            <summary>
            Base class for error diffusion color dithering, where error is diffused to 
            adjacent neighbor pixels.
            </summary>
            
            <remarks><para>The class does error diffusion to adjacent neighbor pixels
            using specified set of coefficients. These coefficients are represented by
            2 dimensional jugged array, where first array of coefficients is for
            right-standing pixels, but the rest of arrays are for bottom-standing pixels.
            All arrays except the first one should have odd number of coefficients.</para>
            
            <para>Suppose that error diffusion coefficients are represented by the next
            jugged array:</para>
            
            <code>
            int[][] coefficients = new int[2][] {
                new int[1] { 7 },
                new int[3] { 3, 5, 1 }
            };
            </code>
            
            <para>The above coefficients are used to diffuse error over the next neighbor
            pixels (<b>*</b> marks current pixel, coefficients are placed to corresponding
            neighbor pixels):</para>
            <code lang="none">
                | * | 7 |
            | 3 | 5 | 1 |
            
            / 16
            </code>
            
            <para>The image processing routine accepts 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // create dithering routine
            ColorErrorDiffusionToAdjacentNeighbors dithering = new ColorErrorDiffusionToAdjacentNeighbors(
                new int[3][] {
                    new int[2] { 5, 3 },
                    new int[5] { 2, 4, 5, 4, 2 },
                    new int[3] { 2, 3, 2 }
                } );
            // apply the dithering routine
            Bitmap newImage = dithering.Apply( image );
            </code>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ColorReduction.ColorErrorDiffusionToAdjacentNeighbors.Coefficients">
            <summary>
            Diffusion coefficients.
            </summary>
            
            <remarks>Set of coefficients, which are used for error diffusion to
            pixel's neighbors.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.ColorErrorDiffusionToAdjacentNeighbors.#ctor(System.Int32[][])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ColorReduction.ColorErrorDiffusionToAdjacentNeighbors"/> class.
            </summary>
            
            <param name="coefficients">Diffusion coefficients (see <see cref="T:Accord.Imaging.ColorReduction.ColorErrorDiffusionToAdjacentNeighbors"/>
            for more information).</param>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.ColorErrorDiffusionToAdjacentNeighbors.Diffuse(System.Int32,System.Int32,System.Int32,System.Byte*)">
            <summary>
            Do error diffusion.
            </summary>
            
            <param name="rError">Error value of red component.</param>
            <param name="gError">Error value of green component.</param>
            <param name="bError">Error value of blue component.</param>
            <param name="ptr">Pointer to current processing pixel.</param>
            
            <remarks>All parameters of the image and current processing pixel's coordinates
            are initialized by base class.</remarks>
            
        </member>
        <member name="T:Accord.Imaging.ColorReduction.ColorImageQuantizer">
             <summary>
             Color quantization tools.
             </summary>
            
             <remarks><para>The class contains methods aimed to simplify work with color quantization
             algorithms implementing <see cref="T:Accord.Imaging.ColorReduction.IColorQuantizer"/> interface. Using its methods it is possible
             to calculate reduced color palette for the specified image or reduce colors to the specified number.</para>
             
             <para>Sample usage:</para>
             <code>
             // instantiate the images' color quantization class
             ColorImageQuantizer ciq = new ColorImageQuantizer( new MedianCutQuantizer( ) );
             // get 16 color palette for a given image
             Color[] colorTable = ciq.CalculatePalette( image, 16 );
             
             // ... or just reduce colors in the specified image
             Bitmap newImage = ciq.ReduceColors( image, 16 );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\reduced_colors.png" width="480" height="361" />
             </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ColorReduction.ColorImageQuantizer.Quantizer">
            <summary>
            Color quantization algorithm used by this class to build color palettes for the specified images.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ColorReduction.ColorImageQuantizer.UseCaching">
            <summary>
            Use color caching during color reduction or not.
            </summary>
            
            <remarks><para>The property has effect only for methods like <see cref="M:Accord.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(System.Drawing.Bitmap,System.Int32)"/> and
            specifies if internal cache of already processed colors should be used or not. For each pixel in the original
            image the color reduction routine does search in target color palette to find the best matching color.
            To avoid doing the search again and again for already processed colors, the class may use internal dictionary
            which maps colors of original image to indexes in target color palette.
            </para>
            
            <para><note>The property provides a trade off. On one hand it may speedup color reduction routine, but on another
            hand it increases memory usage. Also cache usage may not be efficient for very small target color tables.</note></para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.ColorImageQuantizer.#ctor(Accord.Imaging.ColorReduction.IColorQuantizer)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ColorReduction.ColorImageQuantizer"/> class.
            </summary>
            
            <param name="quantizer">Color quantization algorithm to use for processing images.</param>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.ColorImageQuantizer.CalculatePalette(System.Drawing.Bitmap,System.Int32)">
            <summary>
            Calculate reduced color palette for the specified image.
            </summary>
            
            <param name="image">Image to calculate palette for.</param>
            <param name="paletteSize">Palette size to calculate.</param>
            
            <returns>Return reduced color palette for the specified image.</returns>
            
            <remarks><para>See <see cref="M:Accord.Imaging.ColorReduction.ColorImageQuantizer.CalculatePalette(Accord.Imaging.UnmanagedImage,System.Int32)"/> for details.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.ColorImageQuantizer.CalculatePalette(Accord.Imaging.UnmanagedImage,System.Int32)">
             <summary>
             Calculate reduced color palette for the specified image.
             </summary>
             
             <param name="image">Image to calculate palette for.</param>
             <param name="paletteSize">Palette size to calculate.</param>
             
             <returns>Return reduced color palette for the specified image.</returns>
             
             <remarks><para>The method processes the specified image and feeds color value of each pixel
             to the specified color quantization algorithm. Finally it returns color palette built by
             that algorithm.</para></remarks>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported format of the source image - it must 24 or 32 bpp color image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(System.Drawing.Bitmap,System.Int32)">
            <summary>
            Create an image with reduced number of colors.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="paletteSize">Number of colors to get in the output image, [2, 256].</param>
            
            <returns>Returns image with reduced number of colors.</returns>
            
            <remarks><para>See <see cref="M:Accord.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(Accord.Imaging.UnmanagedImage,System.Int32)"/> for details.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(Accord.Imaging.UnmanagedImage,System.Int32)">
            <summary>
            Create an image with reduced number of colors.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="paletteSize">Number of colors to get in the output image, [2, 256].</param>
            
            <returns>Returns image with reduced number of colors.</returns>
            
            <remarks><para>The method creates an image, which looks similar to the specified image, but contains
            reduced number of colors. First, target color palette is calculated using <see cref="M:Accord.Imaging.ColorReduction.ColorImageQuantizer.CalculatePalette(Accord.Imaging.UnmanagedImage,System.Int32)"/>
            method and then a new image is created, where pixels from the given source image are substituted by
            best matching colors from calculated color table.</para>
            
            <para><note>The output image has 4 bpp or 8 bpp indexed pixel format depending on the target palette size -
            4 bpp for palette size 16 or less; 8 bpp otherwise.</note></para>
            </remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported format of the source image - it must 24 or 32 bpp color image.</exception>
            <exception cref="T:System.ArgumentException">Invalid size of the target color palette.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(System.Drawing.Bitmap,System.Drawing.Color[])">
            <summary>
            Create an image with reduced number of colors using the specified palette.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="palette">Target color palette. Must contatin 2-256 colors.</param>
            
            <returns>Returns image with reduced number of colors.</returns>
            
            <remarks><para>See <see cref="M:Accord.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(Accord.Imaging.UnmanagedImage,System.Drawing.Color[])"/> for details.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.ColorImageQuantizer.ReduceColors(Accord.Imaging.UnmanagedImage,System.Drawing.Color[])">
            <summary>
            Create an image with reduced number of colors using the specified palette.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="palette">Target color palette. Must contatin 2-256 colors.</param>
            
            <returns>Returns image with reduced number of colors.</returns>
            
            <remarks><para>The method creates an image, which looks similar to the specified image, but contains
            reduced number of colors. Is substitutes every pixel of the source image with the closest matching color
            in the specified paletter.</para>
            
            <para><note>The output image has 4 bpp or 8 bpp indexed pixel format depending on the target palette size -
            4 bpp for palette size 16 or less; 8 bpp otherwise.</note></para>
            </remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported format of the source image - it must 24 or 32 bpp color image.</exception>
            <exception cref="T:System.ArgumentException">Invalid size of the target color palette.</exception>
            
        </member>
        <member name="T:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering">
            <summary>
            Base class for error diffusion color dithering.
            </summary>
            
            <remarks><para>The class is the base class for color dithering algorithms based on
            <a href="http://en.wikipedia.org/wiki/Error_diffusion">error diffusion</a>.</para>
            
            <para>Color dithering with error diffusion is based on the idea that each pixel from the specified source
            image is substituted with a best matching color (or better say with color's index) from the specified color
            table. However, the error (difference between color value in the source image and the best matching color)
            is diffused to neighbor pixels of the source image, which affects the way those pixels are substituted by colors
            from the specified table.</para>
            
            <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
            produces 4 bpp or 8 bpp indexed image, which depends on size of the specified <see cref="P:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">color table</see> - 4 bpp result for
            color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
            </remarks>
            
        </member>
        <member name="F:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.x">
            <summary>
            Current processing X coordinate.
            </summary>
        </member>
        <member name="F:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.y">
            <summary>
            Current processing Y coordinate.
            </summary>
        </member>
        <member name="F:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.width">
            <summary>
            Processing image's width.
            </summary>
        </member>
        <member name="F:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.height">
            <summary>
            Processing image's height.
            </summary>
        </member>
        <member name="F:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.stride">
            <summary>
            Processing image's stride (line size).
            </summary>
        </member>
        <member name="F:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.pixelSize">
            <summary>
            Processing image's pixel size in bytes.
            </summary>
        </member>
        <member name="P:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">
            <summary>
            Color table to use for image dithering. Must contain 2-256 colors.
            </summary>
            
            <remarks><para>Color table size determines format of the resulting image produced by this
            image processing routine. If color table contains 16 color or less, then result image will have
            4 bpp indexed pixel format. If color table contains more than 16 colors, then result image will
            have 8 bpp indexed pixel format.</para>
            
            <para>By default the property is initialized with default 16 colors, which are:
            Black, Dark Blue, Dark Green, Dark Cyan, Dark Red, Dark Magenta, Dark Khaki, Light Gray,
            Gray, Blue, Green, Cyan, Red, Magenta, Yellow and White.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">Color table length must be in the [2, 256] range.</exception>
            
        </member>
        <member name="P:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.UseCaching">
            <summary>
            Use color caching during color dithering or not.
            </summary>
            
            <remarks><para>The property  specifies if internal cache of already processed colors should be used or not.
            For each pixel in the original image the color dithering routine does search in target color palette to find
            the best matching color. To avoid doing the search again and again for already processed colors, the class may
            use internal dictionary which maps colors of original image to indexes in target color palette.
            </para>
            
            <para><note>The property provides a trade off. On one hand it may speedup color dithering routine, but on another
            hand it increases memory usage. Also cache usage may not be efficient for very small target color tables.</note></para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.Diffuse(System.Int32,System.Int32,System.Int32,System.Byte*)">
            <summary>
            Do error diffusion.
            </summary>
            
            <param name="rError">Error value of red component.</param>
            <param name="gError">Error value of green component.</param>
            <param name="bError">Error value of blue component.</param>
            <param name="ptr">Pointer to current processing pixel.</param>
            
            <remarks>All parameters of the image and current processing pixel's coordinates
            are initialized in protected members.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.Apply(System.Drawing.Bitmap)">
            <summary>
            Perform color dithering for the specified image.
            </summary>
            
            <param name="sourceImage">Source image to do color dithering for.</param>
            
            <returns>Returns color dithered image. See <see cref="P:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable"/> for information about format of
            the result image.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. It must 24 or 32 bpp color image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.Apply(Accord.Imaging.UnmanagedImage)">
            <summary>
            Perform color dithering for the specified image.
            </summary>
            
            <param name="sourceImage">Source image to do color dithering for.</param>
            
            <returns>Returns color dithered image. See <see cref="P:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable"/> for information about format of
            the result image.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. It must 24 or 32 bpp color image.</exception>
            
        </member>
        <member name="T:Accord.Imaging.ColorReduction.FloydSteinbergColorDithering">
            <summary>
            Color dithering using Floyd-Steinberg error diffusion.
            </summary>
            
            <remarks><para>The image processing routine represents color dithering algorithm, which is based on
            error diffusion dithering with <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering">Floyd-Steinberg</a>
            coefficients. Error is diffused on 4 neighbor pixels with the next coefficients:</para>
            
            <code lang="none">
                | * | 7 |
            | 3 | 5 | 1 |
            
            / 16
            </code>
            
            <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
            produces 4 bpp or 8 bpp indexed image, which depends on size of the specified
            <see cref="P:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">color table</see> - 4 bpp result for
            color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
            
            <para>Sample usage:</para>
            <code>
            // create color image quantization routine
            ColorImageQuantizer ciq = new ColorImageQuantizer( new MedianCutQuantizer( ) );
            // create 16 colors table
            Color[] colorTable = ciq.CalculatePalette( image, 16 );
            // create dithering routine
            FloydSteinbergColorDithering dithering = new FloydSteinbergColorDithering( );
            dithering.ColorTable = colorTable;
            // apply the dithering routine
            Bitmap newImage = dithering.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\color_floyd_steinberg.png" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.ColorReduction.BurkesColorDithering"/>
            <seealso cref="T:Accord.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering"/>
            <seealso cref="T:Accord.Imaging.ColorReduction.SierraColorDithering"/>
            <seealso cref="T:Accord.Imaging.ColorReduction.StuckiColorDithering"/>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.FloydSteinbergColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ColorReduction.FloydSteinbergColorDithering"/> class.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.ColorReduction.IColorQuantizer">
            <summary>
            Interface which is implemented by different color quantization algorithms.
            </summary>
            
            <remarks><para>The interface defines set of methods, which are to be implemented by different
            color quantization algorithms - algorithms which are aimed to provide reduced color table/palette
            for a color image.</para>
            
            <para>See documentation to particular implementation of the interface for additional information
            about the algorithm.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.IColorQuantizer.AddColor(System.Drawing.Color)">
            <summary>
            Process color by a color quantization algorithm.
            </summary>
            
            <param name="color">Color to process.</param>
            
            <remarks><para>Depending on particular implementation of <see cref="T:Accord.Imaging.ColorReduction.IColorQuantizer"/> interface,
            this method may simply process the specified color or store it in internal list for
            later color palette calculation.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.IColorQuantizer.GetPalette(System.Int32)">
             <summary>
             Get palette of the specified size.
             </summary>
             
             <param name="colorCount">Palette size to return.</param>
             
             <returns>Returns reduced color palette for the accumulated/processed colors.</returns>
             
             <remarks><para>The method must be called after continuously calling <see cref="M:Accord.Imaging.ColorReduction.IColorQuantizer.AddColor(System.Drawing.Color)"/> method and
             returns reduced color palette for colors accumulated/processed so far.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.IColorQuantizer.Clear">
            <summary>
            Clear internals of the algorithm, like accumulated color table, etc.
            </summary>
            
            <remarks><para>The methods resets internal state of a color quantization algorithm returning
            it to initial state.</para></remarks>
            
        </member>
        <member name="T:Accord.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering">
             <summary>
             Color dithering using Jarvis, Judice and Ninke error diffusion.
             </summary>
             
             <remarks><para>The image processing routine represents color dithering algorithm, which is based on
             error diffusion dithering with Jarvis-Judice-Ninke coefficients. Error is diffused
             on 12 neighbor pixels with next coefficients:</para>
             <code lang="none">
                     | * | 7 | 5 |
             | 3 | 5 | 7 | 5 | 3 |
             | 1 | 3 | 5 | 3 | 1 |
             
             / 48
             </code>
             
             <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
             produces 4 bpp or 8 bpp indexed image, which depends on size of the specified
             <see cref="P:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">color table</see> - 4 bpp result for
             color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
             
             <para>Sample usage:</para>
             <code>
             // create color image quantization routine
             ColorImageQuantizer ciq = new ColorImageQuantizer( new MedianCutQuantizer( ) );
             // create 32 colors table
             Color[] colorTable = ciq.CalculatePalette( image, 32 );
             // create dithering routine
             JarvisJudiceNinkeColorDithering dithering = new JarvisJudiceNinkeColorDithering( );
             dithering.ColorTable = colorTable;
             // apply the dithering routine
             Bitmap newImage = dithering.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\color_jarvis_judice_ninke.png" width="480" height="361" />
             </remarks>
            
             <seealso cref="T:Accord.Imaging.ColorReduction.BurkesColorDithering"/>
             <seealso cref="T:Accord.Imaging.ColorReduction.FloydSteinbergColorDithering"/>
             <seealso cref="T:Accord.Imaging.ColorReduction.SierraColorDithering"/>
             <seealso cref="T:Accord.Imaging.ColorReduction.StuckiColorDithering"/>
             
        </member>
        <member name="M:Accord.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering"/> class.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.ColorReduction.MedianCutQuantizer">
            <summary>
            Median cut color quantization algorithm.
            </summary>
            
            <remarks><para>The class implements <a href="http://en.wikipedia.org/wiki/Median_cut">median cut</a>
            <a href="http://en.wikipedia.org/wiki/Median_cut">color quantization</a> algorithm.</para>
            
            <para>See also <see cref="T:Accord.Imaging.ColorReduction.ColorImageQuantizer"/> class, which may simplify processing of images.</para>
            
            <para>Sample usage:</para>
            <code>
            // create the color quantization algorithm
            IColorQuantizer quantizer = new MedianCutQuantizer( );
            // process colors (taken from image for example)
            for ( int i = 0; i &lt; pixelsToProcess; i++ )
            {
                quantizer.AddColor( /* pixel color */ );
            }
            // get palette reduced to 16 colors
            Color[] palette = quantizer.GetPalette( 16 );
            </code>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.ColorReduction.ColorImageQuantizer"/>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.MedianCutQuantizer.AddColor(System.Drawing.Color)">
            <summary>
            Add color to the list of processed colors.
            </summary>
            
            <param name="color">Color to add to the internal list.</param>
            
            <remarks><para>The method adds the specified color into internal list of processed colors. The list
            is used later by <see cref="M:Accord.Imaging.ColorReduction.MedianCutQuantizer.GetPalette(System.Int32)"/> method to build reduced color table of the specified size.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.MedianCutQuantizer.GetPalette(System.Int32)">
            <summary>
            Get paletter of the specified size.
            </summary>
            
            <param name="colorCount">Palette size to get.</param>
            
            <returns>Returns reduced palette of the specified size, which covers colors processed so far.</returns>
            
            <remarks><para>The method must be called after continuously calling <see cref="M:Accord.Imaging.ColorReduction.MedianCutQuantizer.AddColor(System.Drawing.Color)"/> method and
            returns reduced color palette for colors accumulated/processed so far.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.MedianCutQuantizer.Clear">
            <summary>
            Clear internal state of the color quantization algorithm by clearing the list of colors
            so far processed.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.ColorReduction.OrderedColorDithering">
            <summary>
            Color dithering with a thresold matrix (ordered dithering).
            </summary>
            
            <remarks><para>The class implements ordered color dithering as described on
            <a href="http://en.wikipedia.org/wiki/Ordered_dithering">Wikipedia</a>.
            The algorithm achieves dithering by applying a <see cref="P:Accord.Imaging.ColorReduction.OrderedColorDithering.ThresholdMatrix">threshold map</see> on
            the pixels displayed, causing some of the pixels to be rendered at a different color, depending on
            how far in between the color is of available <see cref="P:Accord.Imaging.ColorReduction.OrderedColorDithering.ColorTable">color entries</see>.</para>
            
            <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
            produces 4 bpp or 8 bpp indexed image, which depends on size of the specified
            <see cref="P:Accord.Imaging.ColorReduction.OrderedColorDithering.ColorTable">color table</see> - 4 bpp result for
            color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
            
            <para>Sample usage:</para>
            <code>
            // create color image quantization routine
            ColorImageQuantizer ciq = new ColorImageQuantizer( new MedianCutQuantizer( ) );
            // create 256 colors table
            Color[] colorTable = ciq.CalculatePalette( image, 256 );
            // create dithering routine
            OrderedColorDithering dithering = new OrderedColorDithering( );
            dithering.ColorTable = colorTable;
            // apply the dithering routine
            Bitmap newImage = dithering.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\ordered_color_dithering.png" width="480" height="361" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ColorReduction.OrderedColorDithering.ThresholdMatrix">
            <summary>
            Threshold matrix - values to add source image's values.
            </summary>
            
            <remarks><para>The property keeps a threshold matrix, which is applied to values of a source image
            to dither. By adding these values to the source image the algorithm produces the effect when pixels
            of the same color in source image may have different color in the result image (which depends on pixel's
            position). This threshold map is also known as an index matrix or Bayer matrix.</para>
            
            <para>By default the property is inialized with the below matrix:
            <code lang="none">
             2   18    6   22
            26   10   30   14
             8   24    4   20
            32   16   28   12
            </code>
            </para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ColorReduction.OrderedColorDithering.ColorTable">
            <summary>
            Color table to use for image dithering. Must contain 2-256 colors.
            </summary>
            
            <remarks><para>Color table size determines format of the resulting image produced by this
            image processing routine. If color table contains 16 color or less, then result image will have
            4 bpp indexed pixel format. If color table contains more than 16 colors, then result image will
            have 8 bpp indexed pixel format.</para>
            
            <para>By default the property is initialized with default 16 colors, which are:
            Black, Dark Blue, Dark Green, Dark Cyan, Dark Red, Dark Magenta, Dark Khaki, Light Gray,
            Gray, Blue, Green, Cyan, Red, Magenta, Yellow and White.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">Color table length must be in the [2, 256] range.</exception>
            
        </member>
        <member name="P:Accord.Imaging.ColorReduction.OrderedColorDithering.UseCaching">
            <summary>
            Use color caching during color dithering or not.
            </summary>
            
            <remarks><para>The property  specifies if internal cache of already processed colors should be used or not.
            For each pixel in the original image the color dithering routine does search in target color palette to find
            the best matching color. To avoid doing the search again and again for already processed colors, the class may
            use internal dictionary which maps colors of original image to indexes in target color palette.
            </para>
            
            <para><note>The property provides a trade off. On one hand it may speedup color dithering routine, but on another
            hand it increases memory usage. Also cache usage may not be efficient for very small target color tables.</note></para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.OrderedColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ColorReduction.OrderedColorDithering"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.OrderedColorDithering.#ctor(System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ColorReduction.OrderedColorDithering"/> class.
            </summary>
            
            <param name="matrix">Threshold matrix (see <see cref="P:Accord.Imaging.ColorReduction.OrderedColorDithering.ThresholdMatrix"/> property).</param>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.OrderedColorDithering.Apply(System.Drawing.Bitmap)">
            <summary>
            Perform color dithering for the specified image.
            </summary>
            
            <param name="sourceImage">Source image to do color dithering for.</param>
            
            <returns>Returns color dithered image. See <see cref="P:Accord.Imaging.ColorReduction.OrderedColorDithering.ColorTable"/> for information about format of
            the result image.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. It must 24 or 32 bpp color image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.OrderedColorDithering.Apply(Accord.Imaging.UnmanagedImage)">
            <summary>
            Perform color dithering for the specified image.
            </summary>
            
            <param name="sourceImage">Source image to do color dithering for.</param>
            
            <returns>Returns color dithered image. See <see cref="P:Accord.Imaging.ColorReduction.OrderedColorDithering.ColorTable"/> for information about format of
            the result image.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. It must 24 or 32 bpp color image.</exception>
            
        </member>
        <member name="T:Accord.Imaging.ColorReduction.SierraColorDithering">
            <summary>
            Color dithering using Sierra error diffusion.
            </summary>
            
            <remarks><para>The image processing routine represents color dithering algorithm, which is based on
            error diffusion dithering with Sierra coefficients. Error is diffused
            on 10 neighbor pixels with next coefficients:</para>
            <code lang="none">
                    | * | 5 | 3 |
            | 2 | 4 | 5 | 4 | 2 |
                | 2 | 3 | 2 |
            
            / 32
            </code>
            
            <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
            produces 4 bpp or 8 bpp indexed image, which depends on size of the specified
            <see cref="P:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">color table</see> - 4 bpp result for
            color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
            
            <para>Sample usage:</para>
            <code>
            // create dithering routine (use default color table)
            SierraColorDithering dithering = new SierraColorDithering( );
            // apply the dithering routine
            Bitmap newImage = dithering.Apply( image );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\color_sierra.png" width="480" height="361" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.ColorReduction.BurkesColorDithering"/>
            <seealso cref="T:Accord.Imaging.ColorReduction.FloydSteinbergColorDithering"/>
            <seealso cref="T:Accord.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering"/>
            <seealso cref="T:Accord.Imaging.ColorReduction.StuckiColorDithering"/>
            
        </member>
        <member name="M:Accord.Imaging.ColorReduction.SierraColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ColorReduction.SierraColorDithering"/> class.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.ColorReduction.StuckiColorDithering">
             <summary>
             Color dithering using Stucki error diffusion.
             </summary>
             
             <remarks><para>The image processing routine represents color dithering algorithm, which is based on
             error diffusion dithering with Stucki coefficients. Error is diffused
             on 12 neighbor pixels with next coefficients:</para>
             <code lang="none">
                     | * | 8 | 4 |
             | 2 | 4 | 8 | 4 | 2 |
             | 1 | 2 | 4 | 2 | 1 |
             
             / 42
             </code>
             
             <para>The image processing routine accepts 24/32 bpp color images for processing. As a result this routine
             produces 4 bpp or 8 bpp indexed image, which depends on size of the specified
             <see cref="P:Accord.Imaging.ColorReduction.ErrorDiffusionColorDithering.ColorTable">color table</see> - 4 bpp result for
             color tables with 16 colors or less; 8 bpp result for larger color tables.</para>
             
             <para>Sample usage:</para>
             <code>
             // create color image quantization routine
             ColorImageQuantizer ciq = new ColorImageQuantizer( new MedianCutQuantizer( ) );
             // create 64 colors table
             Color[] colorTable = ciq.CalculatePalette( image, 64 );
             // create dithering routine
             StuckiColorDithering dithering = new StuckiColorDithering( );
             dithering.ColorTable = colorTable;
             // apply the dithering routine
             Bitmap newImage = dithering.Apply( image );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample1.jpg" width="480" height="361" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\color_stucki.png" width="480" height="361" />
             </remarks>
            
             <seealso cref="T:Accord.Imaging.ColorReduction.BurkesColorDithering"/>
             <seealso cref="T:Accord.Imaging.ColorReduction.FloydSteinbergColorDithering"/>
             <seealso cref="T:Accord.Imaging.ColorReduction.JarvisJudiceNinkeColorDithering"/>
             <seealso cref="T:Accord.Imaging.ColorReduction.SierraColorDithering"/>
             
        </member>
        <member name="M:Accord.Imaging.ColorReduction.StuckiColorDithering.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ColorReduction.StuckiColorDithering"/> class.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.ComplexFilters.FrequencyFilter">
            <summary>
            Filtering of frequencies outside of specified range in complex Fourier
            transformed image.
            </summary>
            
            <remarks><para>The filer keeps only specified range of frequencies in complex
            Fourier transformed image. The rest of frequencies are zeroed.</para>
            
            <para>Sample usage:</para>
            <code>
            // create complex image
            ComplexImage complexImage = ComplexImage.FromBitmap( image );
            // do forward Fourier transformation
            complexImage.ForwardFourierTransform( );
            // create filter
            FrequencyFilter filter = new FrequencyFilter( new IntRange( 20, 128 ) );
            // apply filter
            filter.Apply( complexImage );
            // do backward Fourier transformation
            complexImage.BackwardFourierTransform( );
            // get complex image as bitmat
            Bitmap fourierImage = complexImage.ToBitmap( );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample3.jpg" width="256" height="256" />
            <para><b>Fourier image:</b></para>
            <img src="..\images\imaging\frequency_filter.jpg" width="256" height="256" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ComplexFilters.FrequencyFilter.FrequencyRange">
            <summary>
            Range of frequencies to keep.
            </summary>
            
            <remarks><para>The range specifies the range of frequencies to keep. Values is frequencies
            outside of this range are zeroed.</para>
            
            <para>Default value is set to <b>[0, 1024]</b>.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.ComplexFilters.FrequencyFilter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ComplexFilters.FrequencyFilter"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ComplexFilters.FrequencyFilter.#ctor(Accord.IntRange)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ComplexFilters.FrequencyFilter"/> class.
            </summary>
            
            <param name="frequencyRange">Range of frequencies to keep.</param>
            
        </member>
        <member name="M:Accord.Imaging.ComplexFilters.FrequencyFilter.Apply(Accord.Imaging.ComplexImage)">
            <summary>
            Apply filter to complex image.
            </summary>
            
            <param name="complexImage">Complex image to apply filter to.</param>
            
            <exception cref="T:System.ArgumentException">The source complex image should be Fourier transformed.</exception>
            
        </member>
        <member name="T:Accord.Imaging.ComplexFilters.IComplexFilter">
            <summary>
            Image processing filter, which operates with Fourier transformed
            complex image.
            </summary>
            
            <remarks>The interface defines the set of methods, which should be
            provided by all image processing filter, which operate with Fourier
            transformed complex image.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.ComplexFilters.IComplexFilter.Apply(Accord.Imaging.ComplexImage)">
            <summary>
            Apply filter to complex image.
            </summary>
            
            <param name="complexImage">Complex image to apply filter to.</param>
            
        </member>
        <member name="T:Accord.Imaging.ComplexImage">
            <summary>
            Complex image.
            </summary>
            
            <remarks><para>The class is used to keep image represented in complex numbers sutable for Fourier
            transformations.</para>
            
            <para>Sample usage:</para>
            <code>
            // create complex image
            ComplexImage complexImage = ComplexImage.FromBitmap( image );
            // do forward Fourier transformation
            complexImage.ForwardFourierTransform( );
            // get complex image as bitmat
            Bitmap fourierImage = complexImage.ToBitmap( );
            </code>
            
            <para><b>Initial image:</b></para>
            <img src="..\images\imaging\sample3.jpg" width="256" height="256" />
            <para><b>Fourier image:</b></para>
            <img src="..\images\imaging\fourier.jpg" width="256" height="256" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ComplexImage.Width">
            <summary>
            Image width.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ComplexImage.Height">
            <summary>
            Image height.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ComplexImage.FourierTransformed">
            <summary>
            Status of the image - Fourier transformed or not.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ComplexImage.Data">
            <summary>
            Complex image's data.
            </summary>
            
            <remarks>Return's 2D array of [<b>height</b>, <b>width</b>] size, which keeps image's
            complex data.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.ComplexImage.#ctor(System.Int32,System.Int32)">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.ComplexImage"/> class.
             </summary>
             
             <param name="width">Image width.</param>
             <param name="height">Image height.</param>
             
             <remarks>The constractor is protected, what makes it imposible to instantiate this
             class directly. To create an instance of this class <see cref="M:Accord.Imaging.ComplexImage.FromBitmap(System.Drawing.Bitmap)"/> or
             <see cref="M:Accord.Imaging.ComplexImage.FromBitmap(System.Drawing.Imaging.BitmapData)"/> method should be used.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.ComplexImage.Clone">
            <summary>
            Clone the complex image.
            </summary>
            
            <returns>Returns copy of the complex image.</returns>
            
        </member>
        <member name="M:Accord.Imaging.ComplexImage.FromBitmap(System.Drawing.Bitmap)">
            <summary>
            Create complex image from grayscale bitmap.
            </summary>
            
            <param name="image">Source grayscale bitmap (8 bpp indexed).</param>
            
            <returns>Returns an instance of complex image.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Image width and height should be power of 2.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ComplexImage.FromBitmap(System.Drawing.Imaging.BitmapData)">
            <summary>
            Create complex image from grayscale bitmap.
            </summary>
            
            <param name="imageData">Source image data (8 bpp indexed).</param>
            
            <returns>Returns an instance of complex image.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Image width and height should be power of 2.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ComplexImage.ToBitmap">
            <summary>
            Convert complex image to bitmap.
            </summary>
            
            <returns>Returns grayscale bitmap.</returns>
            
        </member>
        <member name="M:Accord.Imaging.ComplexImage.ForwardFourierTransform">
            <summary>
            Applies forward fast Fourier transformation to the complex image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ComplexImage.BackwardFourierTransform">
            <summary>
            Applies backward fast Fourier transformation to the complex image.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.DocumentSkewChecker">
             <summary>
             Skew angle checker for scanned documents.
             </summary>
            
             <remarks><para>The class implements document's skew checking algorithm, which is based
             on <see cref="T:Accord.Imaging.HoughLineTransformation">Hough line transformation</see>. The algorithm
             is based on searching for text base lines - black line of text bottoms' followed
             by white line below.</para>
             
             <para><note>The routine supposes that a white-background document is provided
             with black letters. The algorithm is not supposed for any type of objects, but for
             document images with text.</note></para>
             
             <para>The range of angles to detect is controlled by <see cref="P:Accord.Imaging.DocumentSkewChecker.MaxSkewToDetect"/> property.</para>
             
             <para>The filter accepts 8 bpp grayscale images for processing.</para>
             
             <para>Sample usage:</para>
             <code>
             // create instance of skew checker
             DocumentSkewChecker skewChecker = new DocumentSkewChecker( );
             // get documents skew angle
             double angle = skewChecker.GetSkewAngle( documentImage );
             // create rotation filter
             RotateBilinear rotationFilter = new RotateBilinear( -angle );
             rotationFilter.FillColor = Color.White;
             // rotate image applying the filter
             Bitmap rotatedImage = rotationFilter.Apply( documentImage );
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample10.png" width="300" height="184" />
             <para><b>Deskewed image:</b></para>
             <img src="..\images\imaging\deskew.png" width="335" height="250" /> 
             </remarks>
             
             <seealso cref="T:Accord.Imaging.HoughLineTransformation"/>
            
        </member>
        <member name="P:Accord.Imaging.DocumentSkewChecker.StepsPerDegree">
            <summary>
            Steps per degree, [1, 10].
            </summary>
            
            <remarks><para>The value defines quality of Hough transform and its ability to detect
            line slope precisely.</para>
            
            <para>Default value is set to <b>1</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.DocumentSkewChecker.MaxSkewToDetect">
             <summary>
             Maximum skew angle to detect, [0, 45] degrees.
             </summary>
             
             <remarks><para>The value sets maximum document's skew angle to detect.
             Document's skew angle can be as positive (rotated counter clockwise), as negative
             (rotated clockwise). So setting this value to 25, for example, will lead to
             [-25, 25] degrees detection range.</para>
            
             <para>Scanned documents usually have skew in the [-20, 20] degrees range.</para>
             
             <para>Default value is set to <b>30</b>.</para>
             </remarks>
             
        </member>
        <member name="P:Accord.Imaging.DocumentSkewChecker.MinBeta">
             <summary>
             Minimum angle to detect skew in degrees.
             </summary>
            
             <remarks><para><note>The property is deprecated and setting it has not any effect.
             Use <see cref="P:Accord.Imaging.DocumentSkewChecker.MaxSkewToDetect"/> property instead.</note></para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.DocumentSkewChecker.MaxBeta">
             <summary>
             Maximum angle to detect skew in degrees.
             </summary>
            
             <remarks><para><note>The property is deprecated and setting it has not any effect.
             Use <see cref="P:Accord.Imaging.DocumentSkewChecker.MaxSkewToDetect"/> property instead.</note></para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.DocumentSkewChecker.LocalPeakRadius">
            <summary>
            Radius for searching local peak value, [1, 10].
            </summary>
            
            <remarks><para>The value determines radius around a map's value, which is analyzed to determine
            if the map's value is a local maximum in specified area.</para>
            
            <para>Default value is set to <b>4</b>.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.DocumentSkewChecker.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.DocumentSkewChecker"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.DocumentSkewChecker.GetSkewAngle(System.Drawing.Bitmap)">
            <summary>
            Get skew angle of the provided document image.
            </summary>
            
            <param name="image">Document's image to get skew angle of.</param>
            
            <returns>Returns document's skew angle. If the returned angle equals to -90,
            then document skew detection has failed.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.DocumentSkewChecker.GetSkewAngle(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Get skew angle of the provided document image.
            </summary>
            
            <param name="image">Document's image to get skew angle of.</param>
            <param name="rect">Image's rectangle to process (used to exclude processing of
            regions, which are not relevant to skew detection).</param>
            
            <returns>Returns document's skew angle. If the returned angle equals to -90,
            then document skew detection has failed.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.DocumentSkewChecker.GetSkewAngle(System.Drawing.Imaging.BitmapData)">
            <summary>
            Get skew angle of the provided document image.
            </summary>
            
            <param name="imageData">Document's image data to get skew angle of.</param>
            
            <returns>Returns document's skew angle. If the returned angle equals to -90,
            then document skew detection has failed.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.DocumentSkewChecker.GetSkewAngle(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Get skew angle of the provided document image.
            </summary>
            
            <param name="imageData">Document's image data to get skew angle of.</param>
            <param name="rect">Image's rectangle to process (used to exclude processing of
            regions, which are not relevant to skew detection).</param>
            
            <returns>Returns document's skew angle. If the returned angle equals to -90,
            then document skew detection has failed.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.DocumentSkewChecker.GetSkewAngle(Accord.Imaging.UnmanagedImage)">
            <summary>
            Get skew angle of the provided document image.
            </summary>
            
            <param name="image">Document's unmanaged image to get skew angle of.</param>
            
            <returns>Returns document's skew angle. If the returned angle equals to -90,
            then document skew detection has failed.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.DocumentSkewChecker.GetSkewAngle(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Get skew angle of the provided document image.
            </summary>
            
            <param name="image">Document's unmanaged image to get skew angle of.</param>
            <param name="rect">Image's rectangle to process (used to exclude processing of
            regions, which are not relevant to skew detection).</param>
            
            <returns>Returns document's skew angle. If the returned angle equals to -90,
            then document skew detection has failed.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="T:Accord.Imaging.Drawing">
            <summary>
            Drawing primitives.
            </summary>
            
            <remarks><para>The class allows to do drawing of some primitives directly on
            locked image data or unmanaged image.</para>
            
            <para><note>All methods of this class support drawing only on color 24/32 bpp images and
            on grayscale 8 bpp indexed images.</note></para>
            
            <para><note>When it comes to alpha blending for 24/32 bpp images, all calculations are done
            as described on <a href="http://en.wikipedia.org/wiki/Alpha_compositing#Description">Wikipeadia</a>
            (see "over" operator).</note></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Drawing.FillRectangle(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle,System.Drawing.Color)">
            <summary>
            Fill rectangle on the specified image.
            </summary>
            
            <param name="imageData">Source image data to draw on.</param>
            <param name="rectangle">Rectangle's coordinates to fill.</param>
            <param name="color">Rectangle's color.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Drawing.FillRectangle(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle,System.Drawing.Color)">
            <summary>
            Fill rectangle on the specified image.
            </summary>
            
            <param name="image">Source image to draw on.</param>
            <param name="rectangle">Rectangle's coordinates to fill.</param>
            <param name="color">Rectangle's color.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Drawing.Rectangle(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle,System.Drawing.Color)">
            <summary>
            Draw rectangle on the specified image.
            </summary>
            
            <param name="imageData">Source image data to draw on.</param>
            <param name="rectangle">Rectangle's coordinates to draw.</param>
            <param name="color">Rectangle's color.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Drawing.Rectangle(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle,System.Drawing.Color)">
            <summary>
            Draw rectangle on the specified image.
            </summary>
            
            <param name="image">Source image to draw on.</param>
            <param name="rectangle">Rectangle's coordinates to draw.</param>
            <param name="color">Rectangle's color.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Drawing.Line(System.Drawing.Imaging.BitmapData,Accord.IntPoint,Accord.IntPoint,System.Drawing.Color)">
            <summary>
            Draw a line on the specified image.
            </summary>
            
            <param name="imageData">Source image data to draw on.</param>
            <param name="point1">The first point to connect.</param>
            <param name="point2">The second point to connect.</param>
            <param name="color">Line's color.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Drawing.Line(Accord.Imaging.UnmanagedImage,Accord.IntPoint,Accord.IntPoint,System.Drawing.Color)">
            <summary>
            Draw a line on the specified image.
            </summary>
            
            <param name="image">Source image to draw on.</param>
            <param name="point1">The first point to connect.</param>
            <param name="point2">The second point to connect.</param>
            <param name="color">Line's color.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Drawing.Polygon(System.Drawing.Imaging.BitmapData,System.Collections.Generic.List{Accord.IntPoint},System.Drawing.Color)">
            <summary>
            Draw a polygon on the specified image.
            </summary>
            
            <param name="imageData">Source image data to draw on.</param>
            <param name="points">Points of the polygon to draw.</param>
            <param name="color">Polygon's color.</param>
            
            <remarks><para>The method draws a polygon by connecting all points from the
            first one to the last one and then connecting the last point with the first one.
            </para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Drawing.Polygon(Accord.Imaging.UnmanagedImage,System.Collections.Generic.List{Accord.IntPoint},System.Drawing.Color)">
            <summary>
            Draw a polygon on the specified image.
            </summary>
            
            <param name="image">Source image to draw on.</param>
            <param name="points">Points of the polygon to draw.</param>
            <param name="color">Polygon's color.</param>
            
            <remarks><para>The method draws a polygon by connecting all points from the
            first one to the last one and then connecting the last point with the first one.
            </para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Drawing.Polyline(System.Drawing.Imaging.BitmapData,System.Collections.Generic.List{Accord.IntPoint},System.Drawing.Color)">
            <summary>
            Draw a polyline on the specified image.
            </summary>
            
            <param name="imageData">Source image data to draw on.</param>
            <param name="points">Points of the polyline to draw.</param>
            <param name="color">polyline's color.</param>
            
            <remarks><para>The method draws a polyline by connecting all points from the
            first one to the last one. Unlike <see cref="M:Accord.Imaging.Drawing.Polygon(System.Drawing.Imaging.BitmapData,System.Collections.Generic.List{Accord.IntPoint},System.Drawing.Color)"/>
            method, this method does not connect the last point with the first one.
            </para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Drawing.Polyline(Accord.Imaging.UnmanagedImage,System.Collections.Generic.List{Accord.IntPoint},System.Drawing.Color)">
            <summary>
            Draw a polyline on the specified image.
            </summary>
            
            <param name="image">Source image to draw on.</param>
            <param name="points">Points of the polyline to draw.</param>
            <param name="color">polyline's color.</param>
            
            <remarks><para>The method draws a polyline by connecting all points from the
            first one to the last one. Unlike <see cref="M:Accord.Imaging.Drawing.Polygon(Accord.Imaging.UnmanagedImage,System.Collections.Generic.List{Accord.IntPoint},System.Drawing.Color)"/>
            method, this method does not connect the last point with the first one.
            </para></remarks>
            
        </member>
        <member name="T:Accord.Imaging.UnsupportedImageFormatException">
            <summary>
            Unsupported image format exception.
            </summary>
            
            <remarks><para>The unsupported image format exception is thrown in the case when
            user passes an image of certain format to an image processing routine, which does
            not support the format. Check documentation of the image processing routine
            to discover which formats are supported by the routine.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnsupportedImageFormatException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.UnsupportedImageFormatException"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.UnsupportedImageFormatException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.UnsupportedImageFormatException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            
        </member>
        <member name="M:Accord.Imaging.UnsupportedImageFormatException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.UnsupportedImageFormatException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            <param name="paramName">Name of the invalid parameter.</param>
            
        </member>
        <member name="T:Accord.Imaging.InvalidImagePropertiesException">
            <summary>
            Invalid image properties exception.
            </summary>
            
            <remarks><para>The invalid image properties exception is thrown in the case when
            user provides an image with certain properties, which are treated as invalid by
            particular image processing routine. Another case when this exception is
            thrown is the case when user tries to access some properties of an image (or
            of a recently processed image by some routine), which are not valid for that image.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.InvalidImagePropertiesException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.InvalidImagePropertiesException"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.InvalidImagePropertiesException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.InvalidImagePropertiesException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            
        </member>
        <member name="M:Accord.Imaging.InvalidImagePropertiesException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.InvalidImagePropertiesException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            <param name="paramName">Name of the invalid parameter.</param>
            
        </member>
        <member name="T:Accord.Imaging.ExhaustiveBlockMatching">
            <summary>
            Block matching implementation with the exhaustive search algorithm.
            </summary>
            
            <remarks><para>The class implements exhaustive search block matching algorithm
            (see documentation for <see cref="T:Accord.Imaging.IBlockMatching"/> for information about
            block matching algorithms). Exhaustive search algorithm tests each possible
            location of block within search window trying to find a match with minimal
            difference.</para>
            
            <para><note>Because of the exhaustive nature of the algorithm, high performance
            should not be expected in the case if big number of reference points is provided
            or big block size and search radius are specified. Minimizing theses values increases
            performance. But too small block size and search radius may affect quality.</note></para>
            
            <para><note>The class processes only grayscale (8 bpp indexed) and color (24 bpp) images.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // collect reference points using corners detector (for example)
            SusanCornersDetector scd = new SusanCornersDetector( 30, 18 );
            List&lt;IntPoint&gt; points = scd.ProcessImage( sourceImage );
            
            // create block matching algorithm's instance
            ExhaustiveBlockMatching bm = new ExhaustiveBlockMatching( 8, 12 );
            // process images searching for block matchings
            List&lt;BlockMatch&gt; matches = bm.ProcessImage( sourceImage, points, searchImage );
            
            // draw displacement vectors
            BitmapData data = sourceImage.LockBits(
                new Rectangle( 0, 0, sourceImage.Width, sourceImage.Height ),
                ImageLockMode.ReadWrite, sourceImage.PixelFormat );
            
            foreach ( BlockMatch match in matches )
            {
                // highlight the original point in source image
                Drawing.FillRectangle( data,
                    new Rectangle( match.SourcePoint.X - 1, match.SourcePoint.Y - 1, 3, 3 ),
                    Color.Yellow );
                // draw line to the point in search image
                Drawing.Line( data, match.SourcePoint, match.MatchPoint, Color.Red );
            
                // check similarity
                if ( match.Similarity > 0.98f )
                {
                    // process block with high similarity somehow special
                }
            }
            
            sourceImage.UnlockBits( data );
            </code>
            
            <para><b>Test image 1 (source):</b></para>
            <img src="..\images\imaging\ebm_sample1.png" width="217" height="192" />
            <para><b>Test image 2 (search):</b></para>
            <img src="..\images\imaging\ebm_sample2.png" width="217" height="192" />
            <para><b>Result image:</b></para>
            <img src="..\images\imaging\ebm_result.png" width="217" height="192" />
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ExhaustiveBlockMatching.SearchRadius">
            <summary>
            Search radius.
            </summary>
            
            <remarks><para>The value specifies the shift from reference point in all
            four directions, used to search for the best matching block.</para>
            
            <para>Default value is set to <b>12</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ExhaustiveBlockMatching.BlockSize">
            <summary>
            Block size to search for.
            </summary>
            
            <remarks><para>The value specifies block size to search for. For each provided
            reference pointer, a square block of this size is taken from the source image
            (reference point becomes the coordinate of block's center) and the best match
            is searched in second image within specified <see cref="P:Accord.Imaging.ExhaustiveBlockMatching.SearchRadius">search
            radius</see>.</para>
            
            <para>Default value is set to <b>16</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ExhaustiveBlockMatching.SimilarityThreshold">
            <summary>
            Similarity threshold, [0..1].
            </summary>
            
            <remarks><para>The property sets the minimal acceptable similarity between blocks
            in source and search images. If similarity is lower than this value,
            then the candidate block in search image is not treated as a match for the block
            in source image.
            </para>
            
            <para>Default value is set to <b>0.9</b>.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.ExhaustiveBlockMatching.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ExhaustiveBlockMatching"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.ExhaustiveBlockMatching.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ExhaustiveBlockMatching"/> class.
            </summary>
            
            <param name="blockSize">Block size to search for.</param>
            <param name="searchRadius">Search radius.</param>
            
        </member>
        <member name="M:Accord.Imaging.ExhaustiveBlockMatching.ProcessImage(System.Drawing.Bitmap,System.Collections.Generic.List{Accord.IntPoint},System.Drawing.Bitmap)">
            <summary>
            Process images matching blocks between hem.
            </summary>
            
            <param name="sourceImage">Source image with reference points.</param>
            <param name="coordinates">List of reference points to be matched.</param>
            <param name="searchImage">Image in which the reference points will be looked for.</param>
            
            <returns>Returns list of found block matches. The list is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Source and search images sizes must match.</exception>
            <exception cref="T:System.ArgumentException">Source images can be grayscale (8 bpp indexed) or color (24 bpp) image only.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Source and search images must have same pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ExhaustiveBlockMatching.ProcessImage(System.Drawing.Imaging.BitmapData,System.Collections.Generic.List{Accord.IntPoint},System.Drawing.Imaging.BitmapData)">
            <summary>
            Process images matching blocks between them.
            </summary>
            
            <param name="sourceImageData">Source image with reference points.</param>
            <param name="coordinates">List of reference points to be matched.</param>
            <param name="searchImageData">Image in which the reference points will be looked for.</param>
            
            <returns>Returns list of found block matches. The list is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Source and search images sizes must match.</exception>
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source images can be grayscale (8 bpp indexed) or color (24 bpp) image only.</exception>
            <exception cref="T:System.ArgumentException">Source and search images must have same pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ExhaustiveBlockMatching.ProcessImage(Accord.Imaging.UnmanagedImage,System.Collections.Generic.List{Accord.IntPoint},Accord.Imaging.UnmanagedImage)">
            <summary>
            Process images matching blocks between them.
            </summary>
            
            <param name="sourceImage">Source unmanaged image with reference points.</param>
            <param name="coordinates">List of reference points to be matched.</param>
            <param name="searchImage">Unmanaged image in which the reference points will be looked for.</param>
            
            <returns>Returns list of found block matches. The list is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Source and search images sizes must match.</exception>
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source images can be grayscale (8 bpp indexed) or color (24 bpp) image only.</exception>
            <exception cref="T:System.ArgumentException">Source and search images must have same pixel format.</exception>
            
        </member>
        <member name="T:Accord.Imaging.ExhaustiveTemplateMatching">
            <summary>
            Exhaustive template matching.
            </summary>
            
            <remarks><para>The class implements exhaustive template matching algorithm,
            which performs complete scan of source image, comparing each pixel with corresponding
            pixel of template.</para>
            
            <para>The class processes only grayscale 8 bpp and color 24 bpp images.</para>
            </remarks>
            
            <example>
            <para>Sample usage:</para>
            <code>
            // create template matching algorithm's instance
            var tm = new ExhaustiveTemplateMatching(0.9f);
            
            // find all matchings with specified above similarity
            TemplateMatch[] matchings = tm.ProcessImage(sourceImage, templateImage);
            
            // highlight found matchings
            BitmapData data = sourceImage.LockBits(ImageLockMode.ReadWrite);
            
            foreach (TemplateMatch m in matchings)
            {
                Drawing.Rectangle(data, m.Rectangle, Color.White);
                
                // do something else with the matching
            }
            
            sourceImage.UnlockBits(data);
            </code>
            
            <para>The class also can be used to get similarity level between two image of the same
            size, which can be useful to get information about how different/similar are images:</para>
            
            <code>
            // create template matching algorithm's instance
            // use zero similarity to make sure algorithm will provide anything
            ExhaustiveTemplateMatching tm = new ExhaustiveTemplateMatching(0);
            
            // compare two images
            TemplateMatch[] matchings = tm.ProcessImage(image1, image2);
            
            // check similarity level
            if (matchings[0].Similarity > 0.95f)
            {
                // do something with quite similar images
            }
            </code>
            </example>
            
        </member>
        <member name="P:Accord.Imaging.ExhaustiveTemplateMatching.SimilarityThreshold">
            <summary>
            Similarity threshold, [0..1].
            </summary>
            
            <remarks><para>The property sets the minimal acceptable similarity between template
            and potential found candidate. If similarity is lower than this value,
            then object is not treated as matching with template.
            </para>
            
            <para>Default value is set to <b>0.9</b>.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.ExhaustiveTemplateMatching.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ExhaustiveTemplateMatching"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ExhaustiveTemplateMatching.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ExhaustiveTemplateMatching"/> class.
            </summary>
            
            <param name="similarityThreshold">Similarity threshold.</param>
            
        </member>
        <member name="M:Accord.Imaging.ExhaustiveTemplateMatching.ProcessImage(System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="template">Template image to search for.</param>
            
            <returns>Returns array of found template matches. The array is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Template image is bigger than source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ExhaustiveTemplateMatching.ProcessImage(System.Drawing.Bitmap,System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="template">Template image to search for.</param>
            <param name="searchZone">Rectangle in source image to search template for.</param>
            
            <returns>Returns array of found template matches. The array is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Template image is bigger than source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ExhaustiveTemplateMatching.ProcessImage(System.Drawing.Imaging.BitmapData,System.Drawing.Imaging.BitmapData)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            <param name="templateData">Template image to search for.</param>
            
            <returns>Returns array of found template matches. The array is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Template image is bigger than source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ExhaustiveTemplateMatching.ProcessImage(System.Drawing.Imaging.BitmapData,System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            <param name="templateData">Template image to search for.</param>
            <param name="searchZone">Rectangle in source image to search template for.</param>
            
            <returns>Returns array of found template matches. The array is sorted by similarity
            of found matches in descending order.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Template image is bigger than source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ExhaustiveTemplateMatching.ProcessImage(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
             <summary>
             Process image looking for matchings with specified template.
             </summary>
             
             <param name="image">Unmanaged source image to process.</param>
             <param name="template">Unmanaged template image to search for.</param>
             
             <returns>Returns array of found template matches. The array is sorted by similarity
             of found matches in descending order.</returns>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Template image is bigger than source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ExhaustiveTemplateMatching.ProcessImage(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
             <summary>
             Process image looking for matchings with specified template.
             </summary>
             
             <param name="image">Unmanaged source image to process.</param>
             <param name="template">Unmanaged template image to search for.</param>
             <param name="searchZone">Rectangle in source image to search template for.</param>
             
             <returns>Returns array of found template matches. The array is sorted by similarity
             of found matches in descending order.</returns>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
             <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Template image is bigger than search zone.</exception>
            
        </member>
        <member name="T:Accord.Imaging.IBlobsFilter">
             <summary>
             Interface for custom blobs' filters used for filtering blobs after
             blob counting.
             </summary>
             
             <remarks><para>The interface should be implemented by classes, which perform
             custom blobs' filtering different from default filtering implemented in
             <see cref="T:Accord.Imaging.BlobCounterBase"/>. See <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter"/>
             for additional information.</para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.IBlobsFilter.Check(Accord.Imaging.Blob)">
             <summary>
             Check specified blob and decide if should be kept or not.
             </summary>
             
             <param name="blob">Blob to check.</param>
             
             <returns>Return <see langword="true"/> if the blob should be kept or
             <see langword="false"/> if it should be removed.</returns>
            
        </member>
        <member name="T:Accord.Imaging.HorizontalIntensityStatistics">
            <summary>
            Horizontal intensity statistics.
            </summary>
            
            <remarks><para>The class provides information about horizontal distribution
            of pixel intensities, which may be used to locate objects, their centers, etc.
            </para>
            
            <para>The class accepts grayscale (8 bpp indexed and 16 bpp) and color (24, 32, 48 and 64 bpp) images.
            In the case of 32 and 64 bpp color images, the alpha channel is not processed - statistics is not
            gathered for this channel.</para>
            
            <para>Sample usage:</para>
            <code>
            // collect statistics
            HorizontalIntensityStatistics his = new HorizontalIntensityStatistics( sourceImage );
            // get gray histogram (for grayscale image)
            Histogram histogram = his.Gray;
            // output some histogram's information
            System.Diagnostics.Debug.WriteLine( "Mean = " + histogram.Mean );
            System.Diagnostics.Debug.WriteLine( "Min = " + histogram.Min );
            System.Diagnostics.Debug.WriteLine( "Max = " + histogram.Max );
            </code>
            
            <para><b>Sample grayscale image with its horizontal intensity histogram:</b></para>
            <img src="..\images\imaging\hor_histogram.jpg" width="320" height="338" />
            </remarks>
            
            <seealso cref="T:Accord.Imaging.VerticalIntensityStatistics"/>
            
        </member>
        <member name="P:Accord.Imaging.HorizontalIntensityStatistics.Red">
            <summary>
            Histogram for red channel.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HorizontalIntensityStatistics.Green">
            <summary>
            Histogram for green channel.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HorizontalIntensityStatistics.Blue">
            <summary>
            Histogram for blue channel.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HorizontalIntensityStatistics.Gray">
            <summary>
            Histogram for gray channel (intensities).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HorizontalIntensityStatistics.IsGrayscale">
            <summary>
            Value wich specifies if the processed image was color or grayscale.
            </summary>
            
            <remarks><para>If the property equals to <b>true</b>, then the <see cref="P:Accord.Imaging.HorizontalIntensityStatistics.Gray"/>
            property should be used to retrieve histogram for the processed grayscale image.
            Otherwise <see cref="P:Accord.Imaging.HorizontalIntensityStatistics.Red"/>, <see cref="P:Accord.Imaging.HorizontalIntensityStatistics.Green"/> and <see cref="P:Accord.Imaging.HorizontalIntensityStatistics.Blue"/> property
            should be used to retrieve histogram for particular RGB channel of the processed
            color image.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.HorizontalIntensityStatistics.#ctor(System.Drawing.Bitmap)">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.HorizontalIntensityStatistics"/> class.
             </summary>
             
             <param name="image">Source image.</param>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:Accord.Imaging.HorizontalIntensityStatistics.#ctor(System.Drawing.Imaging.BitmapData)">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.HorizontalIntensityStatistics"/> class.
             </summary>
             
             <param name="imageData">Source image data.</param>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:Accord.Imaging.HorizontalIntensityStatistics.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.HorizontalIntensityStatistics"/> class.
            </summary>
            
            <param name="image">Source unmanaged image.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.HorizontalIntensityStatistics.ProcessImage(Accord.Imaging.UnmanagedImage)">
            <summary>
            Gather horizontal intensity statistics for specified image.
            </summary>
            
            <param name="image">Source image.</param>
            
        </member>
        <member name="T:Accord.Imaging.HoughCircle">
            <summary>
            Hough circle.
            </summary>
            
            <remarks>Represents circle of Hough transform.</remarks>
            
            <seealso cref="T:Accord.Imaging.HoughCircleTransformation"/>
            
        </member>
        <member name="F:Accord.Imaging.HoughCircle.X">
            <summary>
            Circle center's X coordinate.
            </summary>
        </member>
        <member name="F:Accord.Imaging.HoughCircle.Y">
            <summary>
            Circle center's Y coordinate.
            </summary>
        </member>
        <member name="F:Accord.Imaging.HoughCircle.Radius">
            <summary>
            Circle's radius.
            </summary>
        </member>
        <member name="F:Accord.Imaging.HoughCircle.Intensity">
            <summary>
            Line's absolute intensity.
            </summary>
        </member>
        <member name="F:Accord.Imaging.HoughCircle.RelativeIntensity">
            <summary>
            Line's relative intensity.
            </summary>
        </member>
        <member name="M:Accord.Imaging.HoughCircle.#ctor(System.Int32,System.Int32,System.Int32,System.Int16,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.HoughCircle"/> class.
            </summary>
            
            <param name="x">Circle's X coordinate.</param>
            <param name="y">Circle's Y coordinate.</param>
            <param name="radius">Circle's radius.</param>
            <param name="intensity">Circle's absolute intensity.</param>
            <param name="relativeIntensity">Circle's relative intensity.</param>
            
        </member>
        <member name="M:Accord.Imaging.HoughCircle.CompareTo(System.Object)">
            <summary>
            Compare the object with another instance of this class.
            </summary>
            
            <param name="obj">Object to compare with.</param>
            
            <returns><para>A signed number indicating the relative values of this instance and <b>value</b>: 1) greater than zero - 
            this instance is greater than <b>value</b>; 2) zero - this instance is equal to <b>value</b>;
            3) greater than zero - this instance is less than <b>value</b>.</para>
            
            <para><note>The sort order is descending.</note></para></returns>
            
            <remarks>
            <para><note>Object are compared using their <see cref="F:Accord.Imaging.HoughCircle.Intensity">intensity</see> value.</note></para>
            </remarks>
            
        </member>
        <member name="T:Accord.Imaging.HoughCircleTransformation">
             <summary>
             Hough circle transformation.
             </summary>
            
             <remarks><para>The class implements Hough circle transformation, which allows to detect
             circles of specified radius in an image.</para>
             
             <para>The class accepts binary images for processing, which are represented by 8 bpp grayscale images.
             All black pixels (0 pixel's value) are treated as background, but pixels with different value are
             treated as circles' pixels.</para>
             
             <para>Sample usage:</para>
             <code>
             HoughCircleTransformation circleTransform = new HoughCircleTransformation( 35 );
             // apply Hough circle transform
             circleTransform.ProcessImage( sourceImage );
             Bitmap houghCirlceImage = circleTransform.ToBitmap( );
             // get circles using relative intensity
             HoughCircle[] circles = circleTransform.GetCirclesByRelativeIntensity( 0.5 );
             
             foreach ( HoughCircle circle in circles )
             {
                 // ...
             }
             </code>
             
             <para><b>Initial image:</b></para>
             <img src="..\images\imaging\sample8.jpg" width="400" height="300" />
             <para><b>Hough circle transformation image:</b></para>
             <img src="..\images\imaging\hough_circles.jpg" width="400" height="300" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.HoughLineTransformation"/>
             
        </member>
        <member name="P:Accord.Imaging.HoughCircleTransformation.MinCircleIntensity">
             <summary>
             Minimum circle's intensity in Hough map to recognize a circle.
             </summary>
            
             <remarks><para>The value sets minimum intensity level for a circle. If a value in Hough
             map has lower intensity, then it is not treated as a circle.</para>
             
             <para>Default value is set to <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.HoughCircleTransformation.LocalPeakRadius">
            <summary>
            Radius for searching local peak value.
            </summary>
            
            <remarks><para>The value determines radius around a map's value, which is analyzed to determine
            if the map's value is a local maximum in specified area.</para>
            
            <para>Default value is set to <b>4</b>. Minimum value is <b>1</b>. Maximum value is <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.HoughCircleTransformation.MaxIntensity">
            <summary>
            Maximum found intensity in Hough map.
            </summary>
            
            <remarks><para>The property provides maximum found circle's intensity.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.HoughCircleTransformation.CirclesCount">
            <summary>
            Found circles count.
            </summary>
            
            <remarks><para>The property provides total number of found circles, which intensity is higher (or equal to),
            than the requested <see cref="P:Accord.Imaging.HoughCircleTransformation.MinCircleIntensity">minimum intensity</see>.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.HoughCircleTransformation.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.HoughCircleTransformation"/> class.
            </summary>
            
            <param name="radiusToDetect">Circles' radius to detect.</param>
            
        </member>
        <member name="M:Accord.Imaging.HoughCircleTransformation.ProcessImage(System.Drawing.Bitmap)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="image">Source image to process.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.HoughCircleTransformation.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.HoughCircleTransformation.ProcessImage(Accord.Imaging.UnmanagedImage)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="image">Source unmanaged image to process.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.HoughCircleTransformation.ToBitmap">
            <summary>
            Ãonvert Hough map to bitmap. 
            </summary>
            
            <returns>Returns 8 bppp grayscale bitmap, which shows Hough map.</returns>
            
            <exception cref="T:System.ApplicationException">Hough transformation was not yet done by calling
            ProcessImage() method.</exception>
            
        </member>
        <member name="M:Accord.Imaging.HoughCircleTransformation.GetMostIntensiveCircles(System.Int32)">
            <summary>
            Get specified amount of circles with highest intensity.
            </summary>
            
            <param name="count">Amount of circles to get.</param>
            
            <returns>Returns arrary of most intesive circles. If there are no circles detected,
            the returned array has zero length.</returns>
            
        </member>
        <member name="M:Accord.Imaging.HoughCircleTransformation.GetCirclesByRelativeIntensity(System.Double)">
            <summary>
            Get circles with relative intensity higher then specified value.
            </summary>
            
            <param name="minRelativeIntensity">Minimum relative intesity of circles.</param>
            
            <returns>Returns arrary of most intesive circles. If there are no circles detected,
            the returned array has zero length.</returns>
            
        </member>
        <member name="T:Accord.Imaging.HoughLine">
            <summary>
              Hough line.
            </summary>
            
            <remarks>
              <para>
              Represents line of Hough Line transformation using <a href="http://en.wikipedia.org/wiki/Polar_coordinate_system">
              polar coordinates</a>. See <a href="http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates">
              Wikipedia</a> for information on how to convert polar coordinates to Cartesian coordinates.</para>
            
              <para>
              <note><see cref="T:Accord.Imaging.HoughLineTransformation">Hough Line transformation</see> does not provide
              information about lines start and end points, only slope and distance from image's center. Using
              only provided information it is not possible to draw the detected line as it exactly appears on
              the source image. But it is possible to draw a line through the entire image, which contains the
              source line (see sample code below).</note></para>
            </remarks>
            
            <example>
            <code>
            HoughLineTransformation lineTransform = new HoughLineTransformation();
            
            // apply Hough line transofrm
            lineTransform.ProcessImage(sourceImage);
            Bitmap houghLineImage = lineTransform.ToBitmap();
            
            // get lines using relative intensity
            HoughLine[] lines = lineTransform.GetLinesByRelativeIntensity(0.5);
            
            foreach (HoughLine line in lines)
            {
                // get line's radius and theta values
                int    r = line.Radius;
                double t = line.Theta;
                
                // check if line is in lower part of the image
                if (r &lt; 0)
                {
                    t += 180;
                    r = -r;
                }
                
                // convert degrees to radians
                t = (t / 180) * Math.PI;
                
                // get image centers (all coordinate are measured relative to center)
                int w2 = image.Width / 2;
                int h2 = image.Height / 2;
                
                double x0 = 0, x1 = 0, y0 = 0, y1 = 0;
                
                if (line.Theta != 0)
                {
                    // non-vertical line
                    x0 = -w2; // most left point
                    x1 = w2;  // most right point
                
                    // calculate corresponding y values
                    y0 = (-Math.Cos(t) * x0 + r) / Math.Sin(t);
                    y1 = (-Math.Cos(t) * x1 + r) / Math.Sin(t);
                }
                else
                {
                    // vertical line
                    x0 = line.Radius;
                    x1 = line.Radius;
                
                    y0 = h2;
                    y1 = -h2;
                }
                
                // draw line on the image
                Drawing.Line(sourceData,
                    new IntPoint((int)x0 + w2, h2 - (int)y0),
                    new IntPoint((int)x1 + w2, h2 - (int)y1),
                    Color.Red);
            }
            </code>
            
            <para>To clarify meaning of <see cref="F:Accord.Imaging.HoughLine.Radius"/> and <see cref="F:Accord.Imaging.HoughLine.Theta"/> values
            of detected Hough lines, let's take a look at the below sample image and
            corresponding values of radius and theta for the lines on the image:
            </para>
            
            <img src="..\images\imaging\sample15.png" width="400" height="300" />
            
            <para>
              Detected radius and theta values (color in corresponding colors):
                <list type="bullet">
                <item><font color="#FF0000">Theta = 90, R = 125, I = 249</font>;</item>
                <item><font color="#00FF00">Theta = 0, R = -170, I = 187</font> (converts to Theta = 180, R = 170);</item>
                <item><font color="#0000FF">Theta = 90, R = -58, I = 163</font> (converts to Theta = 270, R = 58);</item>
                <item><font color="#FFFF00">Theta = 101, R = -101, I = 130</font> (converts to Theta = 281, R = 101);</item>
                <item><font color="#FF8000">Theta = 0, R = 43, I = 112</font>;</item>
                <item><font color="#FF80FF">Theta = 45, R = 127, I = 82</font>.</item></list></para>
            </example>
            
            <seealso cref="T:Accord.Imaging.HoughLineTransformation"/>
            
        </member>
        <member name="F:Accord.Imaging.HoughLine.Theta">
            <summary>
            Line's slope - angle between polar axis and line's radius (normal going
            from pole to the line). Measured in degrees, [0, 180).
            </summary>
        </member>
        <member name="F:Accord.Imaging.HoughLine.Radius">
            <summary>
            Line's distance from image center, (ââ, +â).
            </summary>
            
            <remarks><note>Negative line's radius means, that the line resides in lower
            part of the polar coordinates system. This means that <see cref="F:Accord.Imaging.HoughLine.Theta"/> value
            should be increased by 180 degrees and radius should be made positive.
            </note></remarks>
            
        </member>
        <member name="F:Accord.Imaging.HoughLine.Intensity">
            <summary>
            Line's absolute intensity, (0, +â).
            </summary>
            
            <remarks><para>Line's absolute intensity is a measure, which equals
            to number of pixels detected on the line. This value is bigger for longer
            lines.</para>
            
            <para><note>The value may not be 100% reliable to measure exact number of pixels
            on the line. Although these value correlate a lot (which means they are very close
            in most cases), the intensity value may slightly vary.</note></para>
            </remarks>
            
        </member>
        <member name="F:Accord.Imaging.HoughLine.RelativeIntensity">
            <summary>
            Line's relative intensity, (0, 1].
            </summary>
            
            <remarks><para>Line's relative intensity is relation of line's <see cref="F:Accord.Imaging.HoughLine.Intensity"/>
            value to maximum found intensity. For the longest line (line with highest intesity) the
            relative intensity is set to 1. If line's relative is set 0.5, for example, this means
            its intensity is half of maximum found intensity.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.HoughLine.#ctor(System.Double,System.Int16,System.Int16,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.HoughLine"/> class.
            </summary>
            
            <param name="theta">Line's slope.</param>
            <param name="radius">Line's distance from image center.</param>
            <param name="intensity">Line's absolute intensity.</param>
            <param name="relativeIntensity">Line's relative intensity.</param>
            
        </member>
        <member name="M:Accord.Imaging.HoughLine.CompareTo(Accord.Imaging.HoughLine)">
            <summary>
            Compare the object with another instance of this class.
            </summary>
            
            <param name="other">Object to compare with.</param>
            
            <returns><para>A signed number indicating the relative values of this instance and <b>value</b>: 1) greater than zero - 
            this instance is greater than <b>value</b>; 2) zero - this instance is equal to <b>value</b>;
            3) greater than zero - this instance is less than <b>value</b>.</para>
            
            <para><note>The sort order is descending.</note></para></returns>
            
            <remarks>
            <para><note>Object are compared using their <see cref="F:Accord.Imaging.HoughLine.Intensity">intensity</see> value.</note></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.HoughLine.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.HoughLine.Draw(Accord.Imaging.UnmanagedImage,System.Drawing.Color)">
            <summary>
              Draws the line to a given image.
            </summary>
            
            <param name="image">The image where this Hough line should be drawn to.</param>
            <param name="color">The color to be used when drawing the line.</param>
            
        </member>
        <member name="T:Accord.Imaging.HoughLineTransformation">
             <summary>
             Hough line transformation.
             </summary>
            
             <remarks><para>The class implements Hough line transformation, which allows to detect
             straight lines in an image. Lines, which are found by the class, are provided in
             <a href="http://en.wikipedia.org/wiki/Polar_coordinate_system">polar coordinates system</a> -
             lines' distances from image's center and lines' slopes are provided.
             The pole of polar coordinates system is put into processing image's center and the polar
             axis is directed to the right from the pole. Lines' slope is measured in degrees and
             is actually represented by angle between polar axis and line's radius (normal going
             from pole to the line), which is measured in counter-clockwise direction.
             </para>
             
             <para><note>Found lines may have negative <see cref="F:Accord.Imaging.HoughLine.Radius">radius</see>.
             This means, that the line resides in lower part of the polar coordinates system
             and its <see cref="F:Accord.Imaging.HoughLine.Theta"/> value should be increased by 180 degrees and
             radius should be made positive.
             </note></para>
             
             <para>The class accepts binary images for processing, which are represented by 8 bpp grayscale images.
             All black pixels (0 pixel's value) are treated as background, but pixels with different value are
             treated as lines' pixels.</para>
             
             <para>See also documentation to <see cref="T:Accord.Imaging.HoughLine"/> class for additional information
             about Hough Lines.</para>
             </remarks>
             
             <example>
             <para>
               The following example shows how to apply the Hough Line Transform. The example 
               will apply it to the "sudoku.png" test image from OpenCV, as shown below:</para>
             <img src="..\images\imaging\hough-input.png" />
             
             <code source="Unit Tests\Accord.Tests.Imaging\HoughTest.cs" region="doc_apply_part1" />
             <para>
               Input image after applying the filter sequence:</para>
             <img src="..\images\imaging\hough-output0.png" />
             <para>
               Output image after the Hough transform:</para>
             <img src="..\images\imaging\hough-output1.png" />
             
             <code source="Unit Tests\Accord.Tests.Imaging\HoughTest.cs" region="doc_apply_part2" />
             <para>
               Hough lines drawn over the input image:</para>
             <img src="..\images\imaging\hough-output2.png" />
             </example>
             
             <seealso cref="T:Accord.Imaging.HoughLine"/>
             
        </member>
        <member name="P:Accord.Imaging.HoughLineTransformation.StepsPerDegree">
            <summary>
            Steps per degree.
            </summary>
            
            <remarks><para>The value defines quality of Hough line transformation and its ability to detect
            lines' slope precisely.</para>
            
            <para>Default value is set to <b>1</b>. Minimum value is <b>1</b>. Maximum value is <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.HoughLineTransformation.MinLineIntensity">
             <summary>
             Minimum <see cref="F:Accord.Imaging.HoughLine.Intensity">line's intensity</see> in Hough map to recognize a line.
             </summary>
            
             <remarks><para>The value sets minimum intensity level for a line. If a value in Hough
             map has lower intensity, then it is not treated as a line.</para>
             
             <para>Default value is set to <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.HoughLineTransformation.LocalPeakRadius">
            <summary>
            Radius for searching local peak value.
            </summary>
            
            <remarks><para>The value determines radius around a map's value, which is analyzed to determine
            if the map's value is a local maximum in specified area.</para>
            
            <para>Default value is set to <b>4</b>. Minimum value is <b>1</b>. Maximum value is <b>10</b>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.HoughLineTransformation.MaxIntensity">
            <summary>
            Maximum found <see cref="F:Accord.Imaging.HoughLine.Intensity">intensity</see> in Hough map.
            </summary>
            
            <remarks><para>The property provides maximum found line's intensity.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.HoughLineTransformation.LinesCount">
            <summary>
            Found lines count.
            </summary>
            
            <remarks><para>The property provides total number of found lines, which intensity is higher (or equal to),
            than the requested <see cref="P:Accord.Imaging.HoughLineTransformation.MinLineIntensity">minimum intensity</see>.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.HoughLineTransformation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.HoughLineTransformation"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.HoughLineTransformation.ProcessImage(System.Drawing.Bitmap)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="image">Source image to process.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.HoughLineTransformation.ProcessImage(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="rect">Image's rectangle to process.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.HoughLineTransformation.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.HoughLineTransformation.ProcessImage(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            <param name="rect">Image's rectangle to process.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.HoughLineTransformation.ProcessImage(Accord.Imaging.UnmanagedImage)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="image">Source unmanaged image to process.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.HoughLineTransformation.ProcessImage(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process an image building Hough map.
            </summary>
            
            <param name="image">Source unmanaged image to process.</param>
            <param name="rect">Image's rectangle to process.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.HoughLineTransformation.ToBitmap">
            <summary>
            Convert Hough map to bitmap. 
            </summary>
            
            <returns>Returns 8 bppp grayscale bitmap, which shows Hough map.</returns>
            
            <exception cref="T:System.ApplicationException">Hough transformation was not yet done by calling
            ProcessImage() method.</exception>
            
        </member>
        <member name="M:Accord.Imaging.HoughLineTransformation.GetMostIntensiveLines(System.Int32)">
            <summary>
            Get specified amount of lines with highest <see cref="F:Accord.Imaging.HoughLine.Intensity">intensity</see>.
            </summary>
            
            <param name="count">Amount of lines to get.</param>
            
            <returns>Returns array of most intesive lines. If there are no lines detected,
            the returned array has zero length.</returns>
            
        </member>
        <member name="M:Accord.Imaging.HoughLineTransformation.GetLinesByRelativeIntensity(System.Double)">
            <summary>
            Get lines with <see cref="F:Accord.Imaging.HoughLine.RelativeIntensity">relative intensity</see> higher then specified value.
            </summary>
            
            <param name="minRelativeIntensity">Minimum relative intesity of lines.</param>
            
            <returns>Returns array of lines. If there are no lines detected,
            the returned array has zero length.</returns>
            
        </member>
        <member name="T:Accord.Imaging.IBlockMatching">
            <summary>
            Block matching interface.
            </summary>
            
            <remarks><para>The interface specifies set of methods, which should be implemented by different
            block matching algorithms.</para>
            
            <para>Block matching algorithms work with two images - source and search image - and
            a set of reference points. For each provided reference point, the algorithm takes
            a block from source image (reference point is a coordinate of block's center) and finds
            the best match for it in search image providing its coordinate (search is done within
            search window of specified size). In other words, block matching algorithm tries to
            find new coordinates in search image of specified reference points in source image.
            </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.IBlockMatching.ProcessImage(System.Drawing.Bitmap,System.Collections.Generic.List{Accord.IntPoint},System.Drawing.Bitmap)">
            <summary>
            Process images matching blocks between them.
            </summary>
            
            <param name="sourceImage">Source image with reference points.</param>
            <param name="coordinates">List of reference points to be matched.</param>
            <param name="searchImage">Image in which the reference points will be looked for.</param>
            
            <returns>Returns list of found block matches.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IBlockMatching.ProcessImage(System.Drawing.Imaging.BitmapData,System.Collections.Generic.List{Accord.IntPoint},System.Drawing.Imaging.BitmapData)">
            <summary>
            Process images matching blocks between them.
            </summary>
            
            <param name="sourceImageData">Source image with reference points.</param>
            <param name="coordinates">List of reference points to be matched.</param>
            <param name="searchImageData">Image in which the reference points will be looked for.</param>
            
            <returns>Returns list of found block matches.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IBlockMatching.ProcessImage(Accord.Imaging.UnmanagedImage,System.Collections.Generic.List{Accord.IntPoint},Accord.Imaging.UnmanagedImage)">
            <summary>
            Process images matching blocks between them.
            </summary>
            
            <param name="sourceImage">Source unmanaged image with reference points.</param>
            <param name="coordinates">List of reference points to be matched.</param>
            <param name="searchImage">Unmanaged image in which the reference points will be looked for.</param>
            
            <returns>Returns list of found block matches.</returns>
            
        </member>
        <member name="T:Accord.Imaging.ICornersDetector">
            <summary>
            Corners detector's interface.
            </summary>
            
            <remarks><para>The interface specifies set of methods, which should be implemented by different
            corners detection algorithms.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.ICornersDetector.SupportedFormats">
            <summary>
              Gets the list of image pixel formats that are supported by 
              this extractor. The extractor will check whether the pixel
              format of any provided images are in this list to determine
              whether the image can be processed or not.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ICornersDetector.ProcessImage(System.Drawing.Bitmap)">
            <summary>
            Process image looking for corners.
            </summary>
            
            <param name="image">Source image to process.</param>
            
            <returns>Returns list of found corners (X-Y coordinates).</returns>
            
        </member>
        <member name="M:Accord.Imaging.ICornersDetector.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Process image looking for corners.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            
            <returns>Returns list of found corners (X-Y coordinates).</returns>
            
        </member>
        <member name="M:Accord.Imaging.ICornersDetector.ProcessImage(Accord.Imaging.UnmanagedImage)">
            <summary>
            Process image looking for corners.
            </summary>
            
            <param name="image">Unmanaged source image to process.</param>
            
            <returns>Returns list of found corners (X-Y coordinates).</returns>
            
        </member>
        <member name="T:Accord.Imaging.Image">
            <summary>
            Core image relatad methods.
            </summary>
            
            <remarks>All methods of this class are static and represent general routines
            used by different image processing classes.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Image.IsGrayscale(System.Drawing.Bitmap)">
            <summary>
            Check if specified 8 bpp image is grayscale.
            </summary>
            
            <param name="image">Image to check.</param>
            
            <returns>Returns <b>true</b> if the image is grayscale or <b>false</b> otherwise.</returns>
            
            <remarks>The methods checks if the image is a grayscale image of 256 gradients.
            The method first examines if the image's pixel format is
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>
            and then it examines its palette to check if the image is grayscale or not.</remarks>
            
            <seealso cref="M:Accord.Imaging.Image.IsColor8bpp(System.Drawing.Bitmap)"/>
            
        </member>
        <member name="M:Accord.Imaging.Image.IsColor8bpp(System.Drawing.Bitmap)">
            <summary>
            Check if specified 8 bpp image is contains color-indexed pixels instead of intensity values.
            </summary>
            
            <param name="image">Image to check.</param>
            
            <returns>Returns <b>true</b> if the image is color-indexed or <b>false</b> otherwise.</returns>
            
            <seealso cref="M:Accord.Imaging.Image.IsGrayscale(System.Drawing.Bitmap)"/>
            
        </member>
        <member name="M:Accord.Imaging.Image.CreateGrayscaleImage(System.Int32,System.Int32)">
            <summary>
            Create and initialize new 8 bpp grayscale image.
            </summary>
            
            <param name="width">Image width.</param>
            <param name="height">Image height.</param>
            
            <returns>Returns the created grayscale image.</returns>
            
            <remarks>The method creates new 8 bpp grayscale image and initializes its palette.
            Grayscale image is represented as
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>
            image with palette initialized to 256 gradients of gray color.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Image.SetGrayscalePalette(System.Drawing.Bitmap)">
            <summary>
            Set pallete of the 8 bpp indexed image to grayscale.
            </summary>
            
            <param name="image">Image to initialize.</param>
            
            <remarks>The method initializes palette of
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>
            image with 256 gradients of gray color.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Provided image is not 8 bpp indexed image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Image.Clone(System.Drawing.Bitmap,System.Drawing.Imaging.PixelFormat)">
             <summary>
             Clone image.
             </summary>
             
             <param name="source">Source image.</param>
             <param name="format">Pixel format of result image.</param>
             
             <returns>Returns clone of the source image with specified pixel format.</returns>
            
             <remarks>The original <see cref="M:System.Drawing.Bitmap.Clone(System.Drawing.Rectangle,System.Drawing.Imaging.PixelFormat)">Bitmap.Clone()</see>
             does not produce the desired result - it does not create a clone with specified pixel format.
             More of it, the original method does not create an actual clone - it does not create a copy
             of the image. That is why this method was implemented to provide the functionality.</remarks> 
            
        </member>
        <member name="M:Accord.Imaging.Image.Clone(System.Byte[])">
             <summary>
             Clone image.
             </summary>
             
             <param name="bytes">Source image as an array of bytes.</param>
             
             <returns>Returns clone of the source image with specified pixel format.</returns>
            
             <remarks>The original <see cref="M:System.Drawing.Bitmap.Clone(System.Drawing.Rectangle,System.Drawing.Imaging.PixelFormat)">Bitmap.Clone()</see>
             does not produce the desired result - it does not create a clone with specified pixel format.
             More of it, the original method does not create an actual clone - it does not create a copy
             of the image. That is why this method was implemented to provide the functionality.</remarks> 
            
        </member>
        <member name="M:Accord.Imaging.Image.Clone(System.Drawing.Bitmap)">
            <summary>
            Clone image.
            </summary>
            
            <param name="source">Source image.</param>
            
            <returns>Return clone of the source image.</returns>
            
            <remarks>The original <see cref="M:System.Drawing.Bitmap.Clone(System.Drawing.Rectangle,System.Drawing.Imaging.PixelFormat)">Bitmap.Clone()</see>
            does not produce the desired result - it does not create an actual clone (it does not create a copy
            of the image). That is why this method was implemented to provide the functionality.</remarks> 
            
        </member>
        <member name="M:Accord.Imaging.Image.ConvertColor8bppToGrayscale8bpp(System.Drawing.Bitmap)">
            <summary>
              Converts a 8-bpp color image into a 8-bpp grayscale image, setting its color 
              palette to grayscale and replacing palette indices with their grayscale values.
            </summary>
            
            <param name="bitmap">The bitmap to be converted.</param>
            
        </member>
        <member name="M:Accord.Imaging.Image.Clone(System.Drawing.Imaging.BitmapData)">
             <summary>
             Clone image.
             </summary>
             
             <param name="sourceData">Source image data.</param>
            
             <returns>Clones image from source image data. The message does not clone pallete in the
             case if the source image has indexed pixel format.</returns>
             
        </member>
        <member name="M:Accord.Imaging.Image.FormatImage(System.Drawing.Bitmap@)">
             <summary>
             Format an image.
             </summary>
             
             <param name="image">Source image to format.</param>
             
             <remarks><para>Formats the image to one of the formats, which are supported
             by the <b>AForge.Imaging</b> library. The image is left untouched in the
             case if it is already of
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format24bppRgb</see> or
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppRgb</see> or
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppArgb</see> or
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format48bppRgb</see> or
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format64bppArgb</see>
             format or it is <see cref="M:Accord.Imaging.Image.IsGrayscale(System.Drawing.Bitmap)">grayscale</see>, otherwise the image
             is converted to <see cref="T:System.Drawing.Imaging.PixelFormat">Format24bppRgb</see>
             format.</para>
             
             <para><note>The method is deprecated and <see cref="M:Accord.Imaging.Image.Clone(System.Drawing.Bitmap,System.Drawing.Imaging.PixelFormat)"/> method should
             be used instead with specifying desired pixel format.</note></para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Image.FromFile(System.String)">
            <summary>
            Load bitmap from file.
            </summary>
            
            <param name="fileName">File name to load bitmap from.</param>
            
            <returns>Returns loaded bitmap.</returns>
            
            <remarks><para>The method is provided as an alternative of <see cref="M:System.Drawing.Image.FromFile(System.String)"/>
            method to solve the issues of locked file. The standard .NET's method locks the source file until
            image's object is disposed, so the file can not be deleted or overwritten. This method workarounds the issue and
            does not lock the source file.</para>
            </remarks>
            
            <example>
            <code source="Unit Tests\Accord.Tests.Imaging\Formats\PNMCodecTest.cs" region="doc_load" />
            </example>
            
        </member>
        <member name="M:Accord.Imaging.Image.Convert16bppTo8bpp(System.Drawing.Bitmap)">
            <summary>
            Convert bitmap with 16 bits per plane to a bitmap with 8 bits per plane.
            </summary>
            
            <param name="bitmap">Source image to convert.</param>
            
            <returns>Returns new image which is a copy of the source image but with 8 bits per plane.</returns>
            
            <remarks><para>The routine does the next pixel format conversions:
            <list type="bullet">
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format16bppGrayScale">Format16bppGrayScale</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format8bppIndexed">Format8bppIndexed</see> with grayscale palette;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format48bppRgb">Format48bppRgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format24bppRgb">Format24bppRgb</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format64bppArgb">Format64bppArgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppArgb">Format32bppArgb</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format64bppPArgb">Format64bppPArgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppPArgb">Format32bppPArgb</see>.</item>
            </list>
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Invalid pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Image.FromUrl(System.String)">
            <summary>
            Load bitmap from URL.
            </summary>
            
            <param name="url">URL to load bitmap from.</param>
            
            <returns>Returns loaded bitmap.</returns>
            
        </member>
        <member name="M:Accord.Imaging.Image.FromUrl(System.String,System.String)">
            <summary>
            Load bitmap from URL.
            </summary>
            
            <param name="url">URL to load bitmap from.</param>
            <param name="localPath">The local directory where the file should be stored.</param>
            
            <returns>Returns loaded bitmap.</returns>
            
        </member>
        <member name="M:Accord.Imaging.Image.Convert8bppTo16bpp(System.Drawing.Bitmap)">
            <summary>
            Convert bitmap with 8 bits per plane to a bitmap with 16 bits per plane.
            </summary>
            
            <param name="bitmap">Source image to convert.</param>
            
            <returns>Returns new image which is a copy of the source image but with 16 bits per plane.</returns>
            
            <remarks><para>The routine does the next pixel format conversions:
            <list type="bullet">
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format8bppIndexed">Format8bppIndexed</see> (grayscale palette assumed) to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format16bppGrayScale">Format16bppGrayScale</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format24bppRgb">Format24bppRgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format48bppRgb">Format48bppRgb</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppArgb">Format32bppArgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format64bppArgb">Format64bppArgb</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppPArgb">Format32bppPArgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format64bppPArgb">Format64bppPArgb</see>.</item>
            </list>
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Invalid pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Image.GetPixelFormatSizeInBytes(System.Drawing.Bitmap)">
            <summary>
            Gets the color depth used in an image, in number of bytes per pixel.
            </summary>
            <param name="image">The image.</param>
        </member>
        <member name="M:Accord.Imaging.Image.GetPixelFormatSize(System.Drawing.Bitmap)">
            <summary>
            Gets the color depth used in an image, in number of bits per pixel.
            </summary>
            <param name="image">The image.</param>
        </member>
        <member name="M:Accord.Imaging.Image.GetPixelFormatSizeInBytes(Accord.Imaging.UnmanagedImage)">
            <summary>
            Gets the color depth used in an image, in number of bytes per pixel.
            </summary>
            <param name="image">The image.</param>
        </member>
        <member name="M:Accord.Imaging.Image.GetPixelFormatSize(Accord.Imaging.UnmanagedImage)">
            <summary>
            Gets the color depth used in an image, in number of bits per pixel.
            </summary>
            <param name="image">The image.</param>
        </member>
        <member name="T:Accord.Imaging.ImageStatistics">
            <summary>
            Gather statistics about image in RGB color space.
            </summary>
            
            <remarks><para>The class is used to accumulate statistical values about images,
            like histogram, mean, standard deviation, etc. for each color channel in RGB color
            space.</para>
            
            <para>The class accepts 8 bpp grayscale and 24/32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // gather statistics
            ImageStatistics stat = new ImageStatistics( image );
            // get red channel's histogram
            Histogram red = stat.Red;
            // check mean value of red channel
            if ( red.Mean > 128 )
            {
                // do further processing
            }
            </code>
            </remarks>
            
            <seealso cref="T:Accord.Statistics.Visualizations.Histogram"/>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatistics.Red">
            <summary>
            Histogram of red channel.
            </summary>
            
            <remarks><para><note>The property is valid only for color images
            (see <see cref="P:Accord.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatistics.Green">
            <summary>
            Histogram of green channel.
            </summary>
            
            <remarks><para><note>The property is valid only for color images
            (see <see cref="P:Accord.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatistics.Blue">
            <summary>
            Histogram of blue channel.
            </summary>
            
            <remarks><para><note>The property is valid only for color images
            (see <see cref="P:Accord.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatistics.Gray">
            <summary>
            Histogram of gray channel.
            </summary>
            
            <remarks><para><note>The property is valid only for grayscale images
            (see <see cref="P:Accord.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatistics.RedWithoutBlack">
            <summary>
            Histogram of red channel excluding black pixels.
            </summary>
            
            <remarks><para>The property keeps statistics about red channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            
            <para><note>The property is valid only for color images
            (see <see cref="P:Accord.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatistics.GreenWithoutBlack">
            <summary>
            Histogram of green channel excluding black pixels.
            </summary>
            
            <remarks><para>The property keeps statistics about green channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            
            <para><note>The property is valid only for color images
            (see <see cref="P:Accord.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatistics.BlueWithoutBlack">
            <summary>
            Histogram of blue channel excluding black pixels
            </summary>
            
            <remarks><para>The property keeps statistics about blue channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            
            <para><note>The property is valid only for color images
            (see <see cref="P:Accord.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatistics.GrayWithoutBlack">
            <summary>
            Histogram of gray channel channel excluding black pixels.
            </summary>
            
            <remarks><para>The property keeps statistics about gray channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            
            <para><note>The property is valid only for grayscale images
            (see <see cref="P:Accord.Imaging.ImageStatistics.IsGrayscale"/> property).</note></para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatistics.PixelsCount">
            <summary>
            Total pixels count in the processed image.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatistics.PixelsCountWithoutBlack">
            <summary>
            Total pixels count in the processed image excluding black pixels.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatistics.IsGrayscale">
            <summary>
            Value wich specifies if the processed image was color or grayscale.
            </summary>
            
            <remarks><para>If the value is set to <see langword="true"/> then <see cref="P:Accord.Imaging.ImageStatistics.Gray"/>
            property should be used to get statistics information about image. Otherwise
            <see cref="P:Accord.Imaging.ImageStatistics.Red"/>, <see cref="P:Accord.Imaging.ImageStatistics.Green"/> and <see cref="P:Accord.Imaging.ImageStatistics.Blue"/> properties should be used
            for color images.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatistics.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatistics"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatistics.#ctor(System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatistics"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask image which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask image must be a grayscale/binary (8bpp) image of the same size as the
            specified source image, where black pixels (value 0) correspond to areas which should be excluded
            from processing. So statistics is calculated only for pixels, which are none black in the mask image.
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask image must be 8 bpp grayscale image.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatistics.#ctor(System.Drawing.Bitmap,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatistics"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask array which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask array must be of the same size as the specified source image, where 0 values
            correspond to areas which should be excluded from processing. So statistics is calculated only for pixels,
            which have none zero corresponding value in the mask.
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatistics.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatistics"/> class.
            </summary>
            
            <param name="image">Unmanaged image to gather statistics about.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatistics.#ctor(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatistics"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask image which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask image must be a grayscale/binary (8bpp) image of the same size as the
            specified source image, where black pixels (value 0) correspond to areas which should be excluded
            from processing. So statistics is calculated only for pixels, which are none black in the mask image.
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask image must be 8 bpp grayscale image.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatistics.#ctor(Accord.Imaging.UnmanagedImage,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatistics"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask array which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask array must be of the same size as the specified source image, where 0 values
            correspond to areas which should be excluded from processing. So statistics is calculated only for pixels,
            which have none zero corresponding value in the mask.
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="T:Accord.Imaging.ImageStatisticsHSL">
            <summary>
            Gather statistics about image in HSL color space.
            </summary>
            
            <remarks><para>The class is used to accumulate statistical values about images,
            like histogram, mean, standard deviation, etc. for each <b>HSL</b> color channel.</para>
            
            <para>The class accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // gather statistics
            ImageStatisticsHSL stat = new ImageStatisticsHSL( image );
            // get saturation channel's histogram
            ContinuousHistogram saturation = stat.Saturation;
            // check mean value of saturation channel
            if ( saturation.Mean > 0.5 )
            {
                // do further processing
            }
            </code>
            </remarks>
            
            <seealso cref="T:Accord.Math.ContinuousHistogram"/>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsHSL.Saturation">
            <summary>
            Histogram of saturation channel.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsHSL.Luminance">
            <summary>
            Histogram of luminance channel.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsHSL.SaturationWithoutBlack">
            <summary>
            Histogram of saturation channel excluding black pixels.
            </summary>
            
            <remarks><para>The property keeps statistics about saturation channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsHSL.LuminanceWithoutBlack">
            <summary>
            Histogram of luminance channel excluding black pixels.
            </summary>
            
            <remarks><para>The property keeps statistics about luminance channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsHSL.PixelsCount">
            <summary>
            Total pixels count in the processed image.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsHSL.PixelsCountWithoutBlack">
            <summary>
            Total pixels count in the processed image excluding black pixels.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatisticsHSL.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatisticsHSL"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatisticsHSL.#ctor(System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatisticsHSL"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask image which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask image must be a grayscale/binary (8bpp) image of the same size as the
            specified source image, where black pixels (value 0) correspond to areas which should be excluded
            from processing. So statistics is calculated only for pixels, which are none black in the mask image.
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask image must be 8 bpp grayscale image.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatisticsHSL.#ctor(System.Drawing.Bitmap,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatisticsHSL"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask array which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask array must be of the same size as the specified source image, where 0 values
            correspond to areas which should be excluded from processing. So statistics is calculated only for pixels,
            which have none zero corresponding value in the mask.
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatisticsHSL.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatisticsHSL"/> class.
            </summary>
            
            <param name="image">Unmanaged image to gather statistics about.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatisticsHSL.#ctor(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatisticsHSL"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask image which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask image must be a grayscale/binary (8bpp) image of the same size as the
            specified source image, where black pixels (value 0) correspond to areas which should be excluded
            from processing. So statistics is calculated only for pixels, which are none black in the mask image.
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask image must be 8 bpp grayscale image.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatisticsHSL.#ctor(Accord.Imaging.UnmanagedImage,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatisticsHSL"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask array which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask array must be of the same size as the specified source image, where 0 values
            correspond to areas which should be excluded from processing. So statistics is calculated only for pixels,
            which have none zero corresponding value in the mask.
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="T:Accord.Imaging.ImageStatisticsYCbCr">
            <summary>
            Gather statistics about image in YCbCr color space.
            </summary>
            
            <remarks><para>The class is used to accumulate statistical values about images,
            like histogram, mean, standard deviation, etc. for each <b>YCbCr</b> color channel.</para>
            
            <para>The class accepts 24 and 32 bpp color images for processing.</para>
            
            <para>Sample usage:</para>
            <code>
            // gather statistics
            ImageStatisticsYCbCr stat = new ImageStatisticsYCbCr( image );
            // get Y channel's histogram
            ContinuousHistogram y = stat.Y;
            // check mean value of Y channel
            if ( y.Mean > 0.5 )
            {
                // do further processing
            }
            </code>
            </remarks>
            
            <seealso cref="T:Accord.Math.ContinuousHistogram"/>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsYCbCr.Y">
            <summary>
            Histogram of Y channel.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsYCbCr.Cb">
            <summary>
            Histogram of Cb channel.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsYCbCr.Cr">
            <summary>
            Histogram of Cr channel.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsYCbCr.YWithoutBlack">
            <summary>
            Histogram of Y channel excluding black pixels.
            </summary>
            
            <remarks><para>The property keeps statistics about Y channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsYCbCr.CbWithoutBlack">
            <summary>
            Histogram of Cb channel excluding black pixels
            </summary>
            
            <remarks><para>The property keeps statistics about Cb channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsYCbCr.CrWithoutBlack">
            <summary>
            Histogram of Cr channel excluding black pixels
            </summary>
            
            <remarks><para>The property keeps statistics about Cr channel, which
            excludes all black pixels, what affects mean, standard deviation, etc.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsYCbCr.PixelsCount">
            <summary>
            Total pixels count in the processed image.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ImageStatisticsYCbCr.PixelsCountWithoutBlack">
            <summary>
            Total pixels count in the processed image excluding black pixels.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatisticsYCbCr.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatisticsYCbCr"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatisticsYCbCr.#ctor(System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatisticsYCbCr"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask image which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask image must be a grayscale/binary (8bpp) image of the same size as the
            specified source image, where black pixels (value 0) correspond to areas which should be excluded
            from processing. So statistics is calculated only for pixels, which are none black in the mask image.
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask image must be 8 bpp grayscale image.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatisticsYCbCr.#ctor(System.Drawing.Bitmap,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatisticsYCbCr"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask array which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask array must be of the same size as the specified source image, where 0 values
            correspond to areas which should be excluded from processing. So statistics is calculated only for pixels,
            which have none zero corresponding value in the mask.
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatisticsYCbCr.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatisticsYCbCr"/> class.
            </summary>
            
            <param name="image">Unmanaged image to gather statistics about.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatisticsYCbCr.#ctor(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatisticsYCbCr"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask image which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask image must be a grayscale/binary (8bpp) image of the same size as the
            specified source image, where black pixels (value 0) correspond to areas which should be excluded
            from processing. So statistics is calculated only for pixels, which are none black in the mask image.
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask image must be 8 bpp grayscale image.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="M:Accord.Imaging.ImageStatisticsYCbCr.#ctor(Accord.Imaging.UnmanagedImage,System.Byte[0:,0:])">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.ImageStatisticsYCbCr"/> class.
            </summary>
            
            <param name="image">Image to gather statistics about.</param>
            <param name="mask">Mask array which specifies areas to collect statistics for.</param>
            
            <remarks><para>The mask array must be of the same size as the specified source image, where 0 values
            correspond to areas which should be excluded from processing. So statistics is calculated only for pixels,
            which have none zero corresponding value in the mask.
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Source pixel format is not supported.</exception>
            <exception cref="T:System.ArgumentException">Mask must have the same size as the source image to get statistics for.</exception>
            
        </member>
        <member name="T:Accord.Imaging.IntegralImage">
            <summary>
             Integral image.
            </summary>
            
            <remarks>
            <para>
              This class implements integral image concept, which is described by
              Viola and Jones in: <b>P. Viola and M. J. Jones, "Robust real-time face detection",
              Int. Journal of Computer Vision 57(2), pp. 137â154, 2004</b>.</para>
              
            <para>
              <i>"An integral image <b>I</b> of an input image <b>G</b> is defined as the image in which the
              intensity at a pixel position is equal to the sum of the intensities of all the pixels
              above and to the left of that position in the original image."</i></para>
              
            <para>
              The intensity at position (x, y) can be written as:</para>
              <code>
                        x    y
              I(x,y) = SUM( SUM( G(i,j) ) )
                       i=0  j=0
              </code>
              
            <para>
              <note>The class uses 32-bit integers to represent integral image.</note></para>
              
            <para>
              <note>The class processes only grayscale (8 bpp indexed) images.</note></para>
              
            <para><note>This class contains two versions of each method: safe and unsafe. Safe methods do
              checks of provided coordinates and ensure that these coordinates belong to the image, what makes
              these methods slower. Unsafe methods do not do coordinates' checks and rely that these
              coordinates belong to the image, what makes these methods faster.</note></para>
              
            <para>
              This class implements the simplest upright representation of an integral image. For an integral
              image that can represent squared integral images as well as tilted images at the same time, please 
              refer to <see cref="T:Accord.Imaging.IntegralImage2"/>.</para>
            </remarks>
            
            <example>
            <para>Sample usage:</para>
            <code>
            // create integral image
            IntegralImage im = IntegralImage.FromBitmap(image);
            
            // get pixels' mean value in the specified rectangle
            float mean = im.GetRectangleMean(10, 10, 20, 30)
            </code>
            </example>
            
            <seealso cref="T:Accord.Imaging.IntegralImage2"/>
            
        </member>
        <member name="F:Accord.Imaging.IntegralImage.matrix">
            <summary>
            Integral image's array.
            </summary>
            
            <remarks>See remarks to <see cref="P:Accord.Imaging.IntegralImage.Matrix"/> property.</remarks>
            
        </member>
        <member name="F:Accord.Imaging.IntegralImage.integralImage">
            <summary>
            Integral image's array.
            </summary>
            
            <remarks>See remarks to <see cref="P:Accord.Imaging.IntegralImage.InternalData"/> property.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.IntegralImage.Width">
            <summary>
            Width of the source image the integral image was constructed for.
            </summary>
        </member>
        <member name="P:Accord.Imaging.IntegralImage.Height">
            <summary>
            Height of the source image the integral image was constructed for.
            </summary>
        </member>
        <member name="P:Accord.Imaging.IntegralImage.Matrix">
            <summary>
            Provides access to internal array keeping integral image data.
            </summary>
            
            <remarks>
            <para><note>The array should be accessed by [y][x] indexing.</note></para>
            
            <para><note>The array's size is [<see cref="P:Accord.Imaging.IntegralImage.Height"/>+1, <see cref="P:Accord.Imaging.IntegralImage.Width"/>+1]. The first
            row and column are filled with zeros, what is done for more efficient calculation of
            rectangles' sums.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.IntegralImage.InternalData">
            <summary>
            Provides access to internal array keeping integral image data.
            </summary>
            
            <remarks>
            <para><note>The array should be accessed by [y, x] indexing.</note></para>
            
            <para><note>The array's size is [<see cref="P:Accord.Imaging.IntegralImage.Height"/>+1, <see cref="P:Accord.Imaging.IntegralImage.Width"/>+1]. The first
            row and column are filled with zeros, what is done for more efficient calculation of
            rectangles' sums.</note></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.#ctor(System.Int32,System.Int32)">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.IntegralImage"/> class.
             </summary>
             
             <param name="width">Image width.</param>
             <param name="height">Image height.</param>
             
             <remarks>The constructor is protected, what makes it impossible to instantiate this
             class directly. To create an instance of this class <see cref="M:Accord.Imaging.IntegralImage.FromBitmap(System.Drawing.Bitmap)"/> or
             <see cref="M:Accord.Imaging.IntegralImage.FromBitmap(System.Drawing.Imaging.BitmapData)"/> method should be used.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.FromBitmap(System.Drawing.Bitmap)">
            <summary>
            Construct integral image from source grayscale image.
            </summary>
            
            <param name="image">Source grayscale image.</param>
            
            <returns>Returns integral image.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.FromBitmap(System.Drawing.Imaging.BitmapData)">
            <summary>
            Construct integral image from source grayscale image.
            </summary>
            
            <param name="imageData">Source image data.</param>
            
            <returns>Returns integral image.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.FromBitmap(Accord.Imaging.UnmanagedImage)">
            <summary>
            Construct integral image from source grayscale image.
            </summary>
            
            <param name="image">Source unmanaged image.</param>
            
            <returns>Returns integral image.</returns>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">The source image has incorrect pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.GetRectangleSum(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate sum of pixels in the specified rectangle.
            </summary>
            
            <param name="x1">X coordinate of left-top rectangle's corner.</param>
            <param name="y1">Y coordinate of left-top rectangle's corner.</param>
            <param name="x2">X coordinate of right-bottom rectangle's corner.</param>
            <param name="y2">Y coordinate of right-bottom rectangle's corner.</param>
            
            <returns>Returns sum of pixels in the specified rectangle.</returns>
            
            <remarks><para>Both specified points are included into the calculation rectangle.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.GetHaarXWavelet(System.Int32,System.Int32,System.Int32)">
             <summary>
             Calculate horizontal (X) haar wavelet at the specified point.
             </summary>
             
             <param name="x">X coordinate of the point to calculate wavelet at.</param>
             <param name="y">Y coordinate of the point to calculate wavelet at.</param>
             <param name="radius">Wavelet size to calculate.</param>
             
             <returns>Returns value of the horizontal wavelet at the specified point.</returns>
            
             <remarks><para>The method calculates horizontal wavelet, which is a difference
             of two horizontally adjacent boxes' sums, i.e. <b>A-B</b>. A is the sum of rectangle with coordinates
             (x, y-radius, x+radius-1, y+radius-1). B is the sum of rectangle with coordinates
             (x-radius, y-radius, x-1, y+radius-1).</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.GetHaarYWavelet(System.Int32,System.Int32,System.Int32)">
             <summary>
             Calculate vertical (Y) haar wavelet at the specified point.
             </summary>
             
             <param name="x">X coordinate of the point to calculate wavelet at.</param>
             <param name="y">Y coordinate of the point to calculate wavelet at.</param>
             <param name="radius">Wavelet size to calculate.</param>
             
             <returns>Returns value of the vertical wavelet at the specified point.</returns>
            
             <remarks><para>The method calculates vertical wavelet, which is a difference
             of two vertical adjacent boxes' sums, i.e. <b>A-B</b>. A is the sum of rectangle with coordinates
             (x-radius, y, x+radius-1, y+radius-1). B is the sum of rectangle with coordinates
             (x-radius, y-radius, x+radius-1, y-1).</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.GetRectangleSumUnsafe(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate sum of pixels in the specified rectangle without checking it's coordinates.
            </summary>
            
            <param name="x1">X coordinate of left-top rectangle's corner.</param>
            <param name="y1">Y coordinate of left-top rectangle's corner.</param>
            <param name="x2">X coordinate of right-bottom rectangle's corner.</param>
            <param name="y2">Y coordinate of right-bottom rectangle's corner.</param>
            
            <returns>Returns sum of pixels in the specified rectangle.</returns>
            
            <remarks><para>Both specified points are included into the calculation rectangle.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.GetRectangleSum(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate sum of pixels in the specified rectangle.
            </summary>
            
            <param name="x">X coordinate of central point of the rectangle.</param>
            <param name="y">Y coordinate of central point of the rectangle.</param>
            <param name="radius">Radius of the rectangle.</param>
            
            <returns>Returns sum of pixels in the specified rectangle.</returns>
            
            <remarks><para>The method calculates sum of pixels in square rectangle with
            odd width and height. In the case if it is required to calculate sum of
            3x3 rectangle, then it is required to specify its center and radius equal to 1.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.GetRectangleSumUnsafe(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate sum of pixels in the specified rectangle without checking it's coordinates.
            </summary>
            
            <param name="x">X coordinate of central point of the rectangle.</param>
            <param name="y">Y coordinate of central point of the rectangle.</param>
            <param name="radius">Radius of the rectangle.</param>
            
            <returns>Returns sum of pixels in the specified rectangle.</returns>
            
            <remarks><para>The method calculates sum of pixels in square rectangle with
            odd width and height. In the case if it is required to calculate sum of
            3x3 rectangle, then it is required to specify its center and radius equal to 1.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.GetRectangleMean(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate mean value of pixels in the specified rectangle.
            </summary>
            
            <param name="x1">X coordinate of left-top rectangle's corner.</param>
            <param name="y1">Y coordinate of left-top rectangle's corner.</param>
            <param name="x2">X coordinate of right-bottom rectangle's corner.</param>
            <param name="y2">Y coordinate of right-bottom rectangle's corner.</param>
            
            <returns>Returns mean value of pixels in the specified rectangle.</returns>
            
            <remarks>Both specified points are included into the calculation rectangle.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.GetRectangleMeanUnsafe(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate mean value of pixels in the specified rectangle without checking it's coordinates.
            </summary>
            
            <param name="x1">X coordinate of left-top rectangle's corner.</param>
            <param name="y1">Y coordinate of left-top rectangle's corner.</param>
            <param name="x2">X coordinate of right-bottom rectangle's corner.</param>
            <param name="y2">Y coordinate of right-bottom rectangle's corner.</param>
            
            <returns>Returns mean value of pixels in the specified rectangle.</returns>
            
            <remarks>Both specified points are included into the calculation rectangle.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.GetRectangleMean(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate mean value of pixels in the specified rectangle.
            </summary>
            
            <param name="x">X coordinate of central point of the rectangle.</param>
            <param name="y">Y coordinate of central point of the rectangle.</param>
            <param name="radius">Radius of the rectangle.</param>
            
            <returns>Returns mean value of pixels in the specified rectangle.</returns>
            
            <remarks>The method calculates mean value of pixels in square rectangle with
            odd width and height. In the case if it is required to calculate mean value of
            3x3 rectangle, then it is required to specify its center and radius equal to 1.
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.GetRectangleMeanUnsafe(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate mean value of pixels in the specified rectangle without checking it's coordinates.
            </summary>
            
            <param name="x">X coordinate of central point of the rectangle.</param>
            <param name="y">Y coordinate of central point of the rectangle.</param>
            <param name="radius">Radius of the rectangle.</param>
            
            <returns>Returns mean value of pixels in the specified rectangle.</returns>
            
            <remarks>The method calculates mean value of pixels in square rectangle with
            odd width and height. In the case if it is required to calculate mean value of
            3x3 rectangle, then it is required to specify its center and radius equal to 1.
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage.Clone">
             <summary>
               Creates a new object that is a copy of the current instance.
             </summary>
             
             <returns>
               A new object that is a copy of this instance.
             </returns>
            
        </member>
        <member name="T:Accord.Imaging.Interpolation">
            <summary>
            Interpolation routines.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Interpolation.BiCubicKernel(System.Double)">
            <summary>
            Bicubic kernel.
            </summary>
            
            <param name="x">X value.</param>
            
            <returns>Bicubic cooefficient.</returns>
            
            <remarks><para>The function implements bicubic kernel W(x) as described on
            <a href="http://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm">Wikipedia</a>
            (coefficient <b>a</b> is set to <b>-0.5</b>).</para></remarks>
            
        </member>
        <member name="T:Accord.Imaging.ITemplateMatching">
            <summary>
            Template matching algorithm's interface.
            </summary>
            
            <remarks><para>The interface specifies set of methods, which should be implemented by different
            template matching algorithms - algorithms, which search for the given template in specified
            image.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.ITemplateMatching.ProcessImage(System.Drawing.Bitmap,System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="image">Source image to process.</param>
            <param name="template">Template image to search for.</param>
            <param name="searchZone">Rectangle in source image to search template for.</param>
            
            <returns>Returns array of found matchings.</returns>
            
        </member>
        <member name="M:Accord.Imaging.ITemplateMatching.ProcessImage(System.Drawing.Imaging.BitmapData,System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="imageData">Source image data to process.</param>
            <param name="templateData">Template image to search for.</param>
            <param name="searchZone">Rectangle in source image to search template for.</param>
            
            <returns>Returns array of found matchings.</returns>
            
        </member>
        <member name="M:Accord.Imaging.ITemplateMatching.ProcessImage(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
            Process image looking for matchings with specified template.
            </summary>
            
            <param name="image">Unmanaged source image to process.</param>
            <param name="template">Unmanaged template image to search for.</param>
            <param name="searchZone">Rectangle in source image to search template for.</param>
            
            <returns>Returns array of found matchings.</returns>
            
        </member>
        <member name="T:Accord.Imaging.MemoryManager">
            <summary>
            Internal memory manager used by image processing routines.
            </summary>
            
            <remarks><para>The memory manager supports memory allocation/deallocation
            caching. Caching means that memory blocks may be not freed on request, but
            kept for later reuse.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.MemoryManager.MaximumCacheSize">
            <summary>
            Maximum amount of memory blocks to keep in cache.
            </summary>
            
            <remarks><para>The value specifies the amount of memory blocks, which could be
            cached by the memory manager.</para>
            
            <para>Default value is set to 3. Maximum value is 10.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.MemoryManager.CurrentCacheSize">
            <summary>
            Current amount of memory blocks in cache.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.MemoryManager.BusyMemoryBlocks">
            <summary>
            Amount of busy memory blocks in cache (which were not freed yet by user).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.MemoryManager.FreeMemoryBlocks">
            <summary>
            Amount of free memory blocks in cache (which are not busy by users).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.MemoryManager.CachedMemory">
            <summary>
            Amount of cached memory in bytes.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.MemoryManager.MaxSizeToCache">
            <summary>
            Maximum memory block's size in bytes, which could be cached.
            </summary>
            
            <remarks>Memory blocks, which size is greater than this value, are not cached.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.MemoryManager.MinSizeToCache">
            <summary>
            Minimum memory block's size in bytes, which could be cached.
            </summary>
            
            <remarks>Memory blocks, which size is less than this value, are not cached.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.MemoryManager.Alloc(System.Int32)">
            <summary>
            Allocate unmanaged memory.
            </summary>
            
            <param name="size">Memory size to allocate.</param>
            
            <returns>Return's pointer to the allocated memory buffer.</returns>
            
            <remarks>The method allocates requested amount of memory and returns pointer to it. It may avoid allocation
            in the case some caching scheme is uses and there is already enough allocated memory available.</remarks>
            
            <exception cref="T:System.OutOfMemoryException">There is insufficient memory to satisfy the request.</exception>
            
        </member>
        <member name="M:Accord.Imaging.MemoryManager.Free(System.IntPtr)">
            <summary>
            Free unmanaged memory.
            </summary>
            
            <param name="pointer">Pointer to memory buffer to free.</param>
            
            <remarks>This method may skip actual deallocation of memory and keep it for future <see cref="M:Accord.Imaging.MemoryManager.Alloc(System.Int32)"/> requests,
            if some caching scheme is used.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.MemoryManager.FreeUnusedMemory">
            <summary>
            Force freeing unused memory.
            </summary>
            
            <remarks>Frees and removes from cache memory blocks, which are not used by users.</remarks>
            
            <returns>Returns number of freed memory blocks.</returns>
            
        </member>
        <member name="T:Accord.Imaging.MoravecCornersDetector">
            <summary>
            Moravec corners detector.
            </summary>
            
            <remarks><para>The class implements Moravec corners detector. For information about algorithm's
            details its <a href="http://www.cim.mcgill.ca/~dparks/CornerDetector/mainMoravec.htm">description</a>
            should be studied.</para>
            
            <para><note>Due to limitations of Moravec corners detector (anisotropic response, etc.) its usage is limited
            to certain cases only.</note></para>
            
            <para>The class processes only grayscale 8 bpp and color 24/32 bpp images.</para>
            
            <para>Sample usage:</para>
            <code>
            // create corner detector's instance
            MoravecCornersDetector mcd = new MoravecCornersDetector( );
            // process image searching for corners
            List&lt;IntPoint&gt; corners = scd.ProcessImage( image );
            // process points
            foreach ( IntPoint corner in corners )
            {
                // ... 
            }
            </code>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.SusanCornersDetector"/>
            
        </member>
        <member name="P:Accord.Imaging.MoravecCornersDetector.WindowSize">
            <summary>
            Window size used to determine if point is interesting, [3, 15].
            </summary>
            
            <remarks><para>The value specifies window size, which is used for initial searching of
            corners candidates and then for searching local maximums.</para>
            
            <para>Default value is set to <b>3</b>.</para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">Setting value is not odd.</exception>
            
        </member>
        <member name="P:Accord.Imaging.MoravecCornersDetector.Threshold">
            <summary>
            Threshold value, which is used to filter out uninteresting points.
            </summary>
            
            <remarks><para>The value is used to filter uninteresting points - points which have value below
            specified threshold value are treated as not corners candidates. Increasing this value decreases
            the amount of detected point.</para>
            
            <para>Default value is set to <b>500</b>.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.MoravecCornersDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.MoravecCornersDetector"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MoravecCornersDetector.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.MoravecCornersDetector"/> class.
            </summary>
            
            <param name="threshold">Threshold value, which is used to filter out uninteresting points.</param>
            
        </member>
        <member name="M:Accord.Imaging.MoravecCornersDetector.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.MoravecCornersDetector"/> class.
            </summary>
            
            <param name="threshold">Threshold value, which is used to filter out uninteresting points.</param>
            <param name="windowSize">Window size used to determine if point is interesting.</param>
            
        </member>
        <member name="M:Accord.Imaging.MoravecCornersDetector.InnerProcess(Accord.Imaging.UnmanagedImage)">
            <summary>
            This method should be implemented by inheriting classes to implement the
            actual corners detection, transforming the input image into a list of points.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MoravecCornersDetector.Clone(Accord.Compat.ISet{System.Drawing.Imaging.PixelFormat})">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.QuadrilateralFinder">
             <summary>
             Searching of quadrilateral/triangle corners.
             </summary>
            
             <remarks><para>The class searches for quadrilateral's/triangle's corners on the specified image.
             It first collects edge points of the object and then uses
             <see cref="M:Accord.Math.Geometry.PointsCloud.FindQuadrilateralCorners(System.Collections.Generic.IEnumerable{Accord.IntPoint})"/> to find corners
             the quadrilateral/triangle.</para>
             
             <para><note>The class treats all black pixels as background (none-object) and
             all none-black pixels as object.</note></para>
             
             <para>The class processes grayscale 8 bpp and color 24/32 bpp images.</para>
             
             <para>Sample usage:</para>
             <code>
             // get corners of the quadrilateral
             QuadrilateralFinder qf = new QuadrilateralFinder( );
             List&lt;IntPoint&gt; corners = qf.ProcessImage( image );
             
             // lock image to draw on it with AForge.NET's methods
             // (or draw directly on image without locking if it is unmanaged image)
             BitmapData data = image.LockBits( new Rectangle( 0, 0, image.Width, image.Height ),
                 ImageLockMode.ReadWrite, image.PixelFormat );
             
             Drawing.Polygon( data, corners, Color.Red );
             for ( int i = 0; i &lt; corners.Count; i++ )
             {
                 Drawing.FillRectangle( data,
                     new Rectangle( corners[i].X - 2, corners[i].Y - 2, 5, 5 ),
                     Color.FromArgb( i * 32 + 127 + 32, i * 64, i * 64 ) );
             }
             
             image.UnlockBits( data );
             </code>
             
             <para><b>Source image:</b></para>
             <img src="..\images\imaging\sample17.png" width="320" height="240" />
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\quadrilateral_finder.png" width="320" height="240" />
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.QuadrilateralFinder.ProcessImage(System.Drawing.Bitmap)">
             <summary>
             Find corners of quadrilateral/triangular area in the specified image.
             </summary>
             
             <param name="image">Source image to search quadrilateral for.</param>
             
             <returns>Returns a list of points, which are corners of the quadrilateral/triangular area found
             in the specified image. The first point in the list is the point with lowest
             X coordinate (and with lowest Y if there are several points with the same X value).
             Points are in clockwise order (screen coordinates system).</returns>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:Accord.Imaging.QuadrilateralFinder.ProcessImage(System.Drawing.Imaging.BitmapData)">
             <summary>
             Find corners of quadrilateral/triangular area in the specified image.
             </summary>
             
             <param name="imageData">Source image data to search quadrilateral for.</param>
             
             <returns>Returns a list of points, which are corners of the quadrilateral/triangular area found
             in the specified image. The first point in the list is the point with lowest
             X coordinate (and with lowest Y if there are several points with the same X value).
             Points are in clockwise order (screen coordinates system).</returns>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:Accord.Imaging.QuadrilateralFinder.ProcessImage(Accord.Imaging.UnmanagedImage)">
             <summary>
             Find corners of quadrilateral/triangular area in the specified image.
             </summary>
             
             <param name="image">Source image to search quadrilateral for.</param>
             
             <returns>Returns a list of points, which are corners of the quadrilateral/triangular area found
             in the specified image. The first point in the list is the point with lowest
             X coordinate (and with lowest Y if there are several points with the same X value).
             Points are in clockwise order (screen coordinates system).</returns>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="T:Accord.Imaging.RecursiveBlobCounter">
            <summary>
            Blob counter based on recursion.
            </summary>
            
            <remarks><para>The class counts and extracts stand alone objects in
            images using recursive version of connected components labeling
            algorithm.</para>
            
            <para><note>The algorithm treats all pixels with values less or equal to <see cref="P:Accord.Imaging.RecursiveBlobCounter.BackgroundThreshold"/>
            as background, but pixels with higher values are treated as objects' pixels.</note></para>
            
            <para><note>Since this algorithm is based on recursion, it is
            required to be careful with its application to big images with big blobs,
            because in this case recursion will require big stack size and may lead
            to stack overflow. The recursive version may be applied (and may be even
            faster than <see cref="T:Accord.Imaging.BlobCounter"/>) to an image with small blobs -
            "star sky" image (or small cells, for example, etc).</note></para>
            
            <para>For blobs' searching the class supports 8 bpp indexed grayscale images and
            24/32 bpp color images. 
            See documentation about <see cref="T:Accord.Imaging.BlobCounterBase"/> for information about which
            pixel formats are supported for extraction of blobs.</para>
            
            <para>Sample usage:</para>
            <code>
            // create an instance of blob counter algorithm
            var bc = new RecursiveBlobCounter();
            
            // process binary image
            bc.ProcessImage(image);
            
            // process blobs
            foreach (Rectangle rect in bc.GetObjectsRectangles())
            {
                // ...
            }
            </code>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.RecursiveBlobCounter.BackgroundThreshold">
             <summary>
             Background threshold's value.
             </summary>
             
             <remarks><para>The property sets threshold value for distinguishing between background
             pixel and objects' pixels. All pixel with values less or equal to this property are
             treated as background, but pixels with higher values are treated as objects' pixels.</para>
             
             <para><note>In the case of colour images a pixel is treated as objects' pixel if <b>any</b> of its
             RGB values are higher than corresponding values of this threshold.</note></para>
             
             <para><note>For processing grayscale image, set the property with all RGB components eqaul.</note></para>
            
             <para>Default value is set to <b>(0, 0, 0)</b> - black colour.</para></remarks>
             
        </member>
        <member name="M:Accord.Imaging.RecursiveBlobCounter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RecursiveBlobCounter"/> class.
            </summary>
            
            <remarks>Creates new instance of the <see cref="T:Accord.Imaging.RecursiveBlobCounter"/> class with
            an empty objects map. Before using methods, which provide information about blobs
            or extract them, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>,
            <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/> or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/>
            method should be called to collect objects map.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.RecursiveBlobCounter.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RecursiveBlobCounter"/> class.
            </summary>
            
            <param name="image">Image to look for objects in.</param>
            
        </member>
        <member name="M:Accord.Imaging.RecursiveBlobCounter.#ctor(System.Drawing.Imaging.BitmapData)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RecursiveBlobCounter"/> class.
            </summary>
            
            <param name="imageData">Image data to look for objects in.</param>
            
        </member>
        <member name="M:Accord.Imaging.RecursiveBlobCounter.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RecursiveBlobCounter"/> class.
            </summary>
            
            <param name="image">Unmanaged image to look for objects in.</param>
            
        </member>
        <member name="M:Accord.Imaging.RecursiveBlobCounter.BuildObjectsMap(Accord.Imaging.UnmanagedImage)">
            <summary>
            Actual objects map building.
            </summary>
            
            <param name="image">Unmanaged image to process.</param>
            
            <remarks>The method supports 8 bpp indexed grayscale images and 24/32 bpp color images.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="T:Accord.Imaging.SusanCornersDetector">
            <summary>
            Susan corners detector.
            </summary>
            
            <remarks><para>The class implements Susan corners detector, which is described by
            S.M. Smith in: <b>S.M. Smith, "SUSAN - a new approach to low level image processing",
            Internal Technical Report TR95SMS1, Defense Research Agency, Chobham Lane, Chertsey,
            Surrey, UK, 1995</b>.</para>
            
            <para><note>Some implementation notes:
            <list type="bullet">
            <item>Analyzing each pixel and searching for its USAN area, the 7x7 mask is used,
            which is comprised of 37 pixels. The mask has circle shape:
            <code lang="none">
              xxx
             xxxxx
            xxxxxxx
            xxxxxxx
            xxxxxxx
             xxxxx
              xxx
            </code>
            </item>
            <item>In the case if USAN's center of mass has the same coordinates as nucleus
            (central point), the pixel is not a corner.</item>
            <item>For noise suppression the 5x5 square window is used.</item></list></note></para>
            
            <para>The class processes only grayscale 8 bpp and color 24/32 bpp images.
            In the case of color image, it is converted to grayscale internally using
            <see cref="T:Accord.Imaging.Filters.GrayscaleBT709"/> filter.</para>
            
            <para>Sample usage:</para>
            <code>
            // create corners detector's instance
            SusanCornersDetector scd = new SusanCornersDetector( );
            // process image searching for corners
            List&lt;IntPoint&gt; corners = scd.ProcessImage( image );
            // process points
            foreach ( IntPoint corner in corners )
            {
                // ... 
            }
            </code>
            </remarks>
            
            <seealso cref="T:Accord.Imaging.MoravecCornersDetector"/>
            
        </member>
        <member name="P:Accord.Imaging.SusanCornersDetector.DifferenceThreshold">
            <summary>
            Brightness difference threshold.
            </summary>
            
            <remarks><para>The brightness difference threshold controls the amount
            of pixels, which become part of USAN area. If difference between central
            pixel (nucleus) and surrounding pixel is not higher than difference threshold,
            then that pixel becomes part of USAN.</para>
            
            <para>Increasing this value decreases the amount of detected corners.</para>
            
            <para>Default value is set to <b>25</b>.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.SusanCornersDetector.GeometricalThreshold">
            <summary>
            Geometrical threshold.
            </summary>
            
            <remarks><para>The geometrical threshold sets the maximum number of pixels
            in USAN area around corner. If potential corner has USAN with more pixels, than
            it is not a corner.</para>
            
            <para> Decreasing this value decreases the amount of detected corners - only sharp corners
            are detected. Increasing this value increases the amount of detected corners, but
            also increases amount of flat corners, which may be not corners at all.</para>
            
            <para>Default value is set to <b>18</b>, which is half of maximum amount of pixels in USAN.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.SusanCornersDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.SusanCornersDetector"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.SusanCornersDetector.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.SusanCornersDetector"/> class.
            </summary>
            
            <param name="differenceThreshold">Brightness difference threshold.</param>
            <param name="geometricalThreshold">Geometrical threshold.</param>
            
        </member>
        <member name="M:Accord.Imaging.SusanCornersDetector.InnerProcess(Accord.Imaging.UnmanagedImage)">
            <summary>
            This method should be implemented by inheriting classes to implement the
            actual corners detection, transforming the input image into a list of points.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.SusanCornersDetector.Clone(Accord.Compat.ISet{System.Drawing.Imaging.PixelFormat})">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.TemplateMatch">
            <summary>
            Template match class keeps information about found template match. The class is
            used with template matching algorithms implementing <see cref="T:Accord.Imaging.ITemplateMatching"/>
            interface.
            </summary>
        </member>
        <member name="P:Accord.Imaging.TemplateMatch.Rectangle">
            <summary>
            Rectangle of the matching area.
            </summary>
        </member>
        <member name="P:Accord.Imaging.TemplateMatch.Similarity">
            <summary>
            Similarity between template and found matching, [0..1].
            </summary>
        </member>
        <member name="M:Accord.Imaging.TemplateMatch.#ctor(System.Drawing.Rectangle,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.TemplateMatch"/> class.
            </summary>
            
            <param name="rect">Rectangle of the matching area.</param>
            <param name="similarity">Similarity between template and found matching, [0..1].</param>
            
        </member>
        <member name="T:Accord.Imaging.BaseSparseFeatureExtractor`1">
            <summary>
              Base class for image feature extractors that implement the <see cref="T:Accord.Imaging.IImageFeatureExtractor`1"/> interface.
            </summary>
            
            <typeparam name="TPoint">The type of the descriptor vector for the feature (e.g. double[]).</typeparam>
            
            <seealso cref="T:Accord.Imaging.IImageFeatureExtractor`1" />
            <seealso cref="T:Accord.Imaging.BaseSparseFeatureExtractor`1"/>
            
        </member>
        <member name="M:Accord.Imaging.BaseSparseFeatureExtractor`1.ProcessImage(System.Drawing.Bitmap)">
            <summary>
              Obsolete. Please use the <see cref="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(System.Drawing.Bitmap)"/> method instead.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.BaseSparseFeatureExtractor`1.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
              Obsolete. Please use the <see cref="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(System.Drawing.Bitmap)"/> method instead.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.BaseSparseFeatureExtractor`1.ProcessImage(Accord.Imaging.UnmanagedImage)">
            <summary>
              Obsolete. Please use the <see cref="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(System.Drawing.Bitmap)"/> method instead.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.BaseFeatureExtractor`1">
            <summary>
              Base class for image feature extractors that implement the <see cref="T:Accord.Imaging.IImageFeatureExtractor`1"/> interface.
            </summary>
            
            <typeparam name="TFeature">The type of the extracted features (e.g. <see cref="T:Accord.Imaging.SpeededUpRobustFeaturePoint"/>, <see cref="T:Accord.Imaging.FastRetinaKeypoint"/>]).</typeparam>
            
            <seealso cref="T:Accord.Imaging.IImageFeatureExtractor`1" />
            <seealso cref="T:Accord.Imaging.BaseSparseFeatureExtractor`1"/>
            
        </member>
        <member name="P:Accord.Imaging.BaseFeatureExtractor`1.SupportedFormats">
            <summary>
              Gets the list of image pixel formats that are supported by 
              this extractor. The extractor will check whether the pixel
              format of any provided images are in this list to determine
              whether the image can be processed or not.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.BaseFeatureExtractor`1.NumberOfInputs">
            <summary>
              Returns -1.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.BaseFeatureExtractor`1.NumberOfOutputs">
            <summary>
              Gets the dimensionality of the features generated by this extractor.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BaseFeatureExtractor`1"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.ProcessImage(System.Drawing.Bitmap)">
            <summary>
              Obsolete. Please use the <see cref="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(System.Drawing.Bitmap)"/> method instead.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
              Obsolete. Please use the <see cref="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(System.Drawing.Bitmap)"/> method instead.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.ProcessImage(Accord.Imaging.UnmanagedImage)">
            <summary>
              Obsolete. Please use the <see cref="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(System.Drawing.Bitmap)"/> method instead.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(System.Drawing.Bitmap)">
            <summary>
              Applies the transformation to an input, producing an associated output.
            </summary>
            
            <param name="input">The input data to which the transformation should be applied.</param>
            
            <returns>The output generated by applying this transformation to the given input.</returns>
            
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(System.Drawing.Bitmap[])">
            <summary>
              Applies the transformation to an input, producing an associated output.
            </summary>
            
            <param name="input">The input data to which the transformation should be applied.</param>
            
            <returns>The output generated by applying this transformation to the given input.</returns>
            
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(System.Drawing.Bitmap[],System.Collections.Generic.IEnumerable{`0}[])">
            <summary>
              Applies the transformation to a set of input vectors,
              producing an associated set of output vectors.
            </summary>
            
            <param name="input">The input data to which
              the transformation should be applied.</param>
            <param name="result">The location to where to store the
              result of this transformation.</param>
            
            <returns>The output generated by applying this
              transformation to the given input.</returns>
            
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(Accord.Imaging.UnmanagedImage)">
            <summary>
              Applies the transformation to an input, producing an associated output.
            </summary>
            
            <param name="input">The input data to which the transformation should be applied.</param>
            
            <returns>The output generated by applying this transformation to the given input.</returns>
            
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(Accord.Imaging.UnmanagedImage[])">
            <summary>
              Applies the transformation to an input, producing an associated output.
            </summary>
            
            <param name="input">The input data to which the transformation should be applied.</param>
            
            <returns>The output generated by applying this transformation to the given input.</returns>
            
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(Accord.Imaging.UnmanagedImage[],System.Collections.Generic.IEnumerable{`0}[])">
            <summary>
              Applies the transformation to a set of input vectors,
              producing an associated set of output vectors.
            </summary>
            
            <param name="input">The input data to which
              the transformation should be applied.</param>
            <param name="result">The location to where to store the
              result of this transformation.</param>
            
            <returns>The output generated by applying this
              transformation to the given input.</returns>
            
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.InnerTransform(Accord.Imaging.UnmanagedImage)">
            <summary>
              This method should be implemented by inheriting classes to implement the 
              actual feature extraction, transforming the input image into a list of features.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.Clone(Accord.Compat.ISet{System.Drawing.Imaging.PixelFormat})">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:Accord.Imaging.BaseFeatureExtractor`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Accord.Imaging.HaralickDescriptorDictionary">
            <summary>
              Feature dictionary. Associates a set of Haralick features to a given degree
              used to compute the originating <see cref="T:Accord.Imaging.GrayLevelCooccurrenceMatrix">GLCM</see>.
            </summary>
            
            <seealso cref="T:Accord.Imaging.Haralick"/>
            <seealso cref="T:Accord.Imaging.HaralickDescriptor"/>
            
        </member>
        <member name="M:Accord.Imaging.HaralickDescriptorDictionary.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.HaralickDescriptorDictionary"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.HaralickDescriptorDictionary.Combine(System.Int32)">
            <summary>
              Combines features generated from different <see cref="T:Accord.Imaging.GrayLevelCooccurrenceMatrix">
              GLCMs</see> computed using different <see cref="T:Accord.Imaging.CooccurrenceDegree">angulations</see>
              by concatenating them into a single vector.
            </summary>
            
            <param name="features">The number of Haralick's original features to compute.</param>
            
            <returns>A single vector containing all values computed from
            the different <see cref="T:Accord.Imaging.HaralickDescriptor"/>s.</returns>
            
            <remarks>
              If there are <c>d</c> <see cref="T:Accord.Imaging.CooccurrenceDegree">degrees</see> in this
              collection, and <c>n</c> <paramref name="features"/> given to compute, the
              generated vector will have size <c>d * n</c>. All features from different
              degrees will be concatenated into this single result vector.
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.HaralickDescriptorDictionary.Average(System.Int32)">
            <summary>
              Combines features generated from different <see cref="T:Accord.Imaging.GrayLevelCooccurrenceMatrix">
              GLCMs</see> computed using different <see cref="T:Accord.Imaging.CooccurrenceDegree">angulations</see>
              by averaging them into a single vector.
            </summary>
            
            <param name="features">The number of Haralick's original features to compute.</param>
            
            <returns>A single vector containing the average of the values
              computed from the different <see cref="T:Accord.Imaging.HaralickDescriptor"/>s.</returns>
              
            <remarks>
              If there are <c>d</c> <see cref="T:Accord.Imaging.CooccurrenceDegree">degrees</see> in this
              collection, and <c>n</c> <paramref name="features"/> given to compute, the
              generated vector will have size <c>n</c>. All features from different
              degrees will be averaged into this single result vector.
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.HaralickDescriptorDictionary.AverageWithRange(System.Int32)">
            <summary>
              Combines features generated from different <see cref="T:Accord.Imaging.GrayLevelCooccurrenceMatrix">
              GLCMs</see> computed using different <see cref="T:Accord.Imaging.CooccurrenceDegree">angulations</see>
              by averaging them into a single vector.
            </summary>
            
            <param name="features">The number of Haralick's original features to compute.</param>
            
            <returns>A single vector containing the average of the values
              computed from the different <see cref="T:Accord.Imaging.HaralickDescriptor"/>s.</returns>
            
            <remarks>
              If there are <c>d</c> <see cref="T:Accord.Imaging.CooccurrenceDegree">degrees</see> in this
              collection, and <c>n</c> <paramref name="features"/> given to compute, the
              generated vector will have size <c>2*n*d</c>. Each even index will have
              the average of a given feature, and the subsequent odd index will contain
              the range of this feature.
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.HaralickDescriptorDictionary.Normalize(System.Int32)">
            <summary>
              Combines features generated from different <see cref="T:Accord.Imaging.GrayLevelCooccurrenceMatrix">
              GLCMs</see> computed using different <see cref="T:Accord.Imaging.CooccurrenceDegree">angulations</see>
              by averaging them into a single vector, normalizing them to be between -1 and 1.
            </summary>
            
            <param name="features">The number of Haralick's original features to compute.</param>
            
            <returns>A single vector containing the averaged and normalized values
              computed from the different <see cref="T:Accord.Imaging.HaralickDescriptor"/>s.</returns>
            
            <remarks>
              If there are <c>d</c> <see cref="T:Accord.Imaging.CooccurrenceDegree">degrees</see> in this
              collection, and <c>n</c> <paramref name="features"/> given to compute, the
              generated vector will have size <c>n</c>. All features will be averaged, and
              the mean will be scaled to be in a [-1,1] interval.
            </remarks>
            
        </member>
        <member name="T:Accord.Imaging.Textures.BaseTextureGenerator">
            <summary>
              Base class for texture generators.
            </summary>
            
            <remarks><para>Each texture generator generates a 2-D texture of the specified size and returns
            it as two dimensional array of intensities in the range of [0, 1] - texture's values.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Textures.BaseTextureGenerator.Generate(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            <returns>Two dimensional array of texture's intensities.</returns>
            <remarks>Generates new texture of the specified size.</remarks>
        </member>
        <member name="M:Accord.Imaging.Textures.BaseTextureGenerator.Reset">
            <summary>
            Reset generator.
            </summary>
            <remarks>Resets the generator - resets all internal variables, regenerates
            internal random numbers, etc.</remarks>
        </member>
        <member name="M:Accord.Imaging.Textures.BaseTextureGenerator.GenerateBitmap(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            
            <returns>Two dimensional array of texture's intensities.</returns>
            
            <remarks>Generates new texture of the specified size.</remarks>
            
        </member>
        <member name="T:Accord.Imaging.Textures.CloudsTexture">
             <summary>
             Clouds texture.
             </summary>
             
             <remarks><para>The texture generator creates textures with effect of clouds.</para>
             
             <para>The generator is based on the <see cref="T:Accord.Math.PerlinNoise">Perlin noise function</see>.</para>
             
             <para>Sample usage:</para>
             <code>
             // create texture generator
             CloudsTexture textureGenerator = new CloudsTexture();
             
             // generate new texture
             float[,] texture = textureGenerator.Generate(320, 240);
             
             // convert it to image to visualize
             Bitmap textureImage = texture.ToBitmap();
             </code>
            
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\clouds_texture.jpg" width="320" height="240" />
             </remarks>
             
        </member>
        <member name="M:Accord.Imaging.Textures.CloudsTexture.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Textures.CloudsTexture"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Textures.CloudsTexture.Generate(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            
            <returns>Two dimensional array of intensities.</returns>
            
            <remarks>Generates new texture of the specified size.</remarks>
             
        </member>
        <member name="T:Accord.Imaging.Textures.ITextureGenerator">
            <summary>
            Texture generator interface.
            </summary>
            
            <remarks><para>Each texture generator generates a 2-D texture of the specified size and returns
            it as two dimensional array of intensities in the range of [0, 1] - texture's values.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Textures.ITextureGenerator.Generate(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            
            <returns>Two dimensional array of texture's intensities.</returns>
            
            <remarks>Generates new texture of the specified size.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Textures.ITextureGenerator.Reset">
            <summary>
            Reset generator.
            </summary>
            
            <remarks>Resets the generator - resets all internal variables, regenerates
            internal random numbers, etc.</remarks>
            
        </member>
        <member name="T:Accord.Imaging.Textures.LabyrinthTexture">
             <summary>
             Labirinth texture.
             </summary>
             
             <remarks><para>The texture generator creates textures with effect of labyrinth.</para>
             
             <para>The generator is based on the <see cref="T:Accord.Math.PerlinNoise">Perlin noise function</see>.</para>
             
             <para>Sample usage:</para>
             <code>
             // create texture generator
             LabyrinthTexture textureGenerator = new LabyrinthTexture( );
             // generate new texture
             float[,] texture = textureGenerator.Generate( 320, 240 );
             // convert it to image to visualize
             Bitmap textureImage = TextureTools.ToBitmap( texture );
             </code>
            
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\labyrinth_texture.jpg" width="320" height="240" />
             </remarks>
             
        </member>
        <member name="M:Accord.Imaging.Textures.LabyrinthTexture.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Textures.LabyrinthTexture"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Textures.LabyrinthTexture.Generate(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            
            <returns>Two dimensional array of intensities.</returns>
            
            <remarks>Generates new texture of the specified size.</remarks>
             
        </member>
        <member name="T:Accord.Imaging.Textures.MarbleTexture">
             <summary>
             Marble texture.
             </summary>
             
             <remarks><para>The texture generator creates textures with effect of marble.
             The <see cref="P:Accord.Imaging.Textures.MarbleTexture.XPeriod"/> and <see cref="P:Accord.Imaging.Textures.MarbleTexture.YPeriod"/> properties allow to control the look
             of marble texture in X/Y directions.</para>
             
             <para>The generator is based on the <see cref="T:Accord.Math.PerlinNoise">Perlin noise function</see>.</para>
             
             <para>Sample usage:</para>
             <code>
             // create texture generator
             MarbleTexture textureGenerator = new MarbleTexture( );
             // generate new texture
             float[,] texture = textureGenerator.Generate( 320, 240 );
             // convert it to image to visualize
             Bitmap textureImage = TextureTools.ToBitmap( texture );
             </code>
            
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\marble_texture.jpg" width="320" height="240" />
             </remarks>
             
        </member>
        <member name="P:Accord.Imaging.Textures.MarbleTexture.XPeriod">
            <summary>
            X period value, â¥ 2. Default is 5.
            </summary>
            
            <remarks>Default value is set to <b>5</b>.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.Textures.MarbleTexture.YPeriod">
            <summary>
            Y period value, â¥ 2. Default is 10.
            </summary>
            
            <remarks>Default value is set to <b>10</b>.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Textures.MarbleTexture.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Textures.MarbleTexture"/> class.
            </summary>
            
            <param name="xPeriod">X period value.</param>
            <param name="yPeriod">Y period value.</param>
            
        </member>
        <member name="M:Accord.Imaging.Textures.MarbleTexture.Generate(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            
            <returns>Two dimensional array of intensities.</returns>
            
            <remarks>Generates new texture of the specified size.</remarks>
            
        </member>
        <member name="T:Accord.Imaging.Textures.TextileTexture">
             <summary>
             Textile texture.
             </summary>
             
             <remarks><para>The texture generator creates textures with effect of textile.</para>
             
             <para>The generator is based on the <see cref="T:Accord.Math.PerlinNoise">Perlin noise function</see>.</para>
             
             <para>Sample usage:</para>
             <code>
             // create texture generator
             TextileTexture textureGenerator = new TextileTexture( );
             // generate new texture
             float[,] texture = textureGenerator.Generate( 320, 240 );
             // convert it to image to visualize
             Bitmap textureImage = TextureTools.ToBitmap( texture );
             </code>
            
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\textile_texture.jpg" width="320" height="240" />
             </remarks>
             
        </member>
        <member name="M:Accord.Imaging.Textures.TextileTexture.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Textures.TextileTexture"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Textures.TextileTexture.Generate(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            
            <returns>Two dimensional array of intensities.</returns>
            
            <remarks>Generates new texture of the specified size.</remarks>
            
        </member>
        <member name="T:Accord.Imaging.Textures.TextureTools">
            <summary>
              Obsolete. Please use classes from the Accord.Imaging.Converters namespace instead.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Textures.TextureTools.ToBitmap(System.Single[0:,0:])">
            <summary>
              Obsolete. Please use the <see cref="T:Accord.Imaging.Converters.ImageToMatrix"/> class instead. See remarks for an example.
            </summary>
            
            <example>
            <code>
              MatrixToImage i2m = new MatrixToImage();
              Bitmap image;
              i2m.Convert(texture, out image);
              return image;
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Imaging.Textures.TextureTools.FromBitmap(System.Drawing.Bitmap)">
            <summary>
              Obsolete. Please use the <see cref="T:Accord.Imaging.Converters.ImageToMatrix"/> class instead. See remarks for an example.
            </summary>
            
            <example>
            <code>
              ImageToMatrix i2m = new ImageToMatrix();
              float[,] texture;
              i2m.Convert(image, out texture);
              return texture;
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Imaging.Textures.TextureTools.FromBitmap(System.Drawing.Imaging.BitmapData)">
            <summary>
              Obsolete. Please use the <see cref="T:Accord.Imaging.Converters.ImageToMatrix"/> class instead. See remarks for an example.
            </summary>
            
            <example>
            <code>
              ImageToMatrix i2m = new ImageToMatrix();
              float[,] texture;
              i2m.Convert(image, out texture);
              return texture;
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Imaging.Textures.TextureTools.FromBitmap(Accord.Imaging.UnmanagedImage)">
            <summary>
              Obsolete. Please use the <see cref="T:Accord.Imaging.Converters.ImageToMatrix"/> class instead. See remarks for an example.
            </summary>
            
            <example>
            <code>
              ImageToMatrix i2m = new ImageToMatrix();
              float[,] texture;
              i2m.Convert(image, out texture);
              return texture;
            </code>
            </example>
            
        </member>
        <member name="T:Accord.Imaging.Textures.WoodTexture">
             <summary>
             Wood texture.
             </summary>
             
             <remarks><para>The texture generator creates textures with effect of
             rings on trunk's shear. The <see cref="P:Accord.Imaging.Textures.WoodTexture.Rings"/> property allows to specify the
             desired amount of wood rings.</para>
             
             <para>The generator is based on the <see cref="T:Accord.Math.PerlinNoise">Perlin noise function</see>.</para>
             
             <para>Sample usage:</para>
             <code>
             // create texture generator
             WoodTexture textureGenerator = new WoodTexture();
             
             // generate new texture
             float[,] texture = textureGenerator.Generate(320, 240);
             
             // convert it to image to visualize
             Bitmap textureImage = texture.ToBitmap();
             </code>
            
             <para><b>Result image:</b></para>
             <img src="..\images\imaging\wood_texture.jpg" width="320" height="240" />
             </remarks>
             
        </member>
        <member name="P:Accord.Imaging.Textures.WoodTexture.Rings">
            <summary>
            Wood rings amount, â¥ 3. Default is 12.
            </summary>
            
            <remarks><para>The property sets the amount of wood rings, which make effect of
            rings on trunk's shear.</para>
            
            <para>Default value is set to <b>12</b>.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Textures.WoodTexture.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Textures.WoodTexture"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Textures.WoodTexture.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Textures.WoodTexture"/> class.
            </summary>
            
            <param name="rings">Wood rings amount.</param>
            
        </member>
        <member name="M:Accord.Imaging.Textures.WoodTexture.Generate(System.Int32,System.Int32)">
            <summary>
            Generate texture.
            </summary>
            
            <param name="width">Texture's width.</param>
            <param name="height">Texture's height.</param>
            
            <returns>Two dimensional array of intensities.</returns>
            
            <remarks>Generates new texture of the specified size.</remarks>
            
        </member>
        <member name="T:Accord.Imaging.UnmanagedImage">
            <summary>
            Image in unmanaged memory.
            </summary>
            
            <remarks>
            <para>The class represents wrapper of an image in unmanaged memory. Using this class
            it is possible as to allocate new image in unmanaged memory, as to just wrap provided
            pointer to unmanaged memory, where an image is stored.</para>
            
            <para>Usage of unmanaged images is mostly beneficial when it is required to apply <b>multiple</b>
            image processing routines to a single image. In such scenario usage of .NET managed images 
            usually leads to worse performance, because each routine needs to lock managed image
            before image processing is done and then unlock it after image processing is done. Without
            these lock/unlock there is no way to get direct access to managed image's data, which means
            there is no way to do fast image processing. So, usage of managed images lead to overhead, which
            is caused by locks/unlock. Unmanaged images are represented internally using unmanaged memory
            buffer. This means that it is not required to do any locks/unlocks in order to get access to image
            data (no overhead).</para>
            
            <para>Sample usage:</para>
            <code>
            // sample 1 - wrapping .NET image into unmanaged without
            // making extra copy of image in memory
            BitmapData imageData = image.LockBits(
                new Rectangle( 0, 0, image.Width, image.Height ),
                ImageLockMode.ReadWrite, image.PixelFormat );
            
            try
            {
                UnmanagedImage unmanagedImage = new UnmanagedImage( imageData ) );
                // apply several routines to the unmanaged image
            }
            finally
            {
                image.UnlockBits( imageData );
            }
            
            
            // sample 2 - converting .NET image into unmanaged
            UnmanagedImage unmanagedImage = UnmanagedImage.FromManagedImage( image );
            // apply several routines to the unmanaged image
            ...
            // conver to managed image if it is required to display it at some point of time
            Bitmap managedImage = unmanagedImage.ToManagedImage( );
            </code>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.ImageData">
            <summary>
            Pointer to image data in unmanaged memory.
            </summary>
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.Width">
            <summary>
            Image width in pixels.
            </summary>
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.Height">
            <summary>
            Image height in pixels.
            </summary>
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.Stride">
            <summary>
            Image stride (line size in bytes).
            </summary>
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.PixelFormat">
            <summary>
            Image pixel format.
            </summary>
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.Bytes">
            <summary>
            Gets the image size, in bytes.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.Size">
            <summary>
            Gets the image size, in pixels.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.Offset">
            <summary>
            Gets the number of extra bytes after the image width is over. This can be computed
            as <see cref="P:Accord.Imaging.UnmanagedImage.Stride"/> - <see cref="P:Accord.Imaging.UnmanagedImage.Width"/> * <see cref="P:Accord.Imaging.UnmanagedImage.PixelSize"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.PixelSize">
            <summary>
            Gets the size of the pixels in this image, in bytes. For 
            example, a 8-bpp grayscale image would have pixel size 1.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.#ctor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.UnmanagedImage"/> class.
            </summary>
            
            <param name="imageData">Pointer to image data in unmanaged memory.</param>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="stride">Image stride (line size in bytes).</param>
            <param name="pixelFormat">Image pixel format.</param>
            
            <remarks><para><note>Using this constructor, make sure all specified image attributes are correct
            and correspond to unmanaged memory buffer. If some attributes are specified incorrectly,
            this may lead to exceptions working with the unmanaged memory.</note></para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.#ctor(System.Drawing.Imaging.BitmapData)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.UnmanagedImage"/> class.
            </summary>
            
            <param name="bitmapData">Locked bitmap data.</param>
            
            <remarks><note>Unlike <see cref="M:Accord.Imaging.UnmanagedImage.FromManagedImage(System.Drawing.Imaging.BitmapData)"/> method, this constructor does not make
            copy of managed image. This means that managed image must stay locked for the time of using the instance
            of unamanged image.</note></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Finalize">
            <summary>
            Destroys the instance of the <see cref="T:Accord.Imaging.UnmanagedImage"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Dispose">
            <summary>
            Dispose the object.
            </summary>
            
            <remarks><para>Frees unmanaged resources used by the object. The object becomes unusable
            after that.</para>
            
            <par><note>The method needs to be called only in the case if unmanaged image was allocated
            using <see cref="M:Accord.Imaging.UnmanagedImage.Create(System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)"/> method. In the case if the class instance 
            was created using constructor, this method does not free unmanaged memory.</note></par>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Dispose(System.Boolean)">
            <summary>
            Dispose the object.
            </summary>
            
            <param name="disposing">Indicates if disposing was initiated manually.</param>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Clone">
            <summary>
            Clone the unmanaged images.
            </summary>
            
            <returns>Returns clone of the unmanaged image.</returns>
            
            <remarks><para>The method does complete cloning of the object.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Copy(Accord.Imaging.UnmanagedImage)">
            <summary>
            Copy unmanaged image.
            </summary>
            
            <param name="destImage">Destination image to copy this image to.</param>
            
            <remarks><para>The method copies current unmanaged image to the specified image.
            Size and pixel format of the destination image must be exactly the same.</para></remarks>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Destination image has different size or pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Create(System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)">
            <summary>
            Allocate new image in unmanaged memory.
            </summary>
            
            <param name="width">Image width.</param>
            <param name="height">Image height.</param>
            <param name="pixelFormat">Image pixel format.</param>
            
            <returns>Return image allocated in unmanaged memory.</returns>
            
            <remarks><para>Allocate new image with specified attributes in unmanaged memory.</para>
            
            <para><note>The method supports only
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format16bppGrayScale</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format24bppRgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppRgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppArgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppPArgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format48bppRgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format64bppArgb</see> and
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format64bppPArgb</see> pixel formats.
            In the case if <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>
            format is specified, pallete is not not created for the image (supposed that it is
            8 bpp grayscale image).
            </note></para>
            </remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format was specified.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Invalid image size was specified.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Create(System.Int32,System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)">
            <summary>
            Allocate new image in unmanaged memory.
            </summary>
            
            <param name="width">Image width.</param>
            <param name="height">Image height.</param>
            <param name="stride">Image stride.</param>
            <param name="pixelFormat">Image pixel format.</param>
            
            <returns>Return image allocated in unmanaged memory.</returns>
            
            <remarks><para>Allocate new image with specified attributes in unmanaged memory.</para>
            
            <para><note>The method supports only
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format16bppGrayScale</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format24bppRgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppRgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppArgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppPArgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format48bppRgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format64bppArgb</see> and
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format64bppPArgb</see> pixel formats.
            In the case if <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>
            format is specified, pallete is not not created for the image (supposed that it is
            8 bpp grayscale image).
            </note></para>
            </remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format was specified.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Invalid image size was specified.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.ToManagedImage">
            <summary>
            Create managed image from the unmanaged.
            </summary>
            
            <returns>Returns managed copy of the unmanaged image.</returns>
            
            <remarks><para>The method creates a managed copy of the unmanaged image with the
            same size and pixel format (it calls <see cref="M:Accord.Imaging.UnmanagedImage.ToManagedImage(System.Boolean)"/> specifying
            <see langword="true"/> for the <b>makeCopy</b> parameter).</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.ToManagedImage(System.Boolean)">
            <summary>
            Create managed image from the unmanaged.
            </summary>
            
            <param name="makeCopy">Make a copy of the unmanaged image or not.</param>
            
            <returns>Returns managed copy of the unmanaged image.</returns>
            
            <remarks><para>If the <paramref name="makeCopy"/> is set to <see langword="true"/>, then the method
            creates a managed copy of the unmanaged image, so the managed image stays valid even when the unmanaged
            image gets disposed. However, setting this parameter to <see langword="false"/> creates a managed image which is
            just a wrapper around the unmanaged image. So if unmanaged image is disposed, the
            managed image becomes no longer valid and accessing it will generate an exception.</para></remarks>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">The unmanaged image has some invalid properties, which results
            in failure of converting it to managed image. This may happen if user used the
            <see cref="M:Accord.Imaging.UnmanagedImage.#ctor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)"/> constructor specifying some
            invalid parameters.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.FromByteArray(System.Byte[],System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)">
            <summary>
            Create unmanaged image from the specified byte array.
            </summary>
            
            <param name="bytes">Source byte array containing the image's pixels.</param>
            <param name="height">The height of the image.</param>
            <param name="width">The width of the image.</param>
            <param name="pixelFormat">The <see cref="P:Accord.Imaging.UnmanagedImage.PixelFormat"/> of the pixels.</param>
            
            <returns>Returns new unmanaged image, which is a copy of source managed image.</returns>
            
            <remarks><para>The method creates an exact copy of specified managed image, but allocated
            in unmanaged memory.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.FromManagedImage(System.Drawing.Bitmap)">
            <summary>
            Create unmanaged image from the specified managed image.
            </summary>
            
            <param name="image">Source managed image.</param>
            
            <returns>Returns new unmanaged image, which is a copy of source managed image.</returns>
            
            <remarks><para>The method creates an exact copy of specified managed image, but allocated
            in unmanaged memory.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.FromManagedImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Create unmanaged image from the specified managed image.
            </summary>
            
            <param name="imageData">Source locked image data.</param>
            
            <returns>Returns new unmanaged image, which is a copy of source managed image.</returns>
            
            <remarks><para>The method creates an exact copy of specified managed image, but allocated
            in unmanaged memory. This means that managed image may be unlocked right after call to this
            method.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Collect8bppPixelValues(System.Collections.Generic.List{Accord.IntPoint})">
            <summary>
            Collect pixel values from the specified list of coordinates.
            </summary>
            
            <param name="points">List of coordinates to collect pixels' value from.</param>
            
            <returns>Returns array of pixels' values from the specified coordinates.</returns>
            
            <remarks><para>The method goes through the specified list of points and for each point retrievs
            corresponding pixel's value from the unmanaged image.</para>
            
            <para><note>For grayscale image the output array has the same length as number of points in the
            specified list of points. For color image the output array has triple length, containing pixels'
            values in RGB order.</note></para>
            
            <para><note>The method does not make any checks for valid coordinates and leaves this up to user.
            If specified coordinates are out of image's bounds, the result is not predictable (crash in most cases).
            </note></para>
            
            <para><note>This method is supposed for images with 8 bpp channels only (8 bpp grayscale image and
            24/32 bpp color images).</note></para>
            </remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. Use Collect16bppPixelValues() method for
            images with 16 bpp channels.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.CollectActivePixels">
            <summary>
            Collect coordinates of none black pixels in the image.
            </summary>
            
            <returns>Returns list of points, which have other than black color.</returns>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.CollectActivePixels(System.Drawing.Rectangle)">
             <summary>
             Collect coordinates of none black pixels within specified rectangle of the image.
             </summary>
             
             <param name="rect">Image's rectangle to process.</param>
             
             <returns>Returns list of points, which have other than black color.</returns>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.SetPixels(System.Collections.Generic.List{Accord.IntPoint},System.Drawing.Color)">
             <summary>
             Set pixels with the specified coordinates to the specified color.
             </summary>
             
             <param name="coordinates">List of points to set color for.</param>
             <param name="color">Color to set for the specified points.</param>
             
             <remarks><para><note>For images having 16 bpp per color plane, the method extends the specified color
             value to 16 bit by multiplying it by 256.</note></para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.SetPixel(Accord.IntPoint,System.Drawing.Color)">
             <summary>
             Set pixel with the specified coordinates to the specified color.
             </summary>
             
             <param name="point">Point's coordiates to set color for.</param>
             <param name="color">Color to set for the pixel.</param>
             
             <remarks><para>See <see cref="M:Accord.Imaging.UnmanagedImage.SetPixel(System.Int32,System.Int32,System.Drawing.Color)"/> for more information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.SetPixel(System.Int32,System.Int32,System.Drawing.Color)">
            <summary>
            Set pixel with the specified coordinates to the specified color.
            </summary>
            
            <param name="x">X coordinate of the pixel to set.</param>
            <param name="y">Y coordinate of the pixel to set.</param>
            <param name="color">Color to set for the pixel.</param>
            
            <remarks><para><note>For images having 16 bpp per color plane, the method extends the specified color
            value to 16 bit by multiplying it by 256.</note></para>
            
            <para>For grayscale images this method will calculate intensity value based on the below formula:
            <code lang="none">
            0.2125 * Red + 0.7154 * Green + 0.0721 * Blue
            </code>
            </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.SetPixel(System.Int32,System.Int32,System.Byte)">
             <summary>
             Set pixel with the specified coordinates to the specified value.
             </summary>
            
             <param name="x">X coordinate of the pixel to set.</param>
             <param name="y">Y coordinate of the pixel to set.</param>
             <param name="value">Pixel value to set.</param>
             
             <remarks><para>The method sets all color components of the pixel to the specified value.
             If it is a grayscale image, then pixel's intensity is set to the specified value.
             If it is a color image, then pixel's R/G/B components are set to the same specified value
             (if an image has alpha channel, then it is set to maximum value - 255 or 65535).</para>
             
             <para><note>For images having 16 bpp per color plane, the method extends the specified color
             value to 16 bit by multiplying it by 256.</note></para>
             </remarks>
             
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.GetPixel(Accord.IntPoint)">
             <summary>
             Get color of the pixel with the specified coordinates.
             </summary>
             
             <param name="point">Point's coordiates to get color of.</param>
             
             <returns>Return pixel's color at the specified coordinates.</returns>
             
             <remarks><para>See <see cref="M:Accord.Imaging.UnmanagedImage.GetPixel(System.Int32,System.Int32)"/> for more information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.GetPixel(System.Int32,System.Int32)">
            <summary>
            Get color of the pixel with the specified coordinates.
            </summary>
            
            <param name="x">X coordinate of the pixel to get.</param>
            <param name="y">Y coordinate of the pixel to get.</param>
            
            <returns>Return pixel's color at the specified coordinates.</returns>
            
            <remarks>
            <para><note>In the case if the image has 8 bpp grayscale format, the method will return a color with
            all R/G/B components set to same value, which is grayscale intensity.</note></para>
            
            <para><note>The method supports only 8 bpp grayscale images and 24/32 bpp color images so far.</note></para>
            </remarks>
            
            <exception cref="T:System.ArgumentOutOfRangeException">The specified pixel coordinate is out of image's bounds.</exception>
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Pixel format of this image is not supported by the method.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Collect16bppPixelValues(System.Collections.Generic.List{Accord.IntPoint})">
             <summary>
             Collect pixel values from the specified list of coordinates.
             </summary>
             
             <param name="points">List of coordinates to collect pixels' value from.</param>
             
             <returns>Returns array of pixels' values from the specified coordinates.</returns>
             
             <remarks><para>The method goes through the specified list of points and for each point retrievs
             corresponding pixel's value from the unmanaged image.</para>
             
             <para><note>For grayscale image the output array has the same length as number of points in the
             specified list of points. For color image the output array has triple length, containing pixels'
             values in RGB order.</note></para>
             
             <para><note>The method does not make any checks for valid coordinates and leaves this up to user.
             If specified coordinates are out of image's bounds, the result is not predictable (crash in most cases).
             </note></para>
             
             <para><note>This method is supposed for images with 16 bpp channels only (16 bpp grayscale image and
             48/64 bpp color images).</note></para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. Use Collect8bppPixelValues() method for
             images with 8 bpp channels.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.ToByteArray">
            <summary>
              Converts the image into a sequence of bytes.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.VerticalIntensityStatistics">
             <summary>
             Vertical intensity statistics.
             </summary>
             
             <remarks><para>The class provides information about vertical distribution
             of pixel intensities, which may be used to locate objects, their centers, etc.
             </para>
             
             <para>The class accepts grayscale (8 bpp indexed and 16 bpp) and color (24, 32, 48 and 64 bpp) images.
             In the case of 32 and 64 bpp color images, the alpha channel is not processed - statistics is not
             gathered for this channel.</para>
             
             <para>Sample usage:</para>
             <code>
             // collect statistics
             VerticalIntensityStatistics vis = new VerticalIntensityStatistics( sourceImage );
             // get gray histogram (for grayscale image)
             Histogram histogram = vis.Gray;
             // output some histogram's information
             System.Diagnostics.Debug.WriteLine( "Mean = " + histogram.Mean );
             System.Diagnostics.Debug.WriteLine( "Min = " + histogram.Min );
             System.Diagnostics.Debug.WriteLine( "Max = " + histogram.Max );
             </code>
             
             <para><b>Sample grayscale image with its vertical intensity histogram:</b></para>
             <img src="..\images\imaging\ver_histogram.jpg" width="450" height="240" />
             </remarks>
             
             <seealso cref="T:Accord.Imaging.HorizontalIntensityStatistics"/>
            
        </member>
        <member name="P:Accord.Imaging.VerticalIntensityStatistics.Red">
            <summary>
            Histogram for red channel.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.VerticalIntensityStatistics.Green">
            <summary>
            Histogram for green channel.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.VerticalIntensityStatistics.Blue">
            <summary>
            Histogram for blue channel.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.VerticalIntensityStatistics.Gray">
            <summary>
            Histogram for gray channel (intensities).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.VerticalIntensityStatistics.IsGrayscale">
            <summary>
            Value wich specifies if the processed image was color or grayscale.
            </summary>
            
            <remarks><para>If the property equals to <b>true</b>, then the <see cref="P:Accord.Imaging.VerticalIntensityStatistics.Gray"/>
            property should be used to retrieve histogram for the processed grayscale image.
            Otherwise <see cref="P:Accord.Imaging.VerticalIntensityStatistics.Red"/>, <see cref="P:Accord.Imaging.VerticalIntensityStatistics.Green"/> and <see cref="P:Accord.Imaging.VerticalIntensityStatistics.Blue"/> property
            should be used to retrieve histogram for particular RGB channel of the processed
            color image.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.VerticalIntensityStatistics.#ctor(System.Drawing.Bitmap)">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.VerticalIntensityStatistics"/> class.
             </summary>
             
             <param name="image">Source image.</param>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:Accord.Imaging.VerticalIntensityStatistics.#ctor(System.Drawing.Imaging.BitmapData)">
             <summary>
             Initializes a new instance of the <see cref="T:Accord.Imaging.VerticalIntensityStatistics"/> class.
             </summary>
             
             <param name="imageData">Source image data.</param>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
             
        </member>
        <member name="M:Accord.Imaging.VerticalIntensityStatistics.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.HorizontalIntensityStatistics"/> class.
            </summary>
            
            <param name="image">Source unmanaged image.</param>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.VerticalIntensityStatistics.ProcessImage(Accord.Imaging.UnmanagedImage)">
            <summary>
            Gather vertical intensity statistics for specified image.
            </summary>
            
            <param name="image">Source image.</param>
            
        </member>
        <member name="T:Accord.Imaging.BorderFollowing">
            <summary>
              Border following algorithm for contour extraction.
            </summary>
            
            <example>
            <code>
            // Create a new border following algorithm
            BorderFollowing bf = new BorderFollowing();
            
            // Get all points in the contour of the image. 
            List&lt;IntPoint> contour = bf.FindContour(grayscaleImage);
            
            // Mark all points in the contour point list in blue
            new PointsMarker(contour, Color.Blue).ApplyInPlace(image);
            
            // Show the result
            ImageBox.Show(image);
            </code>
            
            <para>
              The resulting image is shown below.</para>
              
            <img src="..\images\border-following.png" /> 
            
            </example>
            
        </member>
        <member name="P:Accord.Imaging.BorderFollowing.Threshold">
            <summary>
              Gets or sets the pixel value threshold above which a pixel
              is considered white (belonging to the object). Default is zero.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.BorderFollowing.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.BorderFollowing"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.BorderFollowing.#ctor(System.Byte)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.BorderFollowing"/> class.
            </summary>
            
            <param name="threshold">The pixel value threshold above which a pixel
            is considered black (belonging to the object). Default is zero.</param>
            
        </member>
        <member name="M:Accord.Imaging.BorderFollowing.FindContour(System.Drawing.Bitmap)">
            <summary>
            Extracts the contour from a single object in a grayscale image.
            </summary>
            
            <param name="image">A grayscale image.</param>
            <returns>A list of <see cref="T:Accord.IntPoint"/>s defining a contour.</returns>
            
        </member>
        <member name="M:Accord.Imaging.BorderFollowing.FindContour(System.Drawing.Imaging.BitmapData)">
            <summary>
              Extracts the contour from a single object in a grayscale image.
            </summary>
            
            <param name="image">A grayscale image.</param>
            
            <returns>
            A list of <see cref="T:Accord.IntPoint"/>s defining a contour.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.BorderFollowing.FindContour(Accord.Imaging.UnmanagedImage)">
            <summary>
              Extracts the contour from a single object in a grayscale image.
            </summary>
            
            <param name="image">A grayscale image.</param>
            <returns>A list of <see cref="T:Accord.IntPoint"/>s defining a contour.</returns>
            
        </member>
        <member name="T:Accord.Imaging.IContourExtractionAlgorithm">
            <summary>
              Common interface for contour extraction algorithm.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.IContourExtractionAlgorithm.FindContour(System.Drawing.Bitmap)">
            <summary>
              Extracts the contour from a single object in a grayscale image.
            </summary>
            <param name="image">A grayscale image.</param>
            <returns>A list of <see cref="T:Accord.IntPoint"/>s defining a contour.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IContourExtractionAlgorithm.FindContour(System.Drawing.Imaging.BitmapData)">
            <summary>
              Extracts the contour from a single object in a grayscale image.
            </summary>
            <param name="image">A grayscale image.</param>
            <returns>A list of <see cref="T:Accord.IntPoint"/>s defining a contour.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IContourExtractionAlgorithm.FindContour(Accord.Imaging.UnmanagedImage)">
            <summary>
              Extracts the contour from a single object in a grayscale image.
            </summary>
            <param name="image">A grayscale image.</param>
            <returns>A list of <see cref="T:Accord.IntPoint"/>s defining a contour.</returns>
            
        </member>
        <member name="T:Accord.Imaging.Converters.NamespaceDoc">
            <summary>
             Contains classes and methods to convert between different image representations, 
             such as between common images, numeric matrices and arrays.
            </summary>
            
            <remarks>
            <para>
              The image converters are able to convert to and from images defined as <c>byte</c>,
              <c>double</c> and <c>float</c> multi-dimensional matrices, jagged matrices, and even
              images represented as flat arrays. It is also possible to convert images defined as
              series of individual pixel colors into <see cref="T:System.Drawing.Bitmap"/>s, and back from those
              <see cref="T:System.Drawing.Bitmap"/>s into any of the aforementioned representations. Support for
              AForge.NET's UnmanagedImage is also available.
              </para>
              
            <para>
              The namespace class diagram is shown below. </para>
              <img src="..\diagrams\classes\Accord.Imaging.Converters.png" />
            </remarks>
              
        </member>
        <member name="T:Accord.Imaging.Converters.ArrayToImage">
             <summary>
               Jagged array to Bitmap converter.
             </summary>
             
             <remarks>
             <para>
               This class can convert double and float arrays to either Grayscale
               or color Bitmap images. Color images should be represented as an
               array of pixel values for the final image. The actual dimensions
               of the image should be specified in the class constructor.</para>
               
             <para>
               When this class is converting from <see cref="T:byte[]"/> or
               <see cref="T:System.Drawing.Color[]"/>, the values of the <see cref="P:Accord.Imaging.Converters.ArrayToImage.Max"/>
               and <see cref="P:Accord.Imaging.Converters.ArrayToImage.Min"/> properties are ignored and no scaling operation
               is performed.</para>
             </remarks>
             
             <example>
             <para>
               This example converts a single array of double-precision floating-
               point numbers with values from 0 to 1 into a grayscale image.</para>
               
             <code>
             // Create an array representation 
             // of a 4x4 image with a inner 2x2
             // square drawn in the middle
            
             double[] pixels = 
             {
                 0, 0, 0, 0, 
                 0, 1, 1, 0, 
                 0, 1, 1, 0, 
                 0, 0, 0, 0, 
             };
            
             // Create the converter to create a Bitmap from the array
             ArrayToImage conv = new ArrayToImage(width: 4, height: 4);
            
             // Declare an image and store the pixels on it
             Bitmap image; conv.Convert(pixels, out image);
            
             // Show the image on screen
             image = new ResizeNearestNeighbor(320, 320).Apply(image);
             ImageBox.Show(image, PictureBoxSizeMode.Zoom);
             </code>
             
             <para>
               The resulting image is shown below.</para>
               
             <img src="..\images\matrix-to-image.png" />
             
             </example>
             
        </member>
        <member name="P:Accord.Imaging.Converters.ArrayToImage.Max">
            <summary>
              Gets or sets the maximum double value in the
              double array associated with the brightest color.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Converters.ArrayToImage.Min">
            <summary>
              Gets or sets the minimum double value in the
              double array associated with the darkest color.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Converters.ArrayToImage.Height">
            <summary>
              Gets or sets the height of the image
              stored in the double array.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Converters.ArrayToImage.Width">
            <summary>
              Gets or sets the width of the image
              stored in the double array.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.#ctor(System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Converters.ArrayToImage"/> class.
            </summary>
            
            <param name="width">The width of the image to be created.</param>
            <param name="height">The height of the image to be created.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.#ctor(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Converters.ArrayToImage"/> class.
            </summary>
            
            <param name="width">The width of the image to be created.</param>
            <param name="height">The height of the image to be created.</param>
            <param name="min">
              The minimum double value in the double array
              associated with the darkest color. Default is 0.
            </param>
            <param name="max">
              The maximum double value in the double array
              associated with the brightest color. Default is 1.
            </param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Double[],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Single[],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Byte[],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
              For byte transformations, the Min and Max properties
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Double[],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Single[],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Byte[],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
              For byte transformations, the Min and Max properties
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Double[][],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Single[][],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Byte[][],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
              For byte transformations, the Min and Max properties
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Drawing.Color[],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
              For byte transformations, the Min and Max properties are ignored. The 
              resulting image from upon calling this method will always be <see cref=
              "F:System.Drawing.Imaging.PixelFormat.Format32bppArgb">32-bit ARGB</see>.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Double[][],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Single[][],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Byte[][],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
              For byte transformations, the Min and Max properties
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ArrayToImage.Convert(System.Drawing.Color[],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="T:Accord.Imaging.Converters.IConverter`2">
            <summary>
              Public interface for image converter algorithms.
            </summary>
            
            <typeparam name="TInput">Input image type.</typeparam>
            <typeparam name="TOutput">Output image type.</typeparam>
            
        </member>
        <member name="M:Accord.Imaging.Converters.IConverter`2.Convert(`0,`1@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="T:Accord.Imaging.Converters.MatrixToImage">
            <summary>
              Multidimensional array to Bitmap converter.
            </summary>
            
            <remarks>
              This class can convert double and float multidimensional arrays
              (matrices) to Grayscale bitmaps. The color representation of the
              values contained in the matrices must be specified through the 
              Min and Max properties of the class or class constructor.
            </remarks>
            
            <example>
            <para>
              This example converts a multidimensional array of double-precision
              floating-point numbers with values from 0 to 1 into a grayscale image.</para>
              
            <code>
            // Create a matrix representation 
            // of a 4x4 image with a inner 2x2
            // square drawn in the middle
            
            double[,] pixels = 
            {
                 { 0, 0, 0, 0 },
                 { 0, 1, 1, 0 },
                 { 0, 1, 1, 0 },
                 { 0, 0, 0, 0 },
            };
            
            // Create the converter to convert the matrix to a image
            MatrixToImage conv = new MatrixToImage(min: 0, max: 1);
            
            // Declare an image and store the pixels on it
            Bitmap image; conv.Convert(pixels, out image);
            
            // Show the image on screen
            image = new ResizeNearestNeighbor(320, 320).Apply(image);
            ImageBox.Show(image, PictureBoxSizeMode.Zoom);
            </code>
            
            <para>
              The resulting image is shown below.</para>
              
            <img src="..\images\matrix-to-image.png" />
            
            </example>
            
        </member>
        <member name="P:Accord.Imaging.Converters.MatrixToImage.Max">
            <summary>
              Gets or sets the maximum double value in the
              double array associated with the brightest color.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Converters.MatrixToImage.Min">
            <summary>
              Gets or sets the minimum double value in the
              double array associated with the darkest color.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Converters.MatrixToImage.Format">
            <summary>
              Gets or sets the desired output format of the image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.#ctor(System.Double,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Converters.MatrixToImage"/> class.
            </summary>
            
            <param name="min">
              The minimum double value in the double array
              associated with the darkest color. Default is 0.
            </param>
            <param name="max">
              The maximum double value in the double array
              associated with the brightest color. Default is 1.
            </param>
              
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Converters.MatrixToImage"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Double[0:,0:],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Double[][],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Single[0:,0:],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Single[][],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Byte[0:,0:],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Byte[][],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Int32[0:,0:],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Int32[][],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Int16[0:,0:],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Int16[][],Accord.Imaging.UnmanagedImage@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Double[0:,0:],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Double[][],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Single[0:,0:],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Single[][],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Byte[0:,0:],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Byte[][],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Int32[0:,0:],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Int32[][],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Int16[0:,0:],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.MatrixToImage.Convert(System.Int16[][],System.Drawing.Bitmap@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="T:Accord.Imaging.Converters.ImageToArray">
            <summary>
              Bitmap to jagged array converter.
            </summary>
            
            <remarks>
              This class converts images to single or jagged arrays of
              either double-precision or single-precision floating-point
              values.
            </remarks>
            
            <example>
            <para>
              This example converts a 16x16 Bitmap image into
              a double[] array with values between 0 and 1.</para>
              
            <code>
            // Obtain a 16x16 bitmap image
            // Bitmap image = ...
            
            // Show on screen
            ImageBox.Show(image, PictureBoxSizeMode.Zoom);
            
            // Create the converter to convert the image to an
            //   array containing only values between 0 and 1 
            ImageToArray conv = new ImageToArray(min: 0, max: 1);
            
            // Convert the image and store it in the array
            double[] array; conv.Convert(image, out array);
            
            // Show the array on screen
            ImageBox.Show(array, 16, 16, PictureBoxSizeMode.Zoom);    /// </code>
            
            <para>
              The resulting image is shown below.</para>
            
            <img src="..\images\image-to-matrix.png" />
            
            </example>
            
        </member>
        <member name="P:Accord.Imaging.Converters.ImageToArray.Max">
            <summary>
              Gets or sets the maximum double value in the
              double array associated with the brightest color.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Converters.ImageToArray.Min">
            <summary>
              Gets or sets the minimum double value in the
              double array associated with the darkest color.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Converters.ImageToArray.Channel">
            <summary>
              Gets or sets the channel to be extracted.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToArray.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Converters.ImageToArray"/> class.
            </summary>
            
            <param name="min">
              The minimum double value in the double array
              associated with the darkest color. Default is 0.
            </param>
            <param name="max">
              The maximum double value in the double array
              associated with the brightest color. Default is 1.
            </param>
            <param name="channel">The channel to extract. Default is 0.</param>
              
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToArray.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Converters.ImageToArray"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToArray.#ctor(System.Double,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Converters.ImageToArray"/> class.
            </summary>
            
            <param name="min">
              The minimum double value in the double array
              associated with the darkest color. Default is 0.
            </param>
            <param name="max">
              The maximum double value in the double array
              associated with the brightest color. Default is 1.
            </param>
              
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToArray.Convert(System.Drawing.Bitmap,System.Double[][]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToArray.Convert(System.Drawing.Bitmap,System.Single[][]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToArray.Convert(System.Drawing.Bitmap,System.Double[]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToArray.Convert(System.Drawing.Bitmap,System.Single[]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToArray.Convert(System.Drawing.Bitmap,System.Drawing.Color[]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToArray.Convert(Accord.Imaging.UnmanagedImage,System.Double[][]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToArray.Convert(Accord.Imaging.UnmanagedImage,System.Single[][]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToArray.Convert(Accord.Imaging.UnmanagedImage,System.Double[]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToArray.Convert(Accord.Imaging.UnmanagedImage,System.Single[]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToArray.Convert(Accord.Imaging.UnmanagedImage,System.Drawing.Color[]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="T:Accord.Imaging.Converters.ImageToMatrix">
             <summary>
               Bitmap to multidimensional matrix converter.
             </summary>
             
             <remarks>
               This class converts images to multidimensional matrices of
               either double-precision or single-precision floating-point
               values.
             </remarks>
             
             <example>
             <para>
               This example converts a 16x16 Bitmap image into
               a double[,] array with values between 0 and 1.</para>
               
             <code>
             // Obtain an image
             // Bitmap image = ...
            
             // Show on screen
             ImageBox.Show(image, PictureBoxSizeMode.Zoom);
            
             // Create the converter to convert the image to a
             //  matrix containing only values between 0 and 1 
             ImageToMatrix conv = new ImageToMatrix(min: 0, max: 1);
            
             // Convert the image and store it in the matrix
             double[,] matrix; conv.Convert(image, out matrix);
            
             // Show the matrix on screen as an image
             ImageBox.Show(matrix, PictureBoxSizeMode.Zoom);
             </code>
             <para>
               The resulting image is shown below.</para>
             
             <img src="..\images\image-to-matrix.png" />
             
             <para>
               Additionally, the image can also be shown in alternative
               representations such as text or data tables.
             </para>
             
             <code>
             // Show the matrix on screen as a .NET multidimensional array
             MessageBox.Show(matrix.ToString(CSharpMatrixFormatProvider.InvariantCulture));
            
             // Show the matrix on screen as a table
             DataGridBox.Show(matrix, nonBlocking: true)
                 .SetAutoSizeColumns(DataGridViewAutoSizeColumnsMode.Fill)
                 .SetAutoSizeRows(DataGridViewAutoSizeRowsMode.AllCellsExceptHeaders)
                 .SetDefaultFontSize(5)
                .WaitForClose();
             </code>
             
              <para>
               The resulting images are shown below.</para>
               
             <img src="..\images\image-to-matrix-string.png" />
             <img src="..\images\image-to-matrix-table.png" />
             
             </example>
             
        </member>
        <member name="P:Accord.Imaging.Converters.ImageToMatrix.Max">
            <summary>
              Gets or sets the maximum double value in the
              double array associated with the brightest color.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Converters.ImageToMatrix.Min">
            <summary>
              Gets or sets the minimum double value in the
              double array associated with the darkest color.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Converters.ImageToMatrix.Channel">
            <summary>
              Gets or sets the channel to be extracted.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Converters.ImageToMatrix"/> class.
            </summary>
            
            <param name="min">
              The minimum double value in the double array
              associated with the darkest color. Default is 0.
            </param>
            <param name="max">
              The maximum double value in the double array
              associated with the brightest color. Default is 1.
            </param>
            <param name="channel">The channel to extract. Default is 0.</param>
              
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Converters.ImageToMatrix"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.#ctor(System.Double,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Converters.ImageToMatrix"/> class.
            </summary>
            
            <param name="min">
              The minimum double value in the double array
              associated with the darkest color. Default is 0.
            </param>
            <param name="max">
              The maximum double value in the double array
              associated with the brightest color. Default is 1.
            </param>
              
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Double[0:,0:]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Double[][]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Single[0:,0:]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Single[][]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Byte[0:,0:]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Byte[][]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Drawing.Color[0:,0:]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Drawing.Color[][]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Double[0:,0:,0:]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Double[][][]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Single[0:,0:,0:]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Single[][][]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Byte[0:,0:,0:]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(System.Drawing.Bitmap,System.Byte[][][]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Double[0:,0:]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Double[][]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Single[0:,0:]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Single[][]@)">
            <summary>
              Converts an image from one representation to another.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Byte[0:,0:]@)">
            <summary>
              Converts an image from one representation to another. When
              converting to byte, the <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Max"/> and <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Min"/>
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Byte[][]@)">
            <summary>
              Converts an image from one representation to another. When
              converting to byte, the <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Max"/> and <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Min"/>
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Drawing.Color[0:,0:]@)">
            <summary>
              Converts an image from one representation to another. When
              converting to byte, the <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Max"/> and <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Min"/>
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Drawing.Color[][]@)">
            <summary>
              Converts an image from one representation to another. When
              converting to byte, the <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Max"/> and <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Min"/>
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Double[][][]@)">
            <summary>
              Converts an image from one representation to another. When
              converting to byte, the <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Max"/> and <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Min"/>
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Single[0:,0:,0:]@)">
            <summary>
              Converts an image from one representation to another. When
              converting to byte, the <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Max"/> and <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Min"/>
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Single[][][]@)">
            <summary>
              Converts an image from one representation to another. When
              converting to byte, the <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Max"/> and <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Min"/>
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Byte[0:,0:,0:]@)">
            <summary>
              Converts an image from one representation to another. When
              converting to byte, the <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Max"/> and <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Min"/>
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Byte[][][]@)">
            <summary>
              Converts an image from one representation to another. When
              converting to byte, the <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Max"/> and <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Min"/>
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="M:Accord.Imaging.Converters.ImageToMatrix.Convert(Accord.Imaging.UnmanagedImage,System.Double[0:,0:,0:]@)">
            <summary>
              Converts an image from one representation to another. When
              converting to byte, the <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Max"/> and <see cref="P:Accord.Imaging.Converters.ImageToMatrix.Min"/>
              are ignored.
            </summary>
            
            <param name="input">The input image to be converted.</param>
            <param name="output">The converted image.</param>
            
        </member>
        <member name="T:Accord.Imaging.FeatureDescriptor">
            <summary>
              Standard feature descriptor for <see cref="T:double[]" /> feature vectors.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.FeatureDescriptor.Descriptor">
            <summary>
              Gets or sets the descriptor vector
              associated with this point.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor.#ctor(System.Double[])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.FeatureDescriptor"/> structure.
            </summary>
            
            <param name="value">The feature vector.</param>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor.op_Implicit(System.Double[])~Accord.Imaging.FeatureDescriptor">
            <summary>
              Performs an implicit conversion from <see cref="T:double[]"/> 
              to <see cref="T:Accord.Imaging.FeatureDescriptor"/>.
            </summary>
            
            <param name="value">The value to be converted.</param>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor.FromArray(System.Double[])">
            <summary>
              Performs a conversion from <see cref="T:double[]"/> 
              to <see cref="T:Accord.Imaging.FeatureDescriptor"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor.op_Implicit(Accord.Imaging.FeatureDescriptor{System.Double[]})~Accord.Imaging.FeatureDescriptor">
            <summary>
              Performs an implicit conversion from <see cref="T:double[]"/> 
              to <see cref="T:Accord.Imaging.FeatureDescriptor"/>.
            </summary>
            
            <param name="value">The value to be converted.</param>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor.FromGeneric(Accord.Imaging.FeatureDescriptor{System.Double[]})">
            <summary>
              Performs a conversion from <see cref="T:double[]" /> 
              to <see cref="T:Accord.Imaging.FeatureDescriptor"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor.FromValue``1(``0)">
            <summary>
              Performs a conversion from <typeparam name="T"/>
              to <see cref="T:Accord.Imaging.FeatureDescriptor`1"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor.op_Equality(Accord.Imaging.FeatureDescriptor,Accord.Imaging.FeatureDescriptor)">
            <summary>
              Implements the operator ==.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor.op_Inequality(Accord.Imaging.FeatureDescriptor,Accord.Imaging.FeatureDescriptor)">
            <summary>
              Implements the operator !=.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor.GetHashCode">
            <summary>
              Returns a hash code for this instance.
            </summary>
            
            <returns>
              A hash code for this instance, suitable for use in hashing
              algorithms and data structures like a hash table. 
            </returns>
            
        </member>
        <member name="T:Accord.Imaging.FeatureDescriptor`1">
            <summary>
              Standard feature descriptor for generic feature vectors.
            </summary>
            
            <typeparam name="T">The type of feature vector, such as <see cref="T:double[]"/>.</typeparam>
            
        </member>
        <member name="P:Accord.Imaging.FeatureDescriptor`1.Descriptor">
            <summary>
              Gets or sets the descriptor vector
              associated with this point.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor`1.#ctor(`0)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.FeatureDescriptor"/> struct.
            </summary>
            
            <param name="value">The feature vector.</param>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor`1.op_Implicit(`0)~Accord.Imaging.FeatureDescriptor{`0}">
            <summary>
              Performs an implicit conversion from <typeparamref name="T"/>
              to <see cref="T:Accord.Imaging.FeatureDescriptor"/>.
            </summary>
            
            <param name="value">The value to be converted.</param>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor`1.op_Equality(Accord.Imaging.FeatureDescriptor{`0},Accord.Imaging.FeatureDescriptor{`0})">
            <summary>
              Implements the operator ==.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor`1.op_Inequality(Accord.Imaging.FeatureDescriptor{`0},Accord.Imaging.FeatureDescriptor{`0})">
            <summary>
              Implements the operator !=.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor`1.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.FeatureDescriptor`1.GetHashCode">
            <summary>
              Returns a hash code for this instance.
            </summary>
            
            <returns>
              A hash code for this instance, suitable for use in hashing
              algorithms and data structures like a hash table. 
            </returns>
            
        </member>
        <member name="T:Accord.Imaging.ObjectiveFidelity">
            <summary>
              Objective Fidelity Criteria.
            </summary>
            
            <remarks>
            <para>
              References:
              <list type="bullet">
                <item><description>
                    H.T. Yalazan, J.D. Yucel. "A new objective fidelity criterion
                    for image processing." Proceedings of the 16th International 
                    Conference on Pattern Recognition, 2002.</description></item>
              </list></para>  
            </remarks>
              
            <example>
            <code>
            Bitmap ori = ... // Original picture
            Bitmap recon = ... // Reconstructed picture
            
            // Create a new Objective fidelity comparer:
            var of = new ObjectiveFidelity(ori, recon);
            
            // Get the results
            long errorTotal = of.ErrorTotal;
            double msr = of.MeanSquareError;
            double snr = of.SignalToNoiseRatio;
            double psnr = of.PeakSignalToNoiseRatio;
            double dsnr = of.DerivativeSignalNoiseRatio;
            </code>
            </example>
            
        </member>
        <member name="P:Accord.Imaging.ObjectiveFidelity.AbsoluteError">
            <summary>
             Gets the total error between the two images.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ObjectiveFidelity.MeanError">
            <summary>
              Gets the average error between the two images.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ObjectiveFidelity.MeanSquareError">
            <summary>
              Gets the root mean square error between the two images.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ObjectiveFidelity.SignalToNoiseRatio">
            <summary>
              Gets the signal to noise ratio.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ObjectiveFidelity.PeakSignalToNoiseRatio">
            <summary>
              Gets the peak signal to noise ratio.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ObjectiveFidelity.DerivativeSignalNoiseRatio">
            <summary>
              Gets the derivative signal to noise ratio.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ObjectiveFidelity.Level">
            <summary>
              Gets the level used in peak signal to noise ratio.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ObjectiveFidelity.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.ObjectiveFidelity"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ObjectiveFidelity.#ctor(System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.ObjectiveFidelity"/> class.
            </summary>
            
            <param name="a">The first image to be compared.</param>
            <param name="b">The second image that will be compared.</param>
            
        </member>
        <member name="M:Accord.Imaging.ObjectiveFidelity.#ctor(System.Drawing.Imaging.BitmapData,System.Drawing.Imaging.BitmapData)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.ObjectiveFidelity"/> class.
            </summary>
            
            <param name="a">The first image to be compared.</param>
            <param name="b">The second image that will be compared.</param>
            
        </member>
        <member name="M:Accord.Imaging.ObjectiveFidelity.#ctor(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.ObjectiveFidelity"/> class.
            </summary>
            
            <param name="a">The first image to be compared.</param>
            <param name="b">The second image that will be compared.</param>
            
        </member>
        <member name="M:Accord.Imaging.ObjectiveFidelity.Compute(System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
              Compute objective fidelity metrics.
            </summary>
            
            <param name="a">The first image to be compared.</param>
            <param name="b">The second image that will be compared.</param>
            
        </member>
        <member name="M:Accord.Imaging.ObjectiveFidelity.Compute(System.Drawing.Imaging.BitmapData,System.Drawing.Imaging.BitmapData)">
            <summary>
              Compute objective fidelity metrics.
            </summary>
            
            <param name="a">The first image to be compared.</param>
            <param name="b">The second image that will be compared.</param>
            
        </member>
        <member name="M:Accord.Imaging.ObjectiveFidelity.Compute(Accord.Imaging.UnmanagedImage,Accord.Imaging.UnmanagedImage)">
            <summary>
              Compute objective fidelity metrics.
            </summary>
            
            <param name="a">The first image to be compared.</param>
            <param name="b">The second image that will be compared.</param>
            
        </member>
        <member name="T:Accord.Imaging.DrawingExtensions">
            <summary>
              Extension methods for drawwing structures.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.DrawingExtensions.ToRectangle(Accord.Math.Hyperrectangle)">
            <summary>
              Convert the given hyperrectangle in to a System.Drawing.Rectangle.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.DrawingExtensions.ToRectangleF(Accord.Math.Hyperrectangle)">
            <summary>
              Convert the given hyperrectangle in to a System.Drawing.RectangleF.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.DrawingExtensions.ToHyperrectangle(System.Drawing.Rectangle)">
            <summary>
              Convert the given System.Drawing.Rectangle to a <see cref="T:Accord.Math.Hyperrectangle"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.DrawingExtensions.ToHyperrectangle(System.Drawing.RectangleF)">
            <summary>
              Convert the given System.Drawing.RectangleF to a <see cref="T:Accord.Math.Hyperrectangle"/>.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.UnsafeTools">
            <summary>
              Static tool functions for imaging.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.UnsafeTools.Sum(System.Byte*,System.Int32,System.Int32,System.Int32)">
            <summary>
              Computes the sum of all pixels 
              within a given image region.
            </summary>
            
            <param name="src">The image region.</param>
            <param name="width">The region width.</param>
            <param name="height">The region height.</param>
            <param name="stride">The image stride.</param>
            
            <returns>The sum of all pixels within the region.</returns>
            
        </member>
        <member name="M:Accord.Imaging.UnsafeTools.Mean(System.Byte*,System.Int32,System.Int32,System.Int32)">
            <summary>
              Computes the mean pixel value 
              within a given image region.
            </summary>
            
            <param name="src">The image region.</param>
            <param name="width">The region width.</param>
            <param name="height">The region height.</param>
            <param name="stride">The image stride.</param>
            
            <returns>The mean pixel value within the region.</returns>
            
        </member>
        <member name="M:Accord.Imaging.UnsafeTools.Scatter(System.Byte*,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
              Computes the pixel scatter 
              within a given image region.
            </summary>
            
            <param name="src">The image region.</param>
            <param name="width">The region width.</param>
            <param name="height">The region height.</param>
            <param name="stride">The image stride.</param>
            <param name="mean">The region pixel mean.</param>
            
            <returns>The scatter value within the region.</returns>
            
        </member>
        <member name="M:Accord.Imaging.UnsafeTools.Variance(System.Byte*,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
              Computes the pixel variance 
              within a given image region.
            </summary>
            
            <param name="src">The image region.</param>
            <param name="width">The region width.</param>
            <param name="height">The region height.</param>
            <param name="stride">The image stride.</param>
            <param name="mean">The region pixel mean.</param>
            
            <returns>The variance value within the region.</returns>
            
        </member>
        <member name="T:Accord.Imaging.CooccurrenceDegree">
            <summary>
              Co-occurrence Degree.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.CooccurrenceDegree.Degree0">
            <summary>
              Find co-occurrences at 0Â° degrees.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.CooccurrenceDegree.Degree45">
            <summary>
              Find co-occurrences at 45Â° degrees.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.CooccurrenceDegree.Degree90">
            <summary>
              Find co-occurrences at 90Â° degrees.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.CooccurrenceDegree.Degree135">
            <summary>
              Find co-occurrences at 135Â° degrees.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.GrayLevelCooccurrenceMatrix">
            <summary>
              Gray-Level Co-occurrence Matrix (GLCM).
            </summary>
            
            <remarks>
            <para>
              A co-occurrence matrix or co-occurrence distribution is a matrix that is defined over an image to 
              be the distribution of co-occurring pixel values (grayscale values, or colors) at a given offset.</para>
              
            <para>
              Any matrix or pair of matrices can be used to generate a co-occurrence matrix, though their most 
              common application has been in measuring texture in images, so the typical definition, as above, 
              assumes that the matrix is an image. It is also possible to define the matrix across two different
              images.Such a matrix can then be used for color mapping.</para>
            </remarks>
            
            <remarks>
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Mryka Hall-Beyer, "The GLCM Tutorial Home Page", The GLCM Tutorial Home Page.
                  Available in: http://www.fp.ucalgary.ca/mhallbey/tutorial.htm </description></item>
                <item><description><a href="https://en.wikipedia.org/wiki/Co-occurrence_matrix">
                  Wikipedia contributors. "Co-occurrence matrix." Wikipedia, The Free Encyclopedia. 
                  Wikipedia, The Free Encyclopedia, 7 Sep. 2016. Web. 27 Jan. 2017. Available in 
                  https://en.wikipedia.org/wiki/Co-occurrence_matrix </a></description></item>
              </list>
            </para>   
            </remarks>
            
            <example>
            <para>
              Gray-level Cooccurrence matrices can be computed directly from images:</para>
              <code source="Unit Tests\Accord.Tests.Imaging\GrayLevelCooccurrenceMatrixTest.cs" region="doc_learn" />
              
            <para>
              These matrices also play a major role in the computation of <see cref="T:Accord.Imaging.Haralick"/> descriptors. For
              more examples, including on how to use those matrices for image classification, please see <see cref="T:Accord.Imaging.Haralick"/>
              and <see cref="T:Accord.Imaging.HaralickDescriptor"/> documentation pages.</para>
            </example>
            
            <seealso cref="T:Accord.Imaging.Haralick"/>
            <seealso cref="T:Accord.Imaging.HaralickDescriptor"/>
            
        </member>
        <member name="P:Accord.Imaging.GrayLevelCooccurrenceMatrix.AutoGray">
            <summary>
              Gets or sets whether the maximum value of gray should be
              automatically computed from the image. If set to false,
              the maximum gray value will be assumed 255.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.GrayLevelCooccurrenceMatrix.Normalize">
            <summary>
              Gets or sets whether the produced GLCM should be normalized,
              dividing each element by the number of pairs. Default is true.
            </summary>
            
            <value>
              <c>true</c> if the GLCM should be normalized; otherwise, <c>false</c>.
            </value>
            
        </member>
        <member name="P:Accord.Imaging.GrayLevelCooccurrenceMatrix.Degree">
            <summary>
              Gets or sets the direction at which the co-occurrence should 
              be found. Default is <see cref="F:Accord.Imaging.CooccurrenceDegree.Degree0"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.GrayLevelCooccurrenceMatrix.Distance">
            <summary>
              Gets or sets the distance at which the 
              texture should be analyzed. Default is 1.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.GrayLevelCooccurrenceMatrix.Pairs">
            <summary>
              Gets the number of pairs registered during the
              last <see cref="M:Accord.Imaging.GrayLevelCooccurrenceMatrix.Compute(Accord.Imaging.UnmanagedImage)">computed GLCM</see>.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelCooccurrenceMatrix.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.GrayLevelCooccurrenceMatrix"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelCooccurrenceMatrix.#ctor(System.Int32,Accord.Imaging.CooccurrenceDegree)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.GrayLevelCooccurrenceMatrix"/> class.
            </summary>
            
            <param name="distance">The distance at which the texture should be analyzed. Default is 1.</param>
            <param name="degree">The direction to look for co-occurrences. Default is <see cref="F:Accord.Imaging.CooccurrenceDegree.Degree0"/>.</param>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelCooccurrenceMatrix.#ctor(System.Int32,Accord.Imaging.CooccurrenceDegree,System.Boolean,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.GrayLevelCooccurrenceMatrix"/> class.
            </summary>
            
            <param name="distance">The distance at which the texture should be analyzed. Default is 1.</param>
            <param name="degree">The direction to look for co-occurrences. Default is <see cref="F:Accord.Imaging.CooccurrenceDegree.Degree0"/>.</param>
            <param name="autoGray">Whether the maximum value of gray should be
              automatically computed from the image. Default is true.</param>
            <param name="normalize">Whether the produced GLCM should be normalized,
              dividing each element by the number of pairs. Default is true.</param>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelCooccurrenceMatrix.Compute(System.Drawing.Bitmap)">
            <summary>
              Computes the Gray-level Co-occurrence Matrix (GLCM) 
              for the given source image.
            </summary>
            
            <param name="source">The source image.</param>
            
            <returns>A square matrix of double-precision values containing
            the GLCM for the given <paramref name="source"/>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelCooccurrenceMatrix.Compute(System.Drawing.Imaging.BitmapData)">
            <summary>
              Computes the Gray-level Co-occurrence Matrix (GLCM) 
              for the given source image.
            </summary>
            
            <param name="source">The source image.</param>
            
            <returns>A square matrix of double-precision values containing
            the GLCM for the given <paramref name="source"/>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelCooccurrenceMatrix.Compute(Accord.Imaging.UnmanagedImage)">
            <summary>
              Computes the Gray-level Co-occurrence Matrix (GLCM) 
              for the given source image.
            </summary>
            
            <param name="source">The source image.</param>
            
            <returns>A square matrix of double-precision values containing
            the GLCM for the given <paramref name="source"/>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelCooccurrenceMatrix.Compute(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
              Computes the Gray-level Co-occurrence Matrix for the given matrix.
            </summary>
            
            <param name="source">The source image.</param>
            <param name="region">A region of the source image where
             the GLCM should be computed for.</param>
            
            <returns>A square matrix of double-precision values containing the GLCM for the
              <paramref name="region"/> of the given <paramref name="source"/>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelCooccurrenceMatrix.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="T:Accord.Imaging.GrayLevelDifferenceMethod">
            <summary>
              Gray-Level Difference Method (GLDM).
            </summary>
            
            <remarks>
              Computes an gray-level histogram of difference 
              values between adjacent pixels in an image.
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.GrayLevelDifferenceMethod.AutoGray">
            <summary>
              Gets or sets whether the maximum value of gray should be
              automatically computed from the image. If set to false,
              the maximum gray value will be assumed 255.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.GrayLevelDifferenceMethod.Degree">
            <summary>
              Gets or sets the direction at which the co-occurrence should be found.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelDifferenceMethod.#ctor(Accord.Imaging.CooccurrenceDegree)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.GrayLevelDifferenceMethod"/> class.
            </summary>
            
            <param name="degree">The direction at which the co-occurrence should be found.</param>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelDifferenceMethod.#ctor(Accord.Imaging.CooccurrenceDegree,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.GrayLevelDifferenceMethod"/> class.
            </summary>
            
            <param name="degree">The direction at which the co-occurrence should be found.</param>
            <param name="autoGray">Whether the maximum value of gray should be
              automatically computed from the image. Default is true.</param>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelDifferenceMethod.Compute(Accord.Imaging.UnmanagedImage)">
            <summary>
              Computes the Gray-level Difference Method (GLDM)
              Histogram for the given source image.
            </summary>
            
            <param name="source">The source image.</param>
            
            <returns>An histogram containing co-occurrences 
            for every gray level in <paramref name="source"/>.</returns>
            
        </member>
        <member name="T:Accord.Imaging.GrayLevelRunLengthMatrix">
            <summary>
              Gray-Level Run-Length Matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.GrayLevelRunLengthMatrix.AutoGray">
            <summary>
              Gets or sets whether the maximum value of gray should be
              automatically computed from the image. If set to false,
              the maximum gray value will be assumed 255.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.GrayLevelRunLengthMatrix.Degree">
            <summary>
              Gets or sets the direction at which the co-occurrence should be found.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.GrayLevelRunLengthMatrix.Primitives">
            <summary>
              Gets the number of primitives found in the last 
              call to <see cref="M:Accord.Imaging.GrayLevelRunLengthMatrix.Compute(Accord.Imaging.UnmanagedImage)"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelRunLengthMatrix.#ctor(Accord.Imaging.CooccurrenceDegree)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.GrayLevelDifferenceMethod"/> class.
            </summary>
            
            <param name="degree">The direction at which the co-occurrence should be found.</param>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelRunLengthMatrix.#ctor(Accord.Imaging.CooccurrenceDegree,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.GrayLevelDifferenceMethod"/> class.
            </summary>
            
            <param name="degree">The direction at which the co-occurrence should be found.</param>
            <param name="autoGray">Whether the maximum value of gray should be
              automatically computed from the image. Default is true.</param>
            
        </member>
        <member name="M:Accord.Imaging.GrayLevelRunLengthMatrix.Compute(Accord.Imaging.UnmanagedImage)">
            <summary>
              Computes the Gray-level Run-length for the given image source.
            </summary>
            
            <param name="source">The source image.</param>
            
            <returns>An array of run-length vectors containing level counts
              for every width pixel in <paramref name="source"/>.</returns>
            
        </member>
        <member name="T:Accord.Imaging.IFeaturePoint">
            <summary>
              Common interface for feature points.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.IFeaturePoint.X">
            <summary>
              Gets or sets the x-coordinate of this point.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.IFeaturePoint.Y">
            <summary>
              Gets or sets the y-coordinate of this point.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.IFeaturePoint`1">
            <summary>
              Common interface for feature points.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.HaralickMode">
            <summary>
              <see cref="T:Accord.Imaging.Haralick"/>'s operation modes.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.HaralickMode.Average">
            <summary>
              Features will be combined using 
              <see cref="M:Accord.Imaging.HaralickDescriptorDictionary.Average(System.Int32)"/>.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.HaralickMode.AverageWithRange">
            <summary>
              Features will be combined using 
              <see cref="M:Accord.Imaging.HaralickDescriptorDictionary.AverageWithRange(System.Int32)"/>.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.HaralickMode.Combine">
            <summary>
              Features will be combined using 
              <see cref="M:Accord.Imaging.HaralickDescriptorDictionary.Combine(System.Int32)"/>.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.HaralickMode.NormalizedAverage">
            <summary>
              Features will be combined using 
              <see cref="M:Accord.Imaging.HaralickDescriptorDictionary.Normalize(System.Int32)"/>.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.Haralick">
            <summary>
              Haralick textural feature extractor.
            </summary>
            
            <remarks>
            <para>
              Haralick's texture features are based on measures derived from
              <see cref="T:Accord.Imaging.GrayLevelCooccurrenceMatrix">Gray-level Co-occurrence 
              matrices (GLCM)</see>.</para>
            <para>
              Whether considering the intensity or grayscale values of the image 
              or various dimensions of color, the co-occurrence matrix can measure
              the texture of the image. Because co-occurrence matrices are typically
              large and sparse, various metrics of the matrix are often taken to get
              a more useful set of features. Features generated using this technique
              are usually called Haralick features, after R. M. Haralick, attributed to
              his paper Textural features for image classification (1973).</para>
              
            <para>
              This class can extract <see cref="T:Accord.Imaging.HaralickDescriptor"/>s from different
              regions of an image using a pre-defined cell size. For more information
              about which features are computed, please see documentation for the
              <see cref="T:Accord.Imaging.HaralickDescriptor"/> class.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Wikipedia Contributors, "Co-occurrence matrix". Available at
                  http://en.wikipedia.org/wiki/Co-occurrence_matrix </description></item>
                <item><description>
                  Robert M Haralick, K Shanmugam, Its'hak Dinstein; "Textural 
                  Features for Image Classification". IEEE Transactions on Systems, Man,
                  and Cybernetics. SMC-3 (6): 610â621, 1973. Available at:
                  <a href="http://www.makseq.com/materials/lib/Articles-Books/Filters/Texture/Co-occurrence/haralick73.pdf">
                  http://www.makseq.com/materials/lib/Articles-Books/Filters/Texture/Co-occurrence/haralick73.pdf </a>
                  </description></item>
              </list></para>
            </remarks>
            
            <example>
            <para>
              The first example shows how to extract Haralick descriptors given an image.</para>
              <code source="Unit Tests\Accord.Tests.Imaging\HaralickTest.cs" region="doc_apply" />
              <para><b>Input image:</b></para>
              <img src="..\images\imaging\wood_texture.jpg" width="320" height="240" />
              
            <para>
              The second example shows how to use the Haralick feature extractor as part of a
              Bag-of-Words model in order to perform texture image classification:</para>
              <code source="Unit Tests\Accord.Tests.Vision\Imaging\BagOfVisualWordsTest.cs" region="doc_feature_haralick" />
              <code source="Unit Tests\Accord.Tests.Vision\Imaging\BagOfVisualWordsTest.cs" region="doc_classification_feature_haralick" />
            </example>
            
            <seealso cref="T:Accord.Imaging.HaralickDescriptor"/>
            <seealso cref="T:Accord.Imaging.GrayLevelCooccurrenceMatrix"/>
            <seealso cref="T:Accord.Imaging.SpeededUpRobustFeaturesDetector"/>
            <seealso cref="T:Accord.Imaging.HarrisCornersDetector"/>
            
        </member>
        <member name="P:Accord.Imaging.Haralick.CellSize">
            <summary>
              Gets the size of a cell, in pixels. A value of 0 means the 
              cell will have the size of the image. Default is 0 (uses the 
              entire image).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Haralick.Degrees">
            <summary>
              Gets the <see cref="T:Accord.Imaging.CooccurrenceDegree"/>s which should
              be computed by this Haralick textural feature extractor.
              Default is <see cref="F:Accord.Imaging.HaralickMode.NormalizedAverage"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Haralick.Mode">
            <summary>
              Gets or sets the mode of operation of this
              <see cref="T:Accord.Imaging.Haralick">Haralick's textural 
              feature extractor</see>. 
            </summary>
            
            <remarks>
              The mode determines how the different features captured
              by the <see cref="T:Accord.Imaging.HaralickDescriptor"/> are combined.
             </remarks>
             
            <value>
              A value from the <see cref="T:Accord.Imaging.HaralickMode"/> enumeration
              specifying how the different features should be combined.
            </value>
            
        </member>
        <member name="P:Accord.Imaging.Haralick.Features">
            <summary>
              Gets or sets the number of features to extract using
              the <see cref="T:Accord.Imaging.HaralickDescriptor"/>. By default, only
              the first 13 original Haralick's features will be used.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Haralick.Descriptors">
            <summary>
              Gets the set of local binary patterns computed for each
              cell in the last call to <see cref="M:Accord.Imaging.BaseFeatureExtractor`1.ProcessImage(System.Drawing.Bitmap)"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Haralick.Matrix">
            <summary>
              Gets the <see cref="T:Accord.Imaging.GrayLevelCooccurrenceMatrix">Gray-level
              Co-occurrence Matrix (GLCM)</see> generated during the last
              call to <see cref="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(Accord.Imaging.UnmanagedImage)"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Haralick.Normalize">
            <summary>
              Gets or sets whether to normalize final 
              histogram feature vectors. Default is false.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Haralick.#ctor(Accord.Imaging.CooccurrenceDegree[])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Haralick"/> class.
            </summary>
            
            <param name="degrees">
              The angulation degrees on which the <see cref="T:Accord.Imaging.HaralickDescriptor">Haralick's
              features</see> should be computed. Default is to use all directions.</param>
            
        </member>
        <member name="M:Accord.Imaging.Haralick.#ctor(System.Int32,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Haralick"/> class.
            </summary>
            
            <param name="cellSize">
              The size of a computing cell, measured in pixels.
              Default is 0 (use whole image at once).</param>
            <param name="normalize">
              Whether to normalize generated 
              histograms. Default is false.</param>
            
        </member>
        <member name="M:Accord.Imaging.Haralick.#ctor(System.Int32,System.Boolean,Accord.Imaging.CooccurrenceDegree[])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Haralick"/> class.
            </summary>
            
            <param name="cellSize">
              The size of a computing cell, measured in pixels.
              Default is 0 (use whole image at once).</param>
            <param name="normalize">
              Whether to normalize generated 
              histograms. Default is true.</param>
            <param name="degrees">
              The angulation degrees on which the <see cref="T:Accord.Imaging.HaralickDescriptor">Haralick's
              features</see> should be computed. Default is to use all directions.</param>
            
        </member>
        <member name="M:Accord.Imaging.Haralick.InnerTransform(Accord.Imaging.UnmanagedImage)">
            <summary>
              This method should be implemented by inheriting classes to implement the 
              actual feature extraction, transforming the input image into a list of features.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Haralick.Clone(Accord.Compat.ISet{System.Drawing.Imaging.PixelFormat})">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.HaralickDescriptor">
            <summary>
              Haralick's Texture Features.
            </summary>
            
            <remarks>
            <para>
              Haralick's texture features are based on measures derived from
              <see cref="T:Accord.Imaging.GrayLevelCooccurrenceMatrix">Gray-level Co-occurrence 
              matrices (GLCM)</see>.</para>
            <para>
              Whether considering the intensity or grayscale values of the image 
              or various dimensions of color, the co-occurrence matrix can measure
              the texture of the image. Because co-occurrence matrices are typically
              large and sparse, various metrics of the matrix are often taken to get
              a more useful set of features. Features generated using this technique
              are usually called Haralick features, after R. M. Haralick, attributed to
              his paper Textural features for image classification (1973).</para>
              
            <para>
              This class encompasses most of the features derived on Haralick's original
              paper. All features are lazy-evaluated until needed; but may also be
              combined in a single feature vector by calling <see cref="M:Accord.Imaging.HaralickDescriptor.GetVector(System.Int32)"/>.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Wikipedia Contributors, "Co-occurrence matrix". Available at
                  http://en.wikipedia.org/wiki/Co-occurrence_matrix </description></item>
                <item><description>
                  Robert M Haralick, K Shanmugam, Its'hak Dinstein; "Textural 
                  Features for Image Classification". IEEE Transactions on Systems, Man,
                  and Cybernetics. SMC-3 (6): 610â621, 1973. Available at:
                  <a href="http://www.makseq.com/materials/lib/Articles-Books/Filters/Texture/Co-occurrence/haralick73.pdf">
                  http://www.makseq.com/materials/lib/Articles-Books/Filters/Texture/Co-occurrence/haralick73.pdf </a>
                  </description></item>
              </list></para>
            </remarks>
            
            <example>
            <para>
              For a complete example on how to use <see cref="T:Accord.Imaging.Haralick"/>, please refer to
              the <see cref="T:Accord.Imaging.Haralick">documentation of the main Haralick class</see>.</para>
            </example>
            
            <seealso cref="T:Accord.Imaging.GrayLevelCooccurrenceMatrix"/>
            <seealso cref="T:Accord.Imaging.Haralick"/>
            
        </member>
        <member name="M:Accord.Imaging.HaralickDescriptor.#ctor(System.Double[0:,0:])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.HaralickDescriptor"/> class.
            </summary>
            
            <param name="cooccurrenceMatrix">The co-occurrence matrix to compute features from.</param>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.GrayLevels">
            <summary>
              Gets the number of gray levels in the 
              original image. This is the number of
              dimensions of the co-occurrence matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.Sum">
            <summary>
              Gets the matrix sum.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.Mean">
            <summary>
              Gets the matrix mean Î¼.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.RowMarginal">
            <summary>
              Gets the marginal probability vector
              obtained by summing the rows of p(i,j),
              given as p<sub>x</sub>(i) = Î£<sub>j</sub> p(i,j).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.ColumnMarginal">
            <summary>
              Gets the marginal probability vector
              obtained by summing the columns of p(i,j),
              given as p<sub>y</sub>(j) = Î£<sub>i</sub> p(i,j).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.RowMean">
            <summary>
              Gets Î¼<sub>x</sub>, the mean value of the 
              <see cref="P:Accord.Imaging.HaralickDescriptor.RowMarginal"/> vector.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.ColumnMean">
            <summary>
              Gets Î¼_y, the mean value of the 
              <see cref="P:Accord.Imaging.HaralickDescriptor.ColumnMarginal"/> vector.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.RowStandardDeviation">
            <summary>
              Gets Ï<sub>x</sub>, the variance of the 
              <see cref="P:Accord.Imaging.HaralickDescriptor.RowMarginal"/> vector.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.ColumnStandardDeviation">
            <summary>
              Gets Ï<sub>y</sub>, the variance of the 
              <see cref="P:Accord.Imaging.HaralickDescriptor.ColumnMarginal"/> vector.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.RowEntropy">
            <summary>
              Gets H<sub>x</sub>, the entropy of the 
              <see cref="P:Accord.Imaging.HaralickDescriptor.RowMarginal"/> vector.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.ColumnEntropy">
            <summary>
              Gets H<sub>y</sub>, the entropy of the 
              <see cref="P:Accord.Imaging.HaralickDescriptor.ColumnMarginal"/> vector.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.Sums">
            <summary>
              Gets p<sub>(x+y)</sub>(k), the sum 
              of elements whose indices sum to k.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.Differences">
            <summary>
              Gets p<sub>(x-y)</sub> (k), the sum of elements 
              whose absolute indices diferences equals to k.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F01">
            <summary>
              Gets Haralick's first textural feature,
              the Angular Second Momentum.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F02">
            <summary>
              Gets Haralick's second textural feature,
              the Contrast.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F03">
            <summary>
              Gets Haralick's third textural feature,
              the Correlation.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F04">
            <summary>
              Gets Haralick's fourth textural feature,
              the Sum of Squares: Variance.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F05">
             <summary>
               Gets Haralick's fifth textural feature,
               the Inverse Difference Moment.
             </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F06">
            <summary>
              Gets Haralick's sixth textural feature,
              the Sum Average.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F07">
            <summary>
              Gets Haralick's seventh textural feature,
              the Sum Variance.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F08">
            <summary>
              Gets Haralick's eighth textural feature,
              the Sum Entropy.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F09">
            <summary>
              Gets Haralick's ninth textural feature,
              the Entropy.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F10">
            <summary>
              Gets Haralick's tenth textural feature,
              the Difference Variance.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F11">
            <summary>
              Gets Haralick's eleventh textural feature,
              the Difference Entropy.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F12">
            <summary>
              Gets Haralick's twelfth textural feature,
              the First Information Measure.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F13">
            <summary>
              Gets Haralick's thirteenth textural feature,
              the Second Information Measure.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.F14">
            <summary>
              Gets Haralick's fourteenth textural feature,
              the Maximal Correlation Coefficient.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.AngularSecondMomentum">
            <summary>
              Gets Haralick's first textural feature, the
              Angular Second Momentum, also known as Energy
              or Homogeneity.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.LaplaceContrast">
            <summary>
              Gets a variation of Haralick's second textural feature,
              the Contrast with Absolute values (instead of squares).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.Contrast">
            <summary>
              Gets Haralick's second textural feature,
              the Contrast.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.Correlation">
            <summary>
              Gets Haralick's third textural feature,
              the Correlation.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.SumOfSquares">
            <summary>
              Gets Haralick's fourth textural feature,
              the Sum of Squares: Variance.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.InverseDifferenceMoment">
             <summary>
               Gets Haralick's fifth textural feature, the Inverse
               Difference Moment, also known as Local Homogeneity.
               Can be regarded as a complement to <see cref="P:Accord.Imaging.HaralickDescriptor.Contrast"/>.
             </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.TextureHomogeneity">
            <summary>
              Gets a variation of Haralick's fifth textural feature,
              the Texture Homogeneity. Can be regarded as a complement
              to <see cref="P:Accord.Imaging.HaralickDescriptor.LaplaceContrast"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.SumAverage">
            <summary>
              Gets Haralick's sixth textural feature,
              the Sum Average.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.SumVariance">
            <summary>
              Gets Haralick's seventh textural feature,
              the Sum Variance.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.SumEntropy">
            <summary>
              Gets Haralick's eighth textural feature,
              the Sum Entropy.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.Entropy">
            <summary>
              Gets Haralick's ninth textural feature,
              the Entropy.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.DifferenceVariance">
            <summary>
              Gets Haralick's tenth textural feature,
              the Difference Variance.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.DifferenceEntropy">
            <summary>
              Gets Haralick's eleventh textural feature,
              the Difference Entropy.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.FirstInformationMeasure">
            <summary>
              Gets Haralick's twelfth textural feature,
              the First Information Measure.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.SecondInformationMeasure">
            <summary>
              Gets Haralick's thirteenth textural feature,
              the Second Information Measure.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.MaximalCorrelationCoefficient">
            <summary>
              Gets Haralick's fourteenth textural feature,
              the Maximal Correlation Coefficient.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.ClusterShade">
            <summary>
              Gets the Cluster Shade textural feature.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HaralickDescriptor.ClusterProminence">
            <summary>
              Gets the Cluster Prominence textural feature.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.HaralickDescriptor.GetVector(System.Int32)">
            <summary>
              Creates a feature vector with 
              the chosen feature functions.
            </summary>
            
            <param name="features">How many features to include in the vector. Default is 13.</param>
            
            <returns>A vector with Haralick's features up 
            to the given number passed as input.</returns>
            
        </member>
        <member name="T:Accord.Imaging.LocalBinaryPattern">
            <summary>
              Local Binary Patterns.
            </summary>
            
            <remarks>
            <para>
               Local binary patterns (LBP) is a type of feature used for classification
               in computer vision. LBP is the particular case of the Texture Spectrum 
               model proposed in 1990. LBP was first described in 1994. It has since 
               been found to be a powerful feature for texture classification; it has
               further been determined that when LBP is combined with the Histogram of
               oriented gradients (HOG) classifier, it improves the detection performance
               considerably on some datasets. </para>
            
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Wikipedia Contributors, "Local Binary Patterns". Available at
                  http://en.wikipedia.org/wiki/Local_binary_patterns </description></item>
              </list>
            </para>
            </remarks>
            
            <example>
            <para>
              The first example shows how to extract LBP descriptors given an image.</para>
              <code source="Unit Tests\Accord.Tests.Imaging\LocalBinaryPatternsTest.cs" region="doc_apply" />
              <para><b>Input image:</b></para>
              <img src="..\images\imaging\wood_texture.jpg" width="320" height="240" />
              
            <para>
              The second example shows how to use the LBP feature extractor as part of a
              Bag-of-Words model in order to perform texture image classification:</para>
              <code source="Unit Tests\Accord.Tests.Vision\Imaging\BagOfVisualWordsTest.cs" region="doc_feature_lbp" />
            </example>
            
        </member>
        <member name="P:Accord.Imaging.LocalBinaryPattern.CellSize">
            <summary>
              Gets the size of a cell, in pixels. Default is 6.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.LocalBinaryPattern.BlockSize">
            <summary>
              Gets the size of a block, in pixels. Default is 3.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.LocalBinaryPattern.Patterns">
            <summary>
              Gets the set of local binary patterns computed for each
              pixel in the last call to to <see cref="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(System.Drawing.Bitmap)"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.LocalBinaryPattern.Histograms">
            <summary>
              Gets the histogram computed at each cell.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.LocalBinaryPattern.Normalize">
            <summary>
              Gets or sets whether to normalize final 
              histogram feature vectors. Default is true.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.LocalBinaryPattern.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.LocalBinaryPattern"/> class.
            </summary>
            
            <param name="blockSize">
              The size of a block, measured in cells. Default is 3.</param>
            <param name="cellSize">
              The size of a cell, measured in pixels. If set to zero, the entire
              image will be used at once, forming a single block. Default is 6.</param>
            <param name="normalize">
              Whether to normalize generated histograms. Default is true.</param>
            
        </member>
        <member name="M:Accord.Imaging.LocalBinaryPattern.InnerTransform(Accord.Imaging.UnmanagedImage)">
            <summary>
              This method should be implemented by inheriting classes to implement the 
              actual feature extraction, transforming the input image into a list of features.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.LocalBinaryPattern.Clone(Accord.Compat.ISet{System.Drawing.Imaging.PixelFormat})">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.FastRetinaKeypointDescriptorType">
            <summary>
              SURF Feature descriptor types.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.FastRetinaKeypointDescriptorType.None">
            <summary>
              Do not compute descriptors.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.FastRetinaKeypointDescriptorType.Standard">
            <summary>
              Compute standard 512-bit descriptors.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.FastRetinaKeypointDescriptorType.Extended">
            <summary>
              Compute extended 1024-bit descriptors.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.FastRetinaKeypointDetector">
            <summary>
              Fast Retina Keypoint (FREAK) detector.
            </summary>
            
            <remarks>
              The FREAK algorithm is a binary based interest point descriptor algorithm
              that relies in another corner 
            </remarks>
            
            <example>
            <para>
              In the following example, we will see how can we extract binary descriptor
              vectors from a given image using the Fast Retina Keypoint Detector together
              a FAST corners detection algorithm.</para>
            
            <code>
            Bitmap lena = Resources.lena512;
            
            // The freak detector can be used with any other corners detection
            // algorithm. The default corners detection method used is the FAST
            // corners detection. So, let's start creating this detector first:
            //
            var detector = new FastCornersDetector(60);
            
            // Now that we have a corners detector, we can pass it to the FREAK
            // feature extraction algorithm. Please note that if we leave this
            // parameter empty, FAST will be used by default.
            //
            var freak = new FastRetinaKeypointDetector(detector);
            
            // Now, all we have to do is to process our image:
            List&lt;FastRetinaKeypoint> points = freak.ProcessImage(lena);
            
            // Afterwards, we should obtain 83 feature points. We can inspect
            // the feature points visually using the FeaturesMarker class as
            //
            FeaturesMarker marker = new FeaturesMarker(points, scale: 20);
                        
            // And showing it on screen with
            ImageBox.Show(marker.Apply(lena));
            
            // We can also inspect the feature vectors (descriptors) associated
            // with each feature point. In order to get a descriptor vector for
            // any given point, we can use
            //
            byte[] feature = points[42].Descriptor;
                        
            // By default, feature vectors will have 64 bytes in length. We can also
            // display those vectors in more readable formats such as HEX or base64
            //
            string hex = points[42].ToHex();
            string b64 = points[42].ToBase64();
            
            // The above base64 result should be:
            //
            //  "3W8M/ev///ffbr/+v3f34vz//7X+f0609v//+++/1+jfq/e83/X5/+6ft3//b4uaPZf7ePb3n/P93/rIbZlf+g=="
            //
            </code>
            
            <para>
              The resulting image is shown below:</para>
            
              <img src="..\images\freak.png" />
              
            </example>
            
            <seealso cref="T:Accord.Imaging.FastCornersDetector"/>
            <seealso cref="T:Accord.Imaging.HistogramsOfOrientedGradients"/>
            <seealso cref="T:Accord.Imaging.LocalBinaryPattern"/>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypointDetector.Detector">
            <summary>
              Gets the corners detector used to generate features.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypointDetector.ComputeDescriptors">
            <summary>
              Gets or sets a value indicating whether all feature points
              should have their descriptors computed after being detected.
              Default is to compute standard descriptors.
            </summary>
            
            <value><c>true</c> if to compute orientation; otherwise, <c>false</c>.</value>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypointDetector.Octaves">
            <summary>
              Gets or sets the number of octaves to use when 
              building the feature descriptor. Default is 4.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypointDetector.Scale">
            <summary>
              Gets or sets the scale used when building 
              the feature descriptor. Default is 22.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypointDetector.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.FastRetinaKeypointDetector"/> class.
            </summary>
            
            <param name="threshold">The detection threshold for the 
            <see cref="T:Accord.Imaging.FastCornersDetector">FAST detector</see>.</param>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypointDetector.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.FastRetinaKeypointDetector"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypointDetector.#ctor(Accord.Imaging.ICornersDetector)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.FastRetinaKeypointDetector"/> class.
            </summary>
            
            <param name="detector">A corners detector.</param>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypointDetector.InnerTransform(Accord.Imaging.UnmanagedImage)">
            <summary>
              This method should be implemented by inheriting classes to implement the 
              actual feature extraction, transforming the input image into a list of features.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypointDetector.GetDescriptor">
            <summary>
              Gets the <see cref="T:Accord.Imaging.FastRetinaKeypointDescriptor">
              feature descriptor</see> for the last processed image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypointDetector.Clone(Accord.Compat.ISet{System.Drawing.Imaging.PixelFormat})">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.FastRetinaKeypoint">
            <summary>
              Fast Retina Keypoint (FREAK) point.
            </summary>
            
            <remarks>
              In order to extract feature points from an image using FREAK,
              please take a look on the <see cref="T:Accord.Imaging.FastRetinaKeypointDetector"/>
              documentation page.
            </remarks>
            
            <seealso cref="T:Accord.Imaging.FastRetinaKeypointDescriptor"/>
            <seealso cref="T:Accord.Imaging.FastRetinaKeypointDetector"/>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypoint.#ctor(System.Double,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.FastRetinaKeypoint"/> class.
            </summary>
            
            <param name="x">The x-coordinate of the point in the image.</param>
            <param name="y">The y-coordinate of the point in the image.</param>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypoint.X">
            <summary>
              Gets or sets the x-coordinate of this point.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypoint.Y">
            <summary>
              Gets or sets the y-coordinate of this point.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypoint.Scale">
            <summary>
              Gets or sets the scale of the point.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypoint.Orientation">
            <summary>
              Gets or sets the orientation of this point in angles.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypoint.Descriptor">
            <summary>
              Gets or sets the descriptor vector
              associated with this point.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypoint.ToHex">
            <summary>
              Converts the binary descriptor to 
              string of hexadecimal values.
            </summary>
            
            <returns>A string containing an hexadecimal
            value representing this point's descriptor.</returns>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypoint.ToBinary">
            <summary>
              Converts the binary descriptor
              to a string of binary values.
            </summary>
            
            <returns>A string containing a binary value
            representing this point's descriptor.</returns>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypoint.ToBase64">
            <summary>
              Converts the binary descriptor to base64.
            </summary>
            
            <returns>A string containing the base64 
            representation of the descriptor.</returns>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypoint.ToIntPoint">
            <summary>
              Converts the feature point to a <see cref="T:Accord.IntPoint"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypoint.ToPoint">
            <summary>
              Converts this object into a <see cref="T:Accord.IntPoint"/>.
            </summary>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypoint.ToPointF">
            <summary>
              Converts this object into a <see cref="T:System.Drawing.PointF"/>.
            </summary>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypoint.op_Implicit(Accord.Imaging.FastRetinaKeypoint)~System.Drawing.Point">
            <summary>
              Performs an implicit conversion from <see cref="T:Accord.Imaging.FastRetinaKeypoint"/>
              to <see cref="T:System.Drawing.Point"/>.
            </summary>
            
            <param name="point">The point to be converted.</param>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypoint.op_Implicit(Accord.Imaging.FastRetinaKeypoint)~System.Drawing.PointF">
            <summary>
              Performs an implicit conversion from <see cref="T:Accord.Imaging.FastRetinaKeypoint"/>
              to <see cref="T:System.Drawing.PointF"/>.
            </summary>
            
            <param name="point">The point to be converted.</param>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypoint.op_Implicit(Accord.Imaging.FastRetinaKeypoint)~Accord.IntPoint">
            <summary>
              Performs an implicit conversion from <see cref="T:Accord.Imaging.FastRetinaKeypoint"/>
              to <see cref="T:Accord.IntPoint"/>.
            </summary>
            
            <param name="point">The point to be converted.</param>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="T:Accord.Imaging.FastRetinaKeypointDescriptor">
             <summary>
               Fast Retina Keypoint (FREAK) descriptor.
             </summary>
             
             <remarks>
             <para>
               Based on original implementation by A. Alahi, R. Ortiz, and P. 
               Vandergheynst, distributed under a BSD style license.</para>
               
             <para>
               In order to extract feature points from an image using FREAK,
               please take a look on the <see cref="T:Accord.Imaging.FastRetinaKeypointDetector"/>
               documentation page.
             </para>
             <para>
               References:
               <list type="bullet">
                 <item><description>
                   A. Alahi, R. Ortiz, and P. Vandergheynst. FREAK: Fast Retina Keypoint. In IEEE Conference on 
                   Computer Vision and Pattern Recognition, CVPR 2012 Open Source Award Winner.</description></item>
               </list>
             </para>
             </remarks>
            
             <seealso cref="T:Accord.Imaging.FastRetinaKeypoint"/>
             <seealso cref="T:Accord.Imaging.FastRetinaKeypointDetector"/>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypointDescriptor.IsOrientationNormal">
            <summary>
              Gets or sets whether the orientation is normalized.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypointDescriptor.IsScaleNormal">
            <summary>
              Gets or sets whether the scale is normalized.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypointDescriptor.Extended">
            <summary>
              Gets or sets whether to compute the standard 512-bit 
              descriptors or extended 1024-bit 
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypointDescriptor.Image">
            <summary>
              Gets the <see cref="T:Accord.Imaging.UnmanagedImage"/> of
              the original source's feature detector.
            </summary>
            
            <value>The integral image from where the
            features have been detected.</value>
            
        </member>
        <member name="P:Accord.Imaging.FastRetinaKeypointDescriptor.Integral">
            <summary>
              Gets the <see cref="T:Accord.Imaging.IntegralImage"/> of
              the original source's feature detector.
            </summary>
            
            <value>The integral image from where the
            features have been detected.</value>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypointDescriptor.#ctor(Accord.Imaging.UnmanagedImage,Accord.Imaging.IntegralImage,Accord.Imaging.FastRetinaKeypointPattern)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.FastRetinaKeypointDescriptor"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypointDescriptor.Compute(System.Collections.Generic.IList{Accord.Imaging.FastRetinaKeypoint})">
            <summary>
              Describes the specified point (i.e. computes and
              sets the orientation and descriptor vector fields
              of the <see cref="T:Accord.Imaging.FastRetinaKeypoint"/>.
            </summary>
            
            <param name="points">The point to be described.</param>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypointDescriptor.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="F:Accord.Imaging.FastRetinaKeypointPattern.Scales">
            <summary>
              Pattern scale resolution.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.FastRetinaKeypointPattern.Orientations">
            <summary>
              Pattern orientation resolution.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.FastRetinaKeypointPattern.Points">
            <summary>
              Number of pattern points.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.FastRetinaKeypointPattern.Size">
            <summary>
              Smallest keypoint size.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.FastRetinaKeypointPattern.lookupTable">
            <summary>
              Look-up table for the pattern points (position + 
              sigma of all points at all scales and orientation)
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FastRetinaKeypointPattern.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="T:Accord.Imaging.HistogramsOfOrientedGradients">
            <summary>
              Histograms of Oriented Gradients (HOG) descriptor extractor.
            </summary>
            
            <remarks>
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Navneet Dalal and Bill Triggs, "Histograms of Oriented Gradients for Human Detection",
                  CVPR 2005. Available at: <a href="http://lear.inrialpes.fr/people/triggs/pubs/Dalal-cvpr05.pdf">
                  http://lear.inrialpes.fr/people/triggs/pubs/Dalal-cvpr05.pdf </a> </description></item>
              </list></para>
            </remarks>
            
            <example>
            <para>
              The first example shows how to extract HOG descriptors from a standard test image:</para>
              <code source="Unit Tests\Accord.Tests.Imaging\HistogramsOfOrientedGradientsTest.cs" region="doc_apply" />
              
            <para>
              The second example shows how to use HOG descriptors as part of a BagOfVisualWords (BoW) pipeline 
              for image classification:</para>
              <code source="Unit Tests\Accord.Tests.Vision\Imaging\BagOfVisualWordsTest.cs" region="doc_feature_lbp" />
              <code source="Unit Tests\Accord.Tests.Vision\Imaging\BagOfVisualWordsTest.cs" region="doc_classification_feature_lbp" />
            </example>
            
        </member>
        <member name="P:Accord.Imaging.HistogramsOfOrientedGradients.CellSize">
            <summary>
              Gets the size of a cell, in pixels. Default is 6.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HistogramsOfOrientedGradients.BlockSize">
            <summary>
              Gets the size of a block, in pixels. Default is 3.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HistogramsOfOrientedGradients.NumberOfBins">
            <summary>
              Gets the number of histogram bins. Default is 9.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HistogramsOfOrientedGradients.BinWidth">
            <summary>
              Gets the width of the histogram bin. This property is 
              computed as <c>(2.0 * System.Math.PI) / numberOfBins</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HistogramsOfOrientedGradients.Direction">
            <summary>
              Gets the matrix of orientations generated in 
              the last call to <see cref="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(System.Drawing.Bitmap)"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HistogramsOfOrientedGradients.Magnitude">
            <summary>
              Gets the matrix of magnitudes generated in 
              the last call to <see cref="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(System.Drawing.Bitmap)"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HistogramsOfOrientedGradients.Histograms">
            <summary>
              Gets the histogram computed at each cell.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HistogramsOfOrientedGradients.Normalize">
            <summary>
              Gets or sets whether to normalize final 
              histogram feature vectors. Default is true.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.HistogramsOfOrientedGradients.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.HistogramsOfOrientedGradients"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.HistogramsOfOrientedGradients.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.HistogramsOfOrientedGradients"/> class.
            </summary>
            
            <param name="numberOfBins">The number of histogram bins.</param>
            <param name="blockSize">The size of a block, measured in cells.</param>
            <param name="cellSize">The size of a cell, measured in pixels.</param>
            
        </member>
        <member name="M:Accord.Imaging.HistogramsOfOrientedGradients.InnerTransform(Accord.Imaging.UnmanagedImage)">
            <summary>
              This method should be implemented by inheriting classes to implement the 
              actual feature extraction, transforming the input image into a list of features.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.HistogramsOfOrientedGradients.Clone(Accord.Compat.ISet{System.Drawing.Imaging.PixelFormat})">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.ResponseLayerCollection">
            <summary>
              Response filter.
            </summary>
            
            <remarks>
            <para>
              In SURF, the scale-space is divided into a number of octaves,
              where an octave refers to a series of <see cref="T:Accord.Imaging.ResponseLayer"/>
              response maps covering a doubling of scale.</para>
            <para>
              In the traditional approach to constructing a scale-space,
              the image size is varied and the Gaussian filter is repeatedly
              applied to smooth subsequent layers. The SURF approach leaves
              the original image unchanged and varies only the filter size.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.ResponseLayerCollection.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Creates the initial map of responses according to
              the specified number of octaves and initial step.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ResponseLayerCollection.Update(System.Int32,System.Int32,System.Int32)">
            <summary>
              Updates the response filter definitions
              without recreating objects.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ResponseLayerCollection.Compute(Accord.Imaging.IntegralImage)">
            <summary>
              Computes the filter using the specified <see cref="T:Accord.Imaging.IntegralImage">
              Integral Image.</see>
            </summary>
            
            <param name="integral">The integral image.</param>
            
        </member>
        <member name="M:Accord.Imaging.ResponseLayerCollection.GetEnumerator">
            <summary>
              Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
              A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.ResponseLayerCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
              Returns an enumerator that iterates through this collection.
            </summary>
            <returns>
              An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            
        </member>
        <member name="T:Accord.Imaging.ResponseLayer">
            <summary>
              Response Layer.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ResponseLayer.Width">
            <summary>
              Gets the width of the filter.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ResponseLayer.Height">
            <summary>
              Gets the height of the filter.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ResponseLayer.Step">
            <summary>
              Gets the filter step.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ResponseLayer.Size">
            <summary>
              Gets the filter size.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ResponseLayer.Responses">
            <summary>
              Gets the responses computed from the filter.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.ResponseLayer.Laplacian">
            <summary>
              Gets the Laplacian computed from the filter.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ResponseLayer.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.ResponseLayer"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ResponseLayer.Update(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Updates the response layer definitions
              without recreating objects.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.ResponseLayer.Compute(Accord.Imaging.IntegralImage)">
            <summary>
              Computes the filter for the specified integral image.
            </summary>
            
            <param name="image">The integral image.</param>
            
        </member>
        <member name="T:Accord.Imaging.CornerFeaturePoint">
            <summary>
              Corner feature point.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.CornerFeaturePoint.#ctor(Accord.IntPoint)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.CornerFeaturePoint"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.CornerFeaturePoint.X">
            <summary>
              Gets the X position of the point.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.CornerFeaturePoint.Y">
            <summary>
              Gets the Y position of the point.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.CornerFeaturePoint.Descriptor">
            <summary>
              Gets the descriptor vector
              associated with this point.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.CornerFeaturesDetector">
            <summary>
              Feature detector based on corners.
            </summary>
            
            <remarks>
              This class can be used as an adapter for classes implementing
              AForge.NET's ICornersDetector interface, so they can be used
              where an <see cref="T:Accord.Imaging.IImageFeatureExtractor`1"/> is needed.
            </remarks>
            
            <example>
              For an example on how to use this class, please take a look
              on the example section for <c>BagOfVisualWords{T}</c>.
            </example>
            
        </member>
        <member name="P:Accord.Imaging.CornerFeaturesDetector.Detector">
            <summary>
              Gets the corners detector used to generate features.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.CornerFeaturesDetector.#ctor(Accord.Imaging.ICornersDetector)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.CornerFeaturesDetector"/> class.
            </summary>
            
            <param name="detector">A corners detector.</param>
            
        </member>
        <member name="M:Accord.Imaging.CornerFeaturesDetector.InnerTransform(Accord.Imaging.UnmanagedImage)">
            <summary>
            This method should be implemented by inheriting classes to implement the
            actual corners detection, transforming the input image into a list of points.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.CornerFeaturesDetector.Clone(Accord.Compat.ISet{System.Drawing.Imaging.PixelFormat})">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.CornerFeaturesDetector.Dispose(System.Boolean)">
            <summary>
              Releases unmanaged and - optionally - managed resources.
            </summary>
            
            <param name="disposing"><c>true</c> to release both managed and unmanaged
              resources; <c>false</c> to release only unmanaged resources.</param>
            
        </member>
        <member name="T:Accord.Imaging.IImageFeatureExtractor`1">
            <summary>
              Common interface for feature detectors (e.g. <see cref="T:Accord.Imaging.SpeededUpRobustFeaturesDetector"/>,
              <see cref="T:Accord.Imaging.Haralick"/>, <see cref="T:Accord.Imaging.HistogramsOfOrientedGradients"/>).
            </summary>
            
            <typeparam name="TFeature">The type of the extracted features (e.g. <see cref="T:Accord.Imaging.SpeededUpRobustFeaturePoint"/>, <see cref="T:Accord.Imaging.FastRetinaKeypoint"/>]).</typeparam>
            
            <seealso cref="T:Accord.Imaging.SpeededUpRobustFeaturesDetector"/>
            <seealso cref="T:Accord.Imaging.HistogramsOfOrientedGradients"/>
            <seealso cref="T:Accord.Imaging.Haralick"/>
            <seealso cref="T:Accord.Imaging.LocalBinaryPattern"/>
            
        </member>
        <member name="T:Accord.Imaging.IFeatureDetector`1">
            <summary>
              Obsolete. See <see cref="T:Accord.Imaging.IImageFeatureExtractor`1"/> instead.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.IFeatureDetector`1.ProcessImage(System.Drawing.Bitmap)">
            <summary>
              Obsolete. Please use the <see cref="M:Accord.MachineLearning.ICovariantTransform`2.Transform(`0)"/> method instead.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.IFeatureDetector`1.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
              Obsolete. Please use the <see cref="M:Accord.MachineLearning.ICovariantTransform`2.Transform(`0)"/> method instead.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.IFeatureDetector`1.ProcessImage(Accord.Imaging.UnmanagedImage)">
            <summary>
              Obsolete. Please use the <see cref="M:Accord.MachineLearning.ICovariantTransform`2.Transform(`0)"/> method instead.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.Moments.HuMoments">
             <summary>
               Hu's set of invariant image moments.
             </summary>
             
             <remarks>
             <para>
               In image processing, computer vision and related fields, an image moment is
               a certain particular weighted average (moment) of the image pixels' intensities,
               or a function of such moments, usually chosen to have some attractive property 
               or interpretation.</para>
            
             <para>
               Image moments are useful to describe objects after segmentation. Simple properties 
               of the image which are found via image moments include area (or total intensity), 
               its centroid, and information about its orientation.</para>
               
             <para>
               Hu's set of invariant moments are invariant under translation, changes in scale, 
               and also rotation. The first moment, <see cref="P:Accord.Imaging.Moments.HuMoments.I1"/>, is analogous to the moment 
               of inertia around the image's centroid, where the pixels' intensities are analogous
               to physical density. The last one, I7, is skew invariant, which enables it to distinguish
               mirror images of otherwise identical images.</para>
               
             <para>
               References:
               <list type="bullet">
                 <item><description>
                   Wikipedia contributors. "Image moment." Wikipedia, The Free Encyclopedia. Wikipedia,
                   The Free Encyclopedia. Available at http://en.wikipedia.org/wiki/Image_moment </description></item>
               </list>
             </para>
             </remarks>
             
             <example>
             <code>
             Bitmap image = ...;
            
             // Compute the Hu moments of up to third order
             HuMoments hu = new HuMoments(image, order: 3);
             </code>
             </example>
             
             <seealso cref="T:Accord.Imaging.Moments.RawMoments"/>
             <seealso cref="T:Accord.Imaging.Moments.CentralMoments"/>
             
        </member>
        <member name="P:Accord.Imaging.Moments.HuMoments.I1">
            <summary>
              Hu moment of order 1.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.HuMoments.I2">
            <summary>
              Hu moment of order 2.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.HuMoments.I3">
            <summary>
              Hu moment of order 3.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.HuMoments.I4">
            <summary>
              Hu moment of order 4.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.HuMoments.I5">
            <summary>
              Hu moment of order 5.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.HuMoments.I6">
            <summary>
              Hu moment of order 6.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.HuMoments.I7">
            <summary>
              Hu moment of order 7.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Moments.HuMoments.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.HuMoments"/> class.
            </summary>
            
            <param name="order">The maximum moment order to be computed.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.HuMoments.#ctor(System.Drawing.Bitmap,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.HuMoments"/> class.
            </summary>
            
            <param name="order">The maximum moment order to be computed.</param>
            <param name="image">The image whose moments should be computed.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.HuMoments.#ctor(System.Single[0:,0:],System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.HuMoments"/> class.
            </summary>
            
            <param name="order">The maximum order for the moments.</param>
            <param name="image">The image whose moments should be computed.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.HuMoments.Compute(Accord.Imaging.Moments.CentralMoments)">
            <summary>
              Computes the Hu moments from the specified central moments.
            </summary>
            
            <param name="moments">The central moments to use as base of calculations.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.HuMoments.Compute(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
              Computes the center moments for the specified image.
            </summary>
            
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.HuMoments.Compute(System.Single[0:,0:],System.Drawing.Rectangle)">
            <summary>
              Computes the center moments for the specified image.
            </summary>
            
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="T:Accord.Imaging.Moments.MomentsBase">
            <summary>
              Base class for image moments.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.MomentsBase.Order">
            <summary>
              Gets or sets the maximum order of the moments.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.#ctor(System.Int32)">
             <summary>
               Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.MomentsBase"/> class.
             </summary>
             
             <param name="order">The maximum order for the moments.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.#ctor(System.Drawing.Bitmap,System.Drawing.Rectangle,System.Int32)">
             <summary>
               Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.MomentsBase"/> class.
             </summary>
             
             <param name="order">The maximum order for the moments.</param>
             <param name="image">The image whose moments should be computed.</param>
             <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.#ctor(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.MomentsBase"/> class.
            </summary>
            
            <param name="order">The maximum order for the moments.</param>
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.#ctor(System.Single[0:,0:],System.Drawing.Rectangle,System.Int32)">
             <summary>
               Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.MomentsBase"/> class.
             </summary>
             
             <param name="order">The maximum order for the moments.</param>
             <param name="image">The image whose moments should be computed.</param>
             <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.#ctor(System.Drawing.Bitmap,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.MomentsBase"/> class.
            </summary>
            
            <param name="order">The maximum order for the moments.</param>
            <param name="image">The image whose moments should be computed.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.#ctor(Accord.Imaging.UnmanagedImage,System.Int32)">
             <summary>
               Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.MomentsBase"/> class.
             </summary>
             
             <param name="order">The maximum order for the moments.</param>
             <param name="image">The image whose moments should be computed.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.#ctor(System.Single[0:,0:],System.Int32)">
             <summary>
               Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.MomentsBase"/> class.
             </summary>
             
             <param name="order">The maximum order for the moments.</param>
             <param name="image">The image whose moments should be computed.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.Compute(System.Drawing.Bitmap)">
            <summary>
              Computes the moments for the specified image.
            </summary>
            
            <param name="image">The image whose moments should be computed.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.Compute(Accord.Imaging.UnmanagedImage)">
            <summary>
              Computes the moments for the specified image.
            </summary>
            
            <param name="image">The image whose moments should be computed.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.Compute(System.Drawing.Imaging.BitmapData)">
            <summary>
              Computes the moments for the specified image.
            </summary>
            
            <param name="image">The image whose moments should be computed.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.Compute(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
              Computes the moments for the specified image.
            </summary>
            
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.Compute(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
              Computes the moments for the specified image.
            </summary>
            
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.Compute(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
              Computes the moments for the specified image.
            </summary>
            
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.MomentsBase.Compute(System.Single[0:,0:],System.Drawing.Rectangle)">
            <summary>
              Computes the moments for the specified image.
            </summary>
            
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="T:Accord.Imaging.Moments.CentralMoments">
             <summary>
               Central image moments.
             </summary>
            
             <remarks>
             <para>
               In image processing, computer vision and related fields, an image moment is
               a certain particular weighted average (moment) of the image pixels' intensities,
               or a function of such moments, usually chosen to have some attractive property 
               or interpretation.</para>
            
             <para>
               Image moments are useful to describe objects after segmentation. Simple properties 
               of the image which are found via image moments include area (or total intensity), 
               its centroid, and information about its orientation.</para>
               
             <para>
               The central moments can be used to find the location, center of mass and the 
               dimensions of a given object within an image.</para>
               
             <para>
               References:
               <list type="bullet">
                 <item><description>
                   Wikipedia contributors. "Image moment." Wikipedia, The Free Encyclopedia. Wikipedia,
                   The Free Encyclopedia. Available at http://en.wikipedia.org/wiki/Image_moment </description></item>
               </list>
             </para>
             </remarks>
             
             <example>
             <code>
             Bitmap image = ...;
            
             // Compute the center moments of up to third order
             CentralMoments cm = new CentralMoments(image, order: 3);
             
             // Get size and orientation of the image
             SizeF size = target.GetSize();
             float angle = target.GetOrientation();
             </code>
             </example>
             
             <seealso cref="T:Accord.Imaging.Moments.RawMoments"/>
             <seealso cref="T:Accord.Imaging.Moments.HuMoments"/>
             
        </member>
        <member name="F:Accord.Imaging.Moments.CentralMoments.DefaultOrder">
            <summary>
              Gets the default maximum moment order.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.CentralMoments.Mu00">
            <summary>
              Central moment of order (0,0).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.CentralMoments.Mu10">
            <summary>
              Central moment of order (1,0).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.CentralMoments.Mu01">
            <summary>
              Central moment of order (0,1).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.CentralMoments.Mu11">
            <summary>
              Central moment of order (1,1).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.CentralMoments.Mu20">
            <summary>
              Central moment of order (2,0).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.CentralMoments.Mu02">
            <summary>
              Central moment of order (0,2).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.CentralMoments.Mu21">
            <summary>
              Central moment of order (2,1).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.CentralMoments.Mu12">
            <summary>
              Central moment of order (1,2).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.CentralMoments.Mu30">
            <summary>
              Central moment of order (3,0).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.CentralMoments.Mu03">
            <summary>
              Central moment of order (0,3).
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Moments.CentralMoments.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.CentralMoments"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Moments.CentralMoments.#ctor(Accord.Imaging.Moments.RawMoments)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.CentralMoments"/> class.
            </summary>
            
            <param name="moments">The raw moments to construct central moments.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.CentralMoments.#ctor(System.Drawing.Bitmap,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.CentralMoments"/> class.
            </summary>
            
            <param name="order">The maximum order for the moments.</param>
            <param name="image">The image whose moments should be computed.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.CentralMoments.#ctor(System.Single[0:,0:],System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.CentralMoments"/> class.
            </summary>
            
            <param name="order">The maximum order for the moments.</param>
            <param name="image">The image whose moments should be computed.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.CentralMoments.#ctor(System.Drawing.Bitmap,System.Drawing.Rectangle,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.CentralMoments"/> class.
            </summary>
            
            <param name="order">The maximum order for the moments.</param>
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.CentralMoments.#ctor(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.CentralMoments"/> class.
            </summary>
            
            <param name="order">The maximum order for the moments.</param>
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.CentralMoments.#ctor(System.Single[0:,0:],System.Drawing.Rectangle,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.Moments.CentralMoments"/> class.
            </summary>
            
            <param name="order">The maximum order for the moments.</param>
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.CentralMoments.Compute(Accord.Imaging.Moments.RawMoments)">
            <summary>
              Computes the center moments from the specified raw moments.
            </summary>
            
            <param name="moments">The raw moments to use as base of calculations.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.CentralMoments.Compute(System.Single[0:,0:],System.Drawing.Rectangle)">
            <summary>
              Computes the center moments for the specified image.
            </summary>
            
            <param name="image">The image.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.CentralMoments.Compute(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
              Computes the center moments for the specified image.
            </summary>
            
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.CentralMoments.GetSize">
            <summary>
              Gets the size of the ellipse containing the image.
            </summary>
            
            <returns>The size of the ellipse containing the image.</returns>
            
        </member>
        <member name="M:Accord.Imaging.Moments.CentralMoments.GetOrientation">
            <summary>
              Gets the orientation of the ellipse containing the image.
            </summary>
            
            <returns>The angle of orientation of the ellipse, in radians.</returns>
            
        </member>
        <member name="M:Accord.Imaging.Moments.CentralMoments.GetSizeAndOrientation(System.Single@)">
            <summary>
              Gets both size and orientation of the ellipse containing the image.
            </summary>
            
            <param name="angle">The angle of orientation of the ellipse, in radians.</param>
            <returns>The size of the ellipse containing the image.</returns>
            
        </member>
        <member name="T:Accord.Imaging.Moments.IMoments">
            <summary>
              Common interface for image moments.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Moments.IMoments.Compute(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
              Computes the center moments for the specified image.
            </summary>
            
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.IMoments.Compute(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
              Computes the center moments for the specified image.
            </summary>
            
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="T:Accord.Imaging.Moments.RawMoments">
             <summary>
               Raw image moments.
             </summary>
             
             <remarks>
             <para>
               In image processing, computer vision and related fields, an image moment is
               a certain particular weighted average (moment) of the image pixels' intensities,
               or a function of such moments, usually chosen to have some attractive property 
               or interpretation.</para>
            
             <para>
               Image moments are useful to describe objects after segmentation. Simple properties 
               of the image which are found via image moments include area (or total intensity), 
               its centroid, and information about its orientation.</para>
               
             <para>
               The raw moments are the most basic moments which can be computed from an image,
               and can then be further processed to achieve <see cref="T:Accord.Imaging.Moments.CentralMoments"/> or even
               <see cref="T:Accord.Imaging.Moments.HuMoments"/>.</para>
               
             <para>
               References:
               <list type="bullet">
                 <item><description>
                   Wikipedia contributors. "Image moment." Wikipedia, The Free Encyclopedia. Wikipedia,
                   The Free Encyclopedia. Available at http://en.wikipedia.org/wiki/Image_moment </description></item>
               </list>
             </para>
             </remarks>
             
             <example>
             <code>
             Bitmap image = ...;
            
             // Compute the raw moments of up to third order
             RawMoments m = new RawMoments(image, order: 3);
             </code>
             </example>
             
             <seealso cref="T:Accord.Imaging.Moments.HuMoments"/>
             <seealso cref="T:Accord.Imaging.Moments.CentralMoments"/>
             
        </member>
        <member name="F:Accord.Imaging.Moments.RawMoments.DefaultOrder">
            <summary>
              Gets the default maximum moment order.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.M00">
            <summary>
              Raw moment of order (0,0).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.M10">
            <summary>
              Raw moment of order (1,0).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.M01">
            <summary>
              Raw moment of order (0,1).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.M11">
            <summary>
              Raw moment of order (1,1).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.M20">
            <summary>
              Raw moment of order (2,0).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.M02">
            <summary>
              Raw moment of order (0,2).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.M21">
            <summary>
              Raw moment of order (2,1).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.M12">
            <summary>
              Raw moment of order (1,2).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.M30">
            <summary>
              Raw moment of order (3,0).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.M03">
            <summary>
              Raw moment of order (0,3).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.InvM00">
            <summary>
              Inverse raw moment of order (0,0).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.CenterX">
            <summary>
              Gets the X centroid of the image.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.CenterY">
            <summary>
              Gets the Y centroid of the image.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.Moments.RawMoments.Area">
            <summary>
              Gets the area (for binary images) or sum of
              gray level (for grayscale images).
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Moments.RawMoments.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="N:Accord.Imaging.Moments"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Moments.RawMoments.#ctor(System.Drawing.Bitmap,System.Drawing.Rectangle,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="N:Accord.Imaging.Moments"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Moments.RawMoments.#ctor(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="N:Accord.Imaging.Moments"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Moments.RawMoments.#ctor(System.Single[0:,0:],System.Drawing.Rectangle,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="N:Accord.Imaging.Moments"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Moments.RawMoments.#ctor(Accord.Imaging.UnmanagedImage,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="N:Accord.Imaging.Moments"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Moments.RawMoments.#ctor(System.Drawing.Bitmap,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="N:Accord.Imaging.Moments"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Moments.RawMoments.#ctor(System.Single[0:,0:],System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="N:Accord.Imaging.Moments"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Moments.RawMoments.Compute(System.Single[0:,0:],System.Drawing.Rectangle,System.Boolean)">
            <summary>
              Computes the raw moments for the specified image.
            </summary>
            
            <param name="image">The image whose moments should be computed.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            <param name="secondOrder"><c>True</c> to compute second order moments, <c>false</c> otherwise.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.RawMoments.Compute(System.Single[0:,0:],System.Drawing.Rectangle)">
            <summary>
              Computes the raw moments for the specified image.
            </summary>
            
            <param name="image">The image.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.RawMoments.Compute(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
              Computes the raw moments for the specified image.
            </summary>
            
            <param name="image">The image.</param>
            <param name="area">The region of interest in the image to compute moments for.</param>
            
        </member>
        <member name="M:Accord.Imaging.Moments.RawMoments.Reset">
            <summary>
              Resets all moments to zero.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.CorrelationMatching">
             <summary>
               Maximum cross-correlation feature point matching algorithm.
             </summary>
             
             <remarks>
               <para>
                 This class matches feature points by using a maximum cross-correlation measure.</para>
               <para>
                 References:
                 <list type="bullet">
                   <item><description>
                     P. D. Kovesi. MATLAB and Octave Functions for Computer Vision and Image Processing.
                     School of Computer Science and Software Engineering, The University of Western Australia.
                     Available in: <a href="http://www.csse.uwa.edu.au/~pk/Research/MatlabFns/Match/matchbycorrelation.m">
                     http://www.csse.uwa.edu.au/~pk/Research/MatlabFns/Match/matchbycorrelation.m </a>
                   </description></item>
                   <item><description>
                     <a href="http://www.instructor.com.br/unesp2006/premiados/PauloHenrique.pdf">
                     http://www.instructor.com.br/unesp2006/premiados/PauloHenrique.pdf </a>
                   </description></item>
                   <item><description>
                     <a href="http://siddhantahuja.wordpress.com/2010/04/11/correlation-based-similarity-measures-summary/">
                     http://siddhantahuja.wordpress.com/2010/04/11/correlation-based-similarity-measures-summary/ </a>
                   </description></item>
               </list></para>
             </remarks>
            
        </member>
        <member name="P:Accord.Imaging.CorrelationMatching.DistanceMax">
            <summary>
              Gets or sets the maximum distance to consider
              points as correlated. Default is 0 (consider
              all points).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.CorrelationMatching.WindowSize">
            <summary>
              Gets or sets the size of the correlation window.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.CorrelationMatching.#ctor(System.Int32)">
            <summary>
              Constructs a new Correlation Matching algorithm.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.CorrelationMatching.#ctor(System.Int32,System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
              Constructs a new Correlation Matching algorithm.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.CorrelationMatching.#ctor(System.Int32,System.Double)">
            <summary>
              Constructs a new Correlation Matching algorithm.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.CorrelationMatching.#ctor(System.Int32,System.Double,System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
              Constructs a new Correlation Matching algorithm.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.CorrelationMatching.Match(System.Drawing.Bitmap,System.Drawing.Bitmap,System.Collections.Generic.IEnumerable{Accord.IntPoint},System.Collections.Generic.IEnumerable{Accord.IntPoint})">
            <summary>
              Matches two sets of feature points computed from the given images.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.CorrelationMatching.Match(System.Collections.Generic.IEnumerable{Accord.IntPoint},System.Collections.Generic.IEnumerable{Accord.IntPoint})">
            <summary>
              Matches two sets of feature points computed from the given images.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.CorrelationMatching.Match(System.Drawing.Bitmap,System.Drawing.Bitmap,Accord.IntPoint[],Accord.IntPoint[])">
            <summary>
              Matches two sets of feature points computed from the given images.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.CorrelationMatching.Match(Accord.IntPoint[],Accord.IntPoint[])">
            <summary>
              Matches two sets of feature points computed from the given images.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.CorrelationMatching.computeCorrelationMatrix(System.Drawing.Bitmap,Accord.IntPoint[],System.Drawing.Bitmap,Accord.IntPoint[],System.Int32,System.Double)">
            <summary>
              Constructs the correlation matrix between selected points from two images.
            </summary>
            
            <remarks>
              Rows correspond to points from the first image, columns correspond to points
              in the second.
            </remarks>
            
        </member>
        <member name="T:Accord.Imaging.FastCornersDetector">
             <summary>
               Features from Accelerated Segment Test (FAST) corners detector.
             </summary>
             
             <remarks>
             <para>
               In the FAST corner detection algorithm, a pixel is defined as a corner
               if (in a circle surrounding the pixel), N or more contiguous pixels are
               all significantly brighter then or all significantly darker than the center
               pixel. The ordering of questions used to classify a pixel is learned using
               the ID3 algorithm.
             </para>
             
             <para>This detector has been shown to exhibit a high degree of repeatability.</para>
            
             <para>
               The code is roughly based on the 9 valued FAST corner detection
               algorithm implementation in C by Edward Rosten, which has been
               published under a 3-clause BSD license and is freely available at:
               http://svr-www.eng.cam.ac.uk/~er258/work/fast.html. 
             </para>
             
             <para>
               References:
               <list type="bullet">
                 <item><description>
                   E. Rosten, T. Drummond. Fusing Points and Lines for High
                   Performance Tracking, ICCV 2005. </description></item>
                 <item><description>
                   E. Rosten, T. Drummond. Machine learning for high-speed
                   corner detection, ICCV 2005</description></item>
               </list>
             </para>
             </remarks>
             
             <example>
             <code>
               Bitmap image = ... // Lena's famous picture
             
               // Create a new FAST Corners Detector
               FastCornersDetector fast = new FastCornersDetector()
               {
                   Suppress = true, // suppress non-maximum points
                   Threshold = 40   // less leads to more corners
               };
             
               // Process the image looking for corners
               List&lt;IntPoint> points = fast.ProcessImage(image);
             
               // Create a filter to mark the corners
               PointsMarker marker = new PointsMarker(points);
                         
               // Apply the corner-marking filter
               Bitmap markers = marker.Apply(image);
             
               // Show on the screen
               ImageBox.Show(markers);
             </code>
             
             <para>
               The resulting image is shown below:</para>
             
               <img src="..\images\fast.png" />
               
             <para>
               The second example shows how to extract FAST descriptors from a standard test image:</para>
               <code source="Unit Tests\Accord.Tests.Imaging\FastCornersDetectorTest.cs" region="doc_apply" />
             </example>
             
             <seealso cref="T:Accord.Imaging.SpeededUpRobustFeaturesDetector"/>
             <seealso cref="T:Accord.Imaging.FastRetinaKeypointDetector"/>
             
        </member>
        <member name="M:Accord.Imaging.FastCornersDetector.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.FastCornersDetector"/> class.
            </summary>
            
            <param name="threshold">The suppression threshold. Decreasing this value
              increases the number of points detected by the algorithm. Default is 20.</param>
            
        </member>
        <member name="P:Accord.Imaging.FastCornersDetector.Suppress">
            <summary>
              Gets or sets a value indicating whether non-maximum
              points should be suppressed. Default is true.
            </summary>
            
            <value><c>true</c> if non-maximum points should
              be suppressed; otherwise, <c>false</c>.</value>
              
        </member>
        <member name="P:Accord.Imaging.FastCornersDetector.Threshold">
            <summary>
              Gets or sets the corner detection threshold. Increasing this value results in less corners,
              whereas decreasing this value will result in more corners detected by the algorithm.
            </summary>
            
            <value>The corners threshold.</value>
            
        </member>
        <member name="P:Accord.Imaging.FastCornersDetector.Scores">
            <summary>
              Gets the scores of the each corner detected in
              the previous call to <see cref="M:Accord.Imaging.BaseFeatureExtractor`1.Transform(System.Drawing.Bitmap)"/>.
            </summary>
            
            <value>The scores of each last computed corner.</value>
            
        </member>
        <member name="M:Accord.Imaging.FastCornersDetector.InnerProcess(Accord.Imaging.UnmanagedImage)">
            <summary>
            This method should be implemented by inheriting classes to implement the
            actual corners detection, transforming the input image into a list of points.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.FastCornersDetector.Clone(Accord.Compat.ISet{System.Drawing.Imaging.PixelFormat})">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.SpeededUpRobustFeatureDescriptorType">
            <summary>
              SURF Feature descriptor types.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.SpeededUpRobustFeatureDescriptorType.None">
            <summary>
              Do not compute descriptors.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.SpeededUpRobustFeatureDescriptorType.Standard">
            <summary>
              Compute standard descriptors.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.SpeededUpRobustFeatureDescriptorType.Extended">
            <summary>
              Compute extended descriptors.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.SpeededUpRobustFeaturesDetector">
             <summary>
               Speeded-up Robust Features (SURF) detector.
             </summary>
             
             <remarks>
             <para>
               Based on original implementation in the OpenSURF computer vision library
               by Christopher Evans (http://www.chrisevansdev.com). Used under the LGPL
               with permission of the original author.</para>
               
             <para>
               Be aware that the SURF algorithm is a patented algorithm by Anael Orlinski.
               If you plan to use it in a commercial application, you may have to acquire
               a license from the patent holder.</para>
               
             <para>
               References:
               <list type="bullet">
                 <item><description>
                   E. Christopher. Notes on the OpenSURF Library. Available in: 
                   http://sites.google.com/site/chrisevansdev/files/opensurf.pdf</description></item>
                 <item><description>
                   P. D. Kovesi. MATLAB and Octave Functions for Computer Vision and Image Processing.
                   School of Computer Science and Software Engineering, The University of Western Australia.
                   Available in: http://www.csse.uwa.edu.au/~pk/Research/MatlabFns/Spatial/harris.m</description></item>
               </list>
             </para>
             </remarks>
             
             <example>
             <para>
               The first example shows how to extract SURF descriptors from a standard test image:</para>
               <code source="Unit Tests\Accord.Tests.Imaging\SpeededUpRobustFeaturesDetectorTest.cs" region="doc_apply" />
               
             <para>
               The second example shows how to use SURF descriptors as part of a BagOfVisualWords (BoW) pipeline 
               for image classification:</para>
               <code source="Unit Tests\Accord.Tests.Vision\Imaging\BagOfVisualWordsTest.cs" region="doc_learn" />
               <code source="Unit Tests\Accord.Tests.Vision\Imaging\BagOfVisualWordsTest.cs" region="doc_classification" />
             </example>
            
             <seealso cref="T:Accord.Imaging.SpeededUpRobustFeaturePoint"/>
             <seealso cref="T:Accord.Imaging.SpeededUpRobustFeaturesDescriptor"/>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDetector.#ctor(System.Double,System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.SpeededUpRobustFeaturesDetector"/> class.
            </summary>
            
            <param name="threshold">
              The non-maximum suppression threshold. Default is 0.0002f.</param>
            <param name="octaves">
              The number of octaves to use when building the <see cref="T:Accord.Imaging.ResponseLayerCollection">
              response filter</see>. Each octave corresponds to a series of maps covering a
              doubling of scale in the image. Default is 5.</param>
            <param name="initial">
              The initial step to use when building the <see cref="T:Accord.Imaging.ResponseLayerCollection">
              response filter</see>. Default is 2. </param>
              
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturesDetector.ComputeOrientation">
            <summary>
              Gets or sets a value indicating whether all feature points
              should have their orientation computed after being detected.
              Default is true.
            </summary>
            
            <remarks>Computing orientation requires additional processing; 
            set this property to false to compute the orientation of only
            selected points by using the <see cref="M:Accord.Imaging.SpeededUpRobustFeaturesDetector.GetDescriptor">
            current feature descriptor</see> for the last set of detected points.
            </remarks>
            
            <value><c>true</c> if to compute orientation; otherwise, <c>false</c>.</value>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturesDetector.ComputeDescriptors">
            <summary>
              Gets or sets a value indicating whether all feature points
              should have their descriptors computed after being detected.
              Default is to compute standard descriptors.
            </summary>
            
            <remarks>Computing descriptors requires additional processing; 
            set this property to false to compute the descriptors of only
            selected points by using the <see cref="M:Accord.Imaging.SpeededUpRobustFeaturesDetector.GetDescriptor">
            current feature descriptor</see> for the last set of detected points.
            </remarks>
            
            <value><c>true</c> if to compute orientation; otherwise, <c>false</c>.</value>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturesDetector.Threshold">
            <summary>
              Gets or sets the non-maximum suppression
              threshold. Default is 0.0002.
            </summary>
            
            <value>The non-maximum suppression threshold.</value>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturesDetector.Octaves">
            <summary>
              Gets or sets the number of octaves to use when building
              the <see cref="T:Accord.Imaging.ResponseLayerCollection">response filter</see>.
              Each octave corresponds to a series of maps covering a
              doubling of scale in the image. Default is 5.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturesDetector.Step">
            <summary>
              Gets or sets the initial step to use when building
              the <see cref="T:Accord.Imaging.ResponseLayerCollection">response filter</see>.
              Default is 2.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDetector.InnerTransform(Accord.Imaging.UnmanagedImage)">
            <summary>
              This method should be implemented by inheriting classes to implement the 
              actual feature extraction, transforming the input image into a list of features.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDetector.GetDescriptor">
            <summary>
              Gets the <see cref="T:Accord.Imaging.SpeededUpRobustFeaturesDescriptor">
              feature descriptor</see> for the last processed image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDetector.Clone(Accord.Compat.ISet{System.Drawing.Imaging.PixelFormat})">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDetector.Dispose(System.Boolean)">
            <summary>
              Releases unmanaged and - optionally - managed resources.
            </summary>
            
            <param name="disposing"><c>true</c> to release both managed and unmanaged
              resources; <c>false</c> to release only unmanaged resources.</param>
            
        </member>
        <member name="T:Accord.Imaging.HarrisCornerMeasure">
            <summary>
              Corners measures to be used in <see cref="T:Accord.Imaging.HarrisCornersDetector"/>.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.HarrisCornerMeasure.Harris">
            <summary>
              Original Harris' measure. Requires the setting of
              a parameter k (default is 0.04), which may be a
              bit arbitrary and introduce more parameters to tune.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.HarrisCornerMeasure.Noble">
            <summary>
              Noble's measure. Does not require a parameter
              and may be more stable.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.HarrisCornersDetector">
             <summary>
               Harris Corners Detector.
             </summary>
             
             <remarks>
             <para>This class implements the Harris corners detector.</para>
             <para>Sample usage:</para>
             
             <code>
             // create corners detector's instance
             HarrisCornersDetector hcd = new HarrisCornersDetector( );
             // process image searching for corners
             Point[] corners = hcd.ProcessImage( image );
             // process points
             foreach ( Point corner in corners )
             {
                 // ... 
             }
             </code>
             
             <para>
               References:
               <list type="bullet">
                 <item><description>
                   P. D. Kovesi. MATLAB and Octave Functions for Computer Vision and Image Processing.
                   School of Computer Science and Software Engineering, The University of Western Australia.
                   Available in: http://www.csse.uwa.edu.au/~pk/Research/MatlabFns/Spatial/harris.m </description></item>
                 <item><description>
                   C.G. Harris and M.J. Stephens. "A combined corner and edge detector", 
                   Proceedings Fourth Alvey Vision Conference, Manchester.
                   pp 147-151, 1988.</description></item>
                 <item><description>
                   Alison Noble, "Descriptions of Image Surfaces", PhD thesis, Department
                   of Engineering Science, Oxford University 1989, p45.</description></item>
               </list>
             </para>
             </remarks>
             
             <seealso cref="T:Accord.Imaging.MoravecCornersDetector"/>
             <seealso cref="T:Accord.Imaging.SusanCornersDetector"/>
            
        </member>
        <member name="P:Accord.Imaging.HarrisCornersDetector.Measure">
            <summary>
              Gets or sets the measure to use when detecting corners.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HarrisCornersDetector.K">
            <summary>
              Harris parameter k. Default value is 0.04.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HarrisCornersDetector.Threshold">
            <summary>
              Harris threshold. Default value is 20000.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HarrisCornersDetector.Sigma">
            <summary>
              Gaussian smoothing sigma. Default value is 1.2.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.HarrisCornersDetector.Suppression">
            <summary>
              Non-maximum suppression window radius. Default value is 3.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.HarrisCornersDetector.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.HarrisCornersDetector"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.HarrisCornersDetector.#ctor(System.Single)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.HarrisCornersDetector"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.HarrisCornersDetector.#ctor(System.Single,System.Single)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.HarrisCornersDetector"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.HarrisCornersDetector.#ctor(System.Single,System.Single,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.HarrisCornersDetector"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.HarrisCornersDetector.#ctor(System.Single,System.Single,System.Double,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.HarrisCornersDetector"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.HarrisCornersDetector.#ctor(Accord.Imaging.HarrisCornerMeasure,System.Single,System.Double,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.HarrisCornersDetector"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.HarrisCornersDetector.#ctor(Accord.Imaging.HarrisCornerMeasure,System.Single,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.HarrisCornersDetector"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.HarrisCornersDetector.#ctor(Accord.Imaging.HarrisCornerMeasure,System.Single)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.HarrisCornersDetector"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.HarrisCornersDetector.#ctor(Accord.Imaging.HarrisCornerMeasure)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.HarrisCornersDetector"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.HarrisCornersDetector.InnerProcess(Accord.Imaging.UnmanagedImage)">
            <summary>
            This method should be implemented by inheriting classes to implement the
            actual corners detection, transforming the input image into a list of points.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.HarrisCornersDetector.convolve(System.Single[0:,0:],System.Single[0:,0:],System.Single[])">
            <summary>
              Convolution with decomposed 1D kernel.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.HarrisCornersDetector.Clone(Accord.Compat.ISet{System.Drawing.Imaging.PixelFormat})">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.IntegralImage2">
            <summary>
              Joint representation of both Integral Image and Squared Integral Image.
            </summary>
            
            <remarks>
            <para>
              This class provides a unified representation for both <see cref="T:Accord.Imaging.IntegralImage">
              integral images</see>, squared integral images and tilted integral images under
              the same class. This class can be used to provide more efficient transformations
              whenever all those representations are required at the same time, such as when
              using the Viola-Jones (Haar Cascade) object detector.</para>
              
            <para>
              Using this representation, both structures can be created in a single pass
              over the data. This is interesting for real time applications. This class
              also accepts a channel parameter indicating the Integral Image should be
              computed using a specified color channel. This avoids costly conversions.</para>
            </remarks>
            
            <example>
            <code source="Unit Tests\Accord.Tests.Imaging\IntegralImage2Test.cs" region="doc_sum" />
            <code source="Unit Tests\Accord.Tests.Imaging\IntegralImage2Test.cs" region="doc_lena" />
            </example>
            
            <seealso cref="T:Accord.Imaging.IntegralImage"/>
            
        </member>
        <member name="P:Accord.Imaging.IntegralImage2.Width">
            <summary>
              Gets the image's width.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.IntegralImage2.Height">
            <summary>
              Gets the image's height.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.IntegralImage2.Image">
            <summary>
              Gets the Integral Image for values' sum.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.IntegralImage2.Squared">
            <summary>
              Gets the Integral Image for values' squared sum.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.IntegralImage2.Rotated">
            <summary>
              Gets the Integral Image for tilted values' sum.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
              Constructs a new Integral image of the given size.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.FromBitmap(System.Drawing.Bitmap)">
            <summary>
              Constructs a new Integral image from a Bitmap image.
            </summary>
            
            <param name="image">The source image from where the integral image should be computed.</param>
            
            <returns>
              The <see cref="T:Accord.Imaging.IntegralImage2"/> representation of 
              the <paramref name="image">source image</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.FromBitmap(System.Drawing.Bitmap,System.Int32)">
            <summary>
              Constructs a new Integral image from a Bitmap image.
            </summary>
            
            <param name="image">The source image from where the integral image should be computed.</param>
            <param name="channel">The image channel to consider in the computations. Default is 0.</param>
            
            <returns>
              The <see cref="T:Accord.Imaging.IntegralImage2"/> representation of 
              the <paramref name="image">source image</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.FromBitmap(System.Drawing.Bitmap,System.Boolean)">
            <summary>
              Constructs a new Integral image from a Bitmap image.
            </summary>
            
            <param name="image">The source image from where the integral image should be computed.</param>
            <param name="computeTilted"><c>True</c> to compute the tilted version of the integral image,
              <c>false</c> otherwise. Default is false.</param>
            
            <returns>
              The <see cref="T:Accord.Imaging.IntegralImage2"/> representation of 
              the <paramref name="image">source image</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.FromBitmap(System.Drawing.Bitmap,System.Int32,System.Boolean)">
            <summary>
              Constructs a new Integral image from a Bitmap image.
            </summary>
            
            <param name="image">The source image from where the integral image should be computed.</param>
            <param name="channel">The image channel to consider in the computations. Default is 0.</param>
            <param name="computeTilted"><c>True</c> to compute the tilted version of the integral image,
              <c>false</c> otherwise. Default is false.</param>
              
            <returns>
              The <see cref="T:Accord.Imaging.IntegralImage2"/> representation of 
              the <paramref name="image">source image</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.FromBitmap(System.Drawing.Imaging.BitmapData)">
            <summary>
              Constructs a new Integral image from a BitmapData image.
            </summary>
            
            <param name="imageData">The source image from where the integral image should be computed.</param>
            
            <returns>
              The <see cref="T:Accord.Imaging.IntegralImage2"/> representation of 
              the <paramref name="imageData">source image</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.FromBitmap(System.Drawing.Imaging.BitmapData,System.Int32)">
            <summary>
              Constructs a new Integral image from a BitmapData image.
            </summary>
            
            <param name="imageData">The source image from where the integral image should be computed.</param>
            <param name="channel">The image channel to consider in the computations. Default is 0.</param>
            
            <returns>
              The <see cref="T:Accord.Imaging.IntegralImage2"/> representation of 
              the <paramref name="imageData">source image</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.FromBitmap(System.Drawing.Imaging.BitmapData,System.Int32,System.Boolean)">
            <summary>
              Constructs a new Integral image from a BitmapData image.
            </summary>
            
            <param name="imageData">The source image from where the integral image should be computed.</param>
            <param name="channel">The image channel to consider in the computations. Default is 0.</param>
            <param name="computeTilted"><c>True</c> to compute the tilted version of the integral image,
              <c>false</c> otherwise. Default is false.</param>
              
            <returns>
              The <see cref="T:Accord.Imaging.IntegralImage2"/> representation of 
              the <paramref name="imageData">source image</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.FromBitmap(System.Drawing.Imaging.BitmapData,System.Boolean)">
            <summary>
              Constructs a new Integral image from a BitmapData image.
            </summary>
            
            <param name="imageData">The source image from where the integral image should be computed.</param>
            <param name="computeTilted"><c>True</c> to compute the tilted version of the integral image,
              <c>false</c> otherwise. Default is false.</param>
            
            <returns>
              The <see cref="T:Accord.Imaging.IntegralImage2"/> representation of 
              the <paramref name="imageData">source image</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.FromBitmap(Accord.Imaging.UnmanagedImage,System.Int32)">
            <summary>
              Constructs a new Integral image from an unmanaged image.
            </summary>
            
            <param name="image">The source image from where the integral image should be computed.</param>
            <param name="channel">The image channel to consider in the computations. Default is 0.</param>
            
            <returns>
              The <see cref="T:Accord.Imaging.IntegralImage2"/> representation of 
              the <paramref name="image">source image</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.FromBitmap(Accord.Imaging.UnmanagedImage)">
            <summary>
              Constructs a new Integral image from an unmanaged image.
            </summary>
            
            <param name="image">The source image from where the integral image should be computed.</param>
            
            <returns>
              The <see cref="T:Accord.Imaging.IntegralImage2"/> representation of 
              the <paramref name="image">source image</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.FromBitmap(Accord.Imaging.UnmanagedImage,System.Boolean)">
            <summary>
              Constructs a new Integral image from an unmanaged image.
            </summary>
            
            <param name="image">The source image from where the integral image should be computed.</param>
            <param name="computeTilted"><c>True</c> to compute the tilted version of the integral image,
              <c>false</c> otherwise. Default is false.</param>
              
            <returns>
              The <see cref="T:Accord.Imaging.IntegralImage2"/> representation of 
              the <paramref name="image">source image</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.FromBitmap(Accord.Imaging.UnmanagedImage,System.Int32,System.Boolean)">
            <summary>
              Constructs a new Integral image from an unmanaged image.
            </summary>
            
            <param name="image">The source image from where the integral image should be computed.</param>
            <param name="channel">The image channel to consider in the computations. Default is 0.</param>
            <param name="computeTilted"><c>True</c> to compute the tilted version of the integral image,
              <c>false</c> otherwise. Default is false.</param>
            
            <returns>
              The <see cref="T:Accord.Imaging.IntegralImage2"/> representation of 
              the <paramref name="image">source image</paramref>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.Update(Accord.Imaging.UnmanagedImage,System.Int32)">
            <summary>
              Computes the integral image representation from the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.GetSum(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Gets the sum of the pixels in a rectangle of the Integral image.
            </summary>
            
            <param name="x">The horizontal position of the rectangle <c>x</c>.</param>
            <param name="y">The vertical position of the rectangle <c>y</c>.</param>
            <param name="height">The rectangle's height <c>h</c>.</param>
            <param name="width">The rectangle's width <c>w</c>.</param>
            
            <returns>The sum of all pixels contained in the rectangle, computed
              as I[y, x] + I[y + h, x + w] - I[y + h, x] - I[y, x + w].</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.GetSum2(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Gets the sum of the squared pixels in a rectangle of the Integral image.
            </summary>
            
            <param name="x">The horizontal position of the rectangle <c>x</c>.</param>
            <param name="y">The vertical position of the rectangle <c>y</c>.</param>
            <param name="height">The rectangle's height <c>h</c>.</param>
            <param name="width">The rectangle's width <c>w</c>.</param>
            
            <returns>The sum of all pixels contained in the rectangle, computed
              as IÂ²[y, x] + IÂ²[y + h, x + w] - IÂ²[y + h, x] - IÂ²[y, x + w].</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.GetSumT(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Gets the sum of the pixels in a tilted rectangle of the Integral image.
            </summary>
            
            <param name="x">The horizontal position of the rectangle <c>x</c>.</param>
            <param name="y">The vertical position of the rectangle <c>y</c>.</param>
            <param name="height">The rectangle's height <c>h</c>.</param>
            <param name="width">The rectangle's width <c>w</c>.</param>
            
            <returns>The sum of all pixels contained in the rectangle, computed
              as T[y + w, x + w + 1] + T[y + h, x - h + 1] - T[y, x + 1] - T[y + w + h, x + w - h + 1].</returns>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.Dispose">
            <summary>
              Performs application-defined tasks associated with freeing,
              releasing, or resetting unmanaged resources.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.Finalize">
            <summary>
              Releases unmanaged resources and performs other cleanup operations 
              before the <see cref="T:Accord.Imaging.IntegralImage2"/> is reclaimed by garbage collection.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.IntegralImage2.Dispose(System.Boolean)">
            <summary>
              Releases unmanaged and - optionally - managed resources
            </summary>
            
            <param name="disposing"><c>true</c> to release both managed 
            and unmanaged resources; <c>false</c> to release only unmanaged
            resources.</param>
            
        </member>
        <member name="T:Accord.Imaging.SpeededUpRobustFeaturePoint">
            <summary>
              Speeded-Up Robust Feature (SURF) Point.
            </summary>
            
            <seealso cref="T:Accord.Imaging.SpeededUpRobustFeaturesDetector"/>
            <seealso cref="T:Accord.Imaging.SpeededUpRobustFeaturesDescriptor"/>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturePoint.#ctor(System.Double,System.Double,System.Double,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.SpeededUpRobustFeaturePoint"/> class.
            </summary>
            
            <param name="x">The x-coordinate of the point in the image.</param>
            <param name="y">The y-coordinate of the point in the image.</param>
            <param name="scale">The point's scale.</param>
            <param name="laplacian">The point's laplacian value.</param>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturePoint.#ctor(System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.SpeededUpRobustFeaturePoint"/> class.
            </summary>
            
            <param name="x">The x-coordinate of the point in the image.</param>
            <param name="y">The y-coordinate of the point in the image.</param>
            <param name="scale">The point's scale.</param>
            <param name="laplacian">The point's laplacian value.</param>
            <param name="orientation">The point's orientation angle.</param>
            <param name="response">The point's response value.</param>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturePoint.#ctor(System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Double[])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.SpeededUpRobustFeaturePoint"/> class.
            </summary>
            
            <param name="x">The x-coordinate of the point in the image.</param>
            <param name="y">The y-coordinate of the point in the image.</param>
            <param name="scale">The point's scale.</param>
            <param name="laplacian">The point's Laplacian value.</param>
            <param name="descriptor">The SURF point descriptor.</param>
            <param name="orientation">The point's orientation angle.</param>
            <param name="response">The point's response value.</param>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturePoint.X">
            <summary>
              Gets or sets the x-coordinate of this point.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturePoint.Y">
            <summary>
              Gets or sets the y-coordinate of this point.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturePoint.Scale">
            <summary>
              Gets or sets the scale of the point.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturePoint.Response">
            <summary>
              Gets or sets the response of the detected feature (strength).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturePoint.Orientation">
            <summary>
              Gets or sets the orientation of this point
              measured anti-clockwise from the x-axis.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturePoint.Laplacian">
            <summary>
              Gets or sets the sign of laplacian for this point
              (which may be useful for fast matching purposes).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturePoint.Descriptor">
            <summary>
              Gets or sets the descriptor vector
              associated with this point.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturePoint.ToIntPoint">
            <summary>
              Converts the feature point to a <see cref="T:Accord.IntPoint"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturePoint.ToPoint">
            <summary>
              Converts this object into a <see cref="T:Accord.IntPoint"/>.
            </summary>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturePoint.ToPointF">
            <summary>
              Converts this object into a <see cref="T:System.Drawing.PointF"/>.
            </summary>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturePoint.op_Implicit(Accord.Imaging.SpeededUpRobustFeaturePoint)~System.Drawing.Point">
            <summary>
              Performs an implicit conversion from <see cref="T:Accord.Imaging.SpeededUpRobustFeaturePoint"/>
              to <see cref="T:System.Drawing.Point"/>.
            </summary>
            
            <param name="point">The point to be converted.</param>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturePoint.op_Implicit(Accord.Imaging.SpeededUpRobustFeaturePoint)~System.Drawing.PointF">
            <summary>
              Performs an implicit conversion from <see cref="T:Accord.Imaging.SpeededUpRobustFeaturePoint"/>
              to <see cref="T:System.Drawing.PointF"/>.
            </summary>
            
            <param name="point">The point to be converted.</param>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturePoint.op_Implicit(Accord.Imaging.SpeededUpRobustFeaturePoint)~Accord.IntPoint">
            <summary>
              Performs an implicit conversion from <see cref="T:Accord.Imaging.SpeededUpRobustFeaturePoint"/>
              to <see cref="T:Accord.IntPoint"/>.
            </summary>
            
            <param name="point">The point to be converted.</param>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="T:Accord.Imaging.MatrixH">
            <summary>
              Encapsulates a 3-by-3 general transformation matrix
              that represents a (possibly) non-linear transform. 
            </summary>
            
            <remarks>
            <para>
              Linear transformations are not the only ones that can be represented by
              matrices. Using homogeneous coordinates, both affine transformations and
              perspective projections on R^n can be represented as linear transformations
              on R^n+1 (that is, n+1-dimensional real projective space).</para>
            <para>
              The general transformation matrix has 8 degrees of freedom, as the last
              element is just a scale parameter.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.#ctor">
            <summary>
              Creates a new projective matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
              Creates a new projective matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
              Creates a new projective matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.#ctor(System.Single[])">
            <summary>
              Creates a new projective matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.#ctor(System.Double[0:,0:])">
            <summary>
              Creates a new projective matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.#ctor(System.Single[0:,0:])">
            <summary>
              Creates a new projective matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.MatrixH.Elements">
            <summary>
              Gets the elements of this matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.MatrixH.OffsetX">
            <summary>
              Gets the offset x
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.MatrixH.OffsetY">
            <summary>
              Gets the offset y
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.MatrixH.IsInvertible">
            <summary>
              Gets whether this matrix is invertible.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.MatrixH.IsAffine">
            <summary>
              Gets whether this is an Affine transformation matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.MatrixH.IsIdentity">
            <summary>
              Gets whether this is the identity transformation.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.Reset">
            <summary>
              Resets this matrix to be the identity.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.Inverse">
            <summary>
              Returns the inverse matrix, if this matrix is invertible.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.Transpose">
            <summary>
              Gets the transpose of this transformation matrix.
            </summary>
            
            <returns>The transposed version of this matrix, given by <c>H'</c>.</returns>
        </member>
        <member name="M:Accord.Imaging.MatrixH.TransformPoints(Accord.Imaging.PointH[])">
            <summary>
              Transforms the given points using this transformation matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.TransformPoints(System.Drawing.PointF[])">
            <summary>
              Transforms the given points using this transformation matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.Multiply(Accord.Imaging.MatrixH)">
            <summary>
              Multiplies this matrix, returning a new matrix as result.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.Equals(System.Object)">
            <summary>
              Compares two objects for equality.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.GetHashCode">
            <summary>
              Returns the hash code for this instance.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.op_Explicit(Accord.Imaging.MatrixH)~System.Double[0:,0:]">
            <summary>
              Double[,] conversion.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.op_Explicit(Accord.Imaging.MatrixH)~System.Single[0:,0:]">
            <summary>
              Single[,] conversion.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.ToDoubleArray">
            <summary>
              Double[,] conversion.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.ToSingleArray">
            <summary>
              Single[,] conversion.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.MatrixH.op_Multiply(Accord.Imaging.MatrixH,Accord.Imaging.MatrixH)">
            <summary>
              Matrix multiplication.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.PointH">
            <summary>
              Represents an ordered pair of real x- and y-coordinates and scalar w that defines
              a point in a two-dimensional plane using homogeneous coordinates.
            </summary>
            
            <remarks>
            <para>
              In mathematics, homogeneous coordinates are a system of coordinates used in
              projective geometry much as Cartesian coordinates are used in Euclidean geometry.</para>
            <para>
              They have the advantage that the coordinates of a point, even those at infinity,
              can be represented using finite coordinates. Often formulas involving homogeneous
              coordinates are simpler and more symmetric than their Cartesian counterparts.</para>
            <para>
              Homogeneous coordinates have a range of applications, including computer graphics,
              where they allow affine transformations and, in general, projective transformations
              to be easily represented by a matrix.</para>
              
            <para>
              References: 
              <list type="bullet">
                <item><description>
                  http://alumnus.caltech.edu/~woody/docs/3dmatrix.html</description></item>
                <item><description>
                  http://simply3d.wordpress.com/2009/05/29/homogeneous-coordinates/</description></item>
              </list></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.PointH.X">
            <summary>
              The first coordinate.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.PointH.Y">
            <summary>
              The second coordinate.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.PointH.W">
            <summary>
              The inverse scaling factor for X and Y.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.#ctor(System.Single,System.Single)">
            <summary>
              Creates a new point.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.#ctor(System.Double,System.Double)">
            <summary>
              Creates a new point.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.#ctor(System.Single,System.Single,System.Single)">
            <summary>
              Creates a new point.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.#ctor(System.Double,System.Double,System.Double)">
            <summary>
              Creates a new point.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.Transform(System.Single[0:,0:])">
            <summary>
              Transforms a point using a projection matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.Normalize">
            <summary>
              Normalizes the point to have unit scale.
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.PointH.IsNormalized">
            <summary>
              Gets whether this point is normalized (w = 1).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.PointH.IsAtInfinity">
            <summary>
              Gets whether this point is at infinity (w = 0).
            </summary>
            
        </member>
        <member name="P:Accord.Imaging.PointH.IsEmpty">
            <summary>
              Gets whether this point is at the origin.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.ToArray">
            <summary>
              Converts the point to a array representation.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.op_Multiply(Accord.Imaging.PointH,System.Single)">
            <summary>
              Multiplication by scalar.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.op_Multiply(System.Single,Accord.Imaging.PointH)">
            <summary>
              Multiplication by scalar.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.Multiply(System.Single)">
            <summary>
              Multiplies the point by a scalar.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.op_Subtraction(Accord.Imaging.PointH,Accord.Imaging.PointH)">
            <summary>
              Subtraction.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.Subtract(Accord.Imaging.PointH)">
            <summary>
              Subtracts the values of two points.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.op_Addition(Accord.Imaging.PointH,Accord.Imaging.PointH)">
            <summary>
              Addition.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.Add(Accord.Imaging.PointH)">
            <summary>
              Add the values of two points.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.op_Equality(Accord.Imaging.PointH,Accord.Imaging.PointH)">
            <summary>
              Equality.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.op_Inequality(Accord.Imaging.PointH,Accord.Imaging.PointH)">
            <summary>
              Inequality
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.op_Implicit(Accord.Imaging.PointH)~System.Drawing.PointF">
            <summary>
              PointF Conversion.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.Ceiling(Accord.Imaging.PointH)">
            <summary>
              Converts to a Integer point by computing the ceiling of the point coordinates. 
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.Round(Accord.Imaging.PointH)">
            <summary>
              Converts to a Integer point by rounding the point coordinates. 
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.Truncate(Accord.Imaging.PointH)">
            <summary>
              Converts to a Integer point by truncating the point coordinates. 
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.Equals(System.Object)">
            <summary>
              Compares two objects for equality.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.PointH.GetHashCode">
            <summary>
              Returns the hash code for this instance.
            </summary>
            
        </member>
        <member name="F:Accord.Imaging.PointH.Empty">
            <summary>
              Returns the empty point.
            </summary>
            
        </member>
        <member name="T:Accord.Imaging.SpeededUpRobustFeaturesDescriptor">
             <summary>
               Speeded-Up Robust Features (SURF) Descriptor.
             </summary>
             
             <seealso cref="T:Accord.Imaging.SpeededUpRobustFeaturesDetector"/>
             <seealso cref="T:Accord.Imaging.SpeededUpRobustFeaturePoint"/>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturesDescriptor.Invariant">
            <summary>
              Gets or sets a value indicating whether the features
              described by this <see cref="T:Accord.Imaging.SpeededUpRobustFeaturesDescriptor"/> should
              be invariant to rotation. Default is true.
            </summary>
            
            <value><c>true</c> for rotation invariant features; <c>false</c> otherwise.</value>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturesDescriptor.Extended">
            <summary>
              Gets or sets a value indicating whether the features
              described by this <see cref="T:Accord.Imaging.SpeededUpRobustFeaturesDescriptor"/> should
              be computed in extended form. Default is false.
            </summary>
            
            <value><c>true</c> for extended features; <c>false</c> otherwise.</value>
            
        </member>
        <member name="P:Accord.Imaging.SpeededUpRobustFeaturesDescriptor.Image">
            <summary>
              Gets the <see cref="T:Accord.Imaging.IntegralImage"/> of
              the original source's feature detector.
            </summary>
            
            <value>The integral image from where the
            features have been detected.</value>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDescriptor.#ctor(Accord.Imaging.IntegralImage)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Imaging.SpeededUpRobustFeaturesDescriptor"/> class.
            </summary>
            
            <param name="integralImage">
              The integral image which is the source of the feature points.
            </param>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDescriptor.Compute(Accord.Imaging.SpeededUpRobustFeaturePoint)">
            <summary>
              Describes the specified point (i.e. computes and
              sets the orientation and descriptor vector fields
              of the <see cref="T:Accord.Imaging.SpeededUpRobustFeaturePoint"/>.
            </summary>
            
            <param name="point">The point to be described.</param>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDescriptor.Compute(System.Collections.Generic.IEnumerable{Accord.Imaging.SpeededUpRobustFeaturePoint})">
            <summary>
              Describes all specified points (i.e. computes and
              sets the orientation and descriptor vector fields
              of each <see cref="T:Accord.Imaging.SpeededUpRobustFeaturePoint"/>.
            </summary>
            
            <param name="points">The list of points to be described.</param>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDescriptor.GetOrientation(Accord.Imaging.SpeededUpRobustFeaturePoint)">
            <summary>
              Determine dominant orientation for the feature point.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDescriptor.GetOrientation(System.Int32,System.Int32,System.Int32)">
            <summary>
              Determine dominant orientation for feature point.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDescriptor.GetDescriptor(System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
              Construct descriptor vector for this interest point
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDescriptor.gaussian(System.Int32,System.Int32,System.Double)">
            <summary>
              Get the value of the Gaussian with std dev sigma at the point (x,y)
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDescriptor.gaussian(System.Double,System.Double,System.Double)">
            <summary>
              Get the value of the Gaussian with std dev sigma at the point (x,y)
            </summary>
        </member>
        <member name="F:Accord.Imaging.SpeededUpRobustFeaturesDescriptor.gauss25">
            <summary>
              Gaussian look-up table for sigma = 2.5
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.SpeededUpRobustFeaturesDescriptor.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="T:Accord.Imaging.Tools">
            <summary>
              Static tool functions for imaging.
            </summary>
            
            <remarks>
              <para>
                References:
                <list type="bullet">
                  <item><description>
                    P. D. Kovesi. MATLAB and Octave Functions for Computer Vision and Image Processing.
                    School of Computer Science and Software Engineering, The University of Western Australia.
                    Available in: <a href="http://www.csse.uwa.edu.au/~pk/Research/MatlabFns/Match/matchbycorrelation.m">
                    http://www.csse.uwa.edu.au/~pk/Research/MatlabFns/Match/matchbycorrelation.m </a>
                  </description></item>
              </list></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Center(System.Drawing.Rectangle)">
            <summary>
              Computes the center of a given rectangle.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Tools.IsEqual(System.Drawing.Rectangle,System.Drawing.Rectangle,System.Int32)">
            <summary>
              Compares two rectangles for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Tools.Homography(Accord.Imaging.PointH[],Accord.Imaging.PointH[])">
            <summary>
              Creates an homography matrix matching points
              from a set of points to another.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Tools.Homography(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>
              Creates an homography matrix matching points
              from a set of points to another.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Fundamental(Accord.Imaging.PointH[],Accord.Imaging.PointH[],Accord.Imaging.PointH[]@)">
            <summary>
              Creates the fundamental matrix between two
              images from a set of points from each image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Fundamental(Accord.Imaging.PointH[],Accord.Imaging.PointH[])">
            <summary>
              Creates the fundamental matrix between two
              images from a set of points from each image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Fundamental(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>
              Creates the fundamental matrix between two
              images from a set of points from each image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Normalize(Accord.Imaging.PointH[],Accord.Imaging.MatrixH@)">
            <summary>
              Normalizes a set of homogeneous points so that the origin is located
              at the centroid and the mean distance to the origin is sqrt(2).
            </summary>
        </member>
        <member name="M:Accord.Imaging.Tools.Normalize(System.Drawing.PointF[],Accord.Imaging.MatrixH@)">
            <summary>
              Normalizes a set of homogeneous points so that the origin is located
              at the centroid and the mean distance to the origin is sqrt(2).
            </summary>
        </member>
        <member name="M:Accord.Imaging.Tools.Normalize(System.Drawing.PointF[],System.Single[0:,0:]@)">
            <summary>
              Normalizes a set of homogeneous points so that the origin is located
              at the centroid and the mean distance to the origin is sqrt(2).
            </summary>
        </member>
        <member name="M:Accord.Imaging.Tools.Normalize(Accord.Imaging.PointH[],System.Single[0:,0:]@)">
            <summary>
              Normalizes a set of homogeneous points so that the origin is located
              at the centroid and the mean distance to the origin is sqrt(2).
            </summary>
        </member>
        <member name="M:Accord.Imaging.Tools.Collinear(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
              Detects if three points are collinear.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Collinear(Accord.Imaging.PointH,Accord.Imaging.PointH,Accord.Imaging.PointH)">
            <summary>
              Detects if three points are collinear.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.CopyResolutionFrom(System.Drawing.Bitmap,System.Drawing.Bitmap)">
            <summary>
            Copies the horizontal and vertical resolution specifications
            from a source Bitmap image and stores in a destination image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Sum(System.Drawing.Bitmap)">
            <summary>
              Computes the sum of the pixels in a given image.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Tools.Sum(System.Drawing.Imaging.BitmapData)">
            <summary>
              Computes the sum of the pixels in a given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Sum(Accord.Imaging.UnmanagedImage)">
            <summary>
              Computes the sum of the pixels in a given image.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Tools.Sum(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
              Computes the sum of the pixels in a given image.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Tools.Sum(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
              Computes the sum of the pixels in a given image.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Tools.Sum(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
              Computes the sum of the pixels in a given image.
            </summary>
        </member>
        <member name="M:Accord.Imaging.Tools.Mean(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
              Computes the arithmetic mean of the pixels in a given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Mean(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
              Computes the arithmetic mean of the pixels in a given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Mean(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
              Computes the arithmetic mean of the pixels in a given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Mean(System.Drawing.Bitmap)">
            <summary>
              Computes the arithmetic mean of the pixels in a given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Mean(System.Drawing.Imaging.BitmapData)">
            <summary>
              Computes the arithmetic mean of the pixels in a given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Mean(Accord.Imaging.UnmanagedImage)">
            <summary>
              Computes the arithmetic mean of the pixels in a given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.StandardDeviation(System.Drawing.Bitmap,System.Double)">
            <summary>
              Computes the standard deviation of image pixels.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.StandardDeviation(System.Drawing.Imaging.BitmapData,System.Double)">
            <summary>
              Computes the standard deviation of image pixels.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.StandardDeviation(Accord.Imaging.UnmanagedImage,System.Double)">
            <summary>
              Computes the standard deviation of image pixels.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.StandardDeviation(System.Drawing.Bitmap,System.Drawing.Rectangle,System.Double)">
            <summary>
              Computes the standard deviation of image pixels.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.StandardDeviation(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle,System.Double)">
            <summary>
              Computes the standard deviation of image pixels.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.StandardDeviation(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle,System.Double)">
            <summary>
              Computes the standard deviation of image pixels.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Max(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
              Computes the maximum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Max(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
              Computes the maximum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Max(Accord.Imaging.UnmanagedImage)">
            <summary>
              Computes the maximum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Max(Accord.Imaging.UnmanagedImage,System.Int32)">
            <summary>
              Computes the maximum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Min(Accord.Imaging.UnmanagedImage,System.Int32)">
            <summary>
              Computes the maximum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Max(System.Drawing.Bitmap)">
            <summary>
              Computes the maximum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Max(System.Drawing.Bitmap,System.Int32)">
            <summary>
              Computes the maximum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Max(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
              Computes the maximum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Min(System.Drawing.Imaging.BitmapData,System.Drawing.Rectangle)">
            <summary>
              Computes the minimum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Min(Accord.Imaging.UnmanagedImage)">
            <summary>
              Computes the minimum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Min(Accord.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
              Computes the minimum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Min(System.Drawing.Bitmap)">
            <summary>
              Computes the maximum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Min(System.Drawing.Bitmap,System.Int32)">
            <summary>
              Computes the maximum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Min(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
              Computes the maximum pixel value in the given image.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.ToBitmap(System.Byte[0:,0:])">
            <summary>
              Converts an image given as a matrix of pixel values into a <see cref="T:System.Drawing.Bitmap"/>.
              For more options, please use the <see cref="T:Accord.Imaging.Converters.MatrixToImage"/> class.
            </summary>
            
            <param name="pixels">A matrix containing the grayscale pixel
            values as <see cref="T:System.Double">bytes</see>.</param>
            <returns>A <see cref="T:System.Drawing.Bitmap"/> of the same width
            and height as the pixel matrix containing the given pixel values.</returns>
            
            <seealso cref="T:Accord.Imaging.Converters.MatrixToImage"/>
            
        </member>
        <member name="M:Accord.Imaging.Tools.ToBitmap(System.Int16[0:,0:])">
            <summary>
              Converts an image given as a matrix of pixel values into a <see cref="T:System.Drawing.Bitmap"/>.
              For more options, please use the <see cref="T:Accord.Imaging.Converters.MatrixToImage"/> class.
            </summary>
            
            <param name="pixels">A matrix containing the grayscale pixel
            values as <see cref="T:System.Double">bytes</see>.</param>
            <returns>A <see cref="T:System.Drawing.Bitmap"/> of the same width
            and height as the pixel matrix containing the given pixel values.</returns>
            
            <seealso cref="T:Accord.Imaging.Converters.MatrixToImage"/>
            
        </member>
        <member name="M:Accord.Imaging.Tools.ToBitmap(System.Double[0:,0:])">
            <summary>
              Converts an image given as a matrix of pixel values into a <see cref="T:System.Drawing.Bitmap"/>.
              For more options, please use the <see cref="T:Accord.Imaging.Converters.MatrixToImage"/> class.
            </summary>
            
            <param name="pixels">A matrix containing the grayscale pixel
            values as <see cref="T:System.Double">bytes</see>.</param>
            <returns>A <see cref="T:System.Drawing.Bitmap"/> of the same width
            and height as the pixel matrix containing the given pixel values.</returns>
            
            <seealso cref="T:Accord.Imaging.Converters.MatrixToImage"/>
            
        </member>
        <member name="M:Accord.Imaging.Tools.ToBitmap(System.Int32[0:,0:])">
            <summary>
              Converts an image given as a matrix of pixel values into a <see cref="T:System.Drawing.Bitmap"/>.
              For more options, please use the <see cref="T:Accord.Imaging.Converters.MatrixToImage"/> class.
            </summary>
            
            <param name="pixels">A matrix containing the grayscale pixel
            values as <see cref="T:System.Double">bytes</see>.</param>
            <returns>A <see cref="T:System.Drawing.Bitmap"/> of the same width
            and height as the pixel matrix containing the given pixel values.</returns>
            
            <seealso cref="T:Accord.Imaging.Converters.MatrixToImage"/>
            
        </member>
        <member name="M:Accord.Imaging.Tools.ToBitmap(System.Single[0:,0:])">
            <summary>
              Converts an image given as a matrix of pixel values into a <see cref="T:System.Drawing.Bitmap"/>.
              For more options, please use the <see cref="T:Accord.Imaging.Converters.MatrixToImage"/> class.
            </summary>
            
            <param name="pixels">A matrix containing the grayscale pixel
            values as <see cref="T:System.Double">bytes</see>.</param>
            <returns>A <see cref="T:System.Drawing.Bitmap"/> of the same width
            and height as the pixel matrix containing the given pixel values.</returns>
            
            <seealso cref="T:Accord.Imaging.Converters.MatrixToImage"/>
            
        </member>
        <member name="M:Accord.Imaging.Tools.ToMatrix(System.Drawing.Bitmap)">
            <summary>
              Converts an image given as a <see cref="T:System.Drawing.Bitmap"/> into a matrix of 
              pixel values.For more options, please use the <see cref="T:Accord.Imaging.Converters.MatrixToImage"/> class.
            </summary>
            
            <param name="bitmap">A image represented as a bitmap.</param>
            
            <returns>A matrix containing the values of each pixel in the bitmap.</returns>
            
            <seealso cref="T:Accord.Imaging.Converters.ImageToMatrix"/>
            
        </member>
        <member name="M:Accord.Imaging.Tools.ToJagged(System.Drawing.Bitmap)">
            <summary>
              Converts an image given as a <see cref="T:System.Drawing.Bitmap"/> into a matrix of 
              pixel values.For more options, please use the <see cref="T:Accord.Imaging.Converters.MatrixToImage"/> class.
            </summary>
            
            <param name="bitmap">A image represented as a bitmap.</param>
            
            <returns>A matrix containing the values of each pixel in the bitmap.</returns>
            
            <seealso cref="T:Accord.Imaging.Converters.ImageToMatrix"/>
            
        </member>
        <member name="M:Accord.Imaging.Tools.ToMatrix(System.Drawing.Bitmap,System.Int32)">
            <summary>
              Converts an image given as a <see cref="T:System.Drawing.Bitmap"/> into a matrix of 
              pixel values.For more options, please use the <see cref="T:Accord.Imaging.Converters.MatrixToImage"/> class.
            </summary>
            
            <param name="bitmap">A image represented as a bitmap.</param>
            <param name="channel">The color channel to be extracted.</param>
            
            <returns>A matrix containing the values of each pixel in the bitmap.</returns>
            
            <seealso cref="T:Accord.Imaging.Converters.ImageToMatrix"/>
            
        </member>
        <member name="M:Accord.Imaging.Tools.ToJagged(System.Drawing.Bitmap,System.Int32)">
            <summary>
              Converts an image given as a <see cref="T:System.Drawing.Bitmap"/> into a matrix of 
              pixel values.For more options, please use the <see cref="T:Accord.Imaging.Converters.MatrixToImage"/> class.
            </summary>
            
            <param name="bitmap">A image represented as a bitmap.</param>
            <param name="channel">The color channel to be extracted.</param>
            
            <returns>A matrix containing the values of each pixel in the bitmap.</returns>
            
            <seealso cref="T:Accord.Imaging.Converters.ImageToMatrix"/>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Multiply(System.Drawing.PointF,System.Single[0:,0:])">
            <summary>
              Multiplies a point by a transformation matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.Multiply(System.Single[0:,0:],System.Drawing.PointF)">
            <summary>
              Multiplies a transformation matrix and a point.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.InnerProduct(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
              Computes the inner product of two points.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.TransformPoints(System.Single[0:,0:],System.Drawing.PointF[])">
            <summary>
              Transforms the given points using this transformation matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.GetFormat(System.String)">
            <summary>
              Gets the image format most likely associated with a given file name.
            </summary>
            
            <param name="fileName">The filename in the form "image.jpg".</param>
            
            <returns>The <see cref="T:System.Drawing.Imaging.ImageFormat"/> most likely associated with
              the given <paramref name="fileName"/>.</returns>
            
        </member>
        <member name="M:Accord.Imaging.Tools.LockBits(System.Drawing.Bitmap,System.Drawing.Imaging.ImageLockMode)">
            <summary>
              Locks a Bitmap into system memory.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.LockBits``1(System.Drawing.Bitmap,System.Drawing.Imaging.ImageLockMode,System.Func{Accord.Imaging.UnmanagedImage,``0})">
            <summary>
              Locks a Bitmap into system memory and executes an operation with a 
              <see cref="T:Accord.Imaging.UnmanagedImage"/> that points to this memory location.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.Tools.LockBits``1(System.Drawing.Bitmap,System.Drawing.Imaging.ImageLockMode,System.Action{Accord.Imaging.UnmanagedImage})">
            <summary>
              Locks a Bitmap into system memory and executes an operation with a 
              <see cref="T:Accord.Imaging.UnmanagedImage"/> that points to this memory location.
            </summary>
            
        </member>
    </members>
</doc>
